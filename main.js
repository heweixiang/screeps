'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/* 存放全局方法 */
/*  判定是否在列表里 */
function isInArray(arr, value) {
    for (var i = 0; i < arr.length; i++) {
        if (value === arr[i]) {
            return true;
        }
    }
    return false;
}
/* 用于多structure类型的filter判断 */
function filter_structure(structure, arr) {
    return isInArray(arr, structure.structureType);
}
/* 寻找列表中hit最小且没有超过指定值的建筑  模式0 为hit最小， 模式1为hit差值最小 模式2为hits/hitsMax比值最小*/
function LeastHit(arr, mode = 0, radio) {
    if (arr.length > 0) {
        var ret = arr[0];
        if (mode == 0) {
            for (var index of arr) {
                if (index.hits < ret.hits)
                    ret = index;
            }
            return ret;
        }
        if (mode == 1) {
            for (var index of arr) {
                if ((index.hitsMax - index.hits) > (ret.hitsMax - ret.hits))
                    ret = index;
            }
            return ret;
        }
        if (mode == 2) {
            for (var index of arr) {
                if ((index.hits / index.hitsMax) < (ret.hits / ret.hitsMax))
                    ret = index;
            }
            if (radio) {
                if (ret.hits / ret.hitsMax < radio)
                    return ret;
                else
                    return undefined;
            }
            else {
                return ret;
            }
        }
    }
    return undefined;
}
/* 获取两点间距离(勾股定理) */
function getDistance(po1, po2) {
    return Math.sqrt((po1.x - po2.x) ** 2 + (po1.y - po2.y) ** 2);
}
/* 生成爬虫指定体型 */
function GenerateAbility(work, carry, move, attack, range_attack, heal, claim, tough, role) {
    var body_list = [];
    // 生成优先级，越往前越优先
    if (tough)
        body_list = AddList(body_list, tough, TOUGH);
    switch (role) {
        case 'power-attack':
            if (move)
                body_list = AddList(body_list, move - 1, MOVE);
            if (attack)
                body_list = AddList(body_list, attack, ATTACK);
            if (move)
                body_list = AddList(body_list, 1, MOVE);
            break;
        case 'out-attack':
            if (move)
                body_list = AddList(body_list, move - 2, MOVE);
            if (attack)
                body_list = AddList(body_list, attack, ATTACK);
            if (heal)
                body_list = AddList(body_list, heal - 1, HEAL);
            if (move)
                body_list = AddList(body_list, 2, MOVE);
            if (heal)
                body_list = AddList(body_list, 1, HEAL);
            break;
        default:
            if (work)
                body_list = AddList(body_list, work, WORK);
            if (attack)
                body_list = AddList(body_list, attack, ATTACK);
            if (range_attack)
                body_list = AddList(body_list, range_attack, RANGED_ATTACK);
            if (carry)
                body_list = AddList(body_list, carry, CARRY);
            if (claim)
                body_list = AddList(body_list, claim, CLAIM);
            if (move)
                body_list = AddList(body_list, move, MOVE);
            if (heal)
                body_list = AddList(body_list, heal, HEAL);
            break;
    }
    return body_list;
}
// 用于对bodypartconstant[] 列表进行自适应化，使得爬虫房间能生产该爬虫，具体逻辑为寻找该bodypart中数量最多的，对其进行减法运算，直到达到目的，但数量到1时将不再减少
function adaption_body(arr, critical_num) {
    // 先统计其他部件和move部件比值
    let move_num = arr.filter(part => part === 'move').length;
    let other_num = arr.length - move_num;
    // 处理没有move部件的爬，比如某些挖过道的爬
    let ratio = move_num ? Math.ceil(other_num / move_num) : 10000;
    // 处理只有move部件的爬
    ratio = ratio < 1 ? 1 : ratio;
    while (CalculateEnergy(arr) > critical_num) {
        // 这里有个隐藏bug，某个部件可能会被减没，不过一般没事，摆烂了
        if (critical_num < 300)
            return arr;
        let m_body = most_body(arr);
        if (!m_body) {
            return arr;
        }
        var index = arr.indexOf(m_body);
        if (index > -1) {
            arr.splice(index, 1);
            // 如果最多的部件已经是move部件了，不再重复进行下面move部件的删除
            if (m_body === 'move') {
                move_num--;
                continue;
            }
            other_num--;
        }
        // 同时删除move部件，至少留一个move部件
        if (move_num > 1 && (other_num / (move_num - 1) <= ratio)) {
            let move_index = arr.indexOf('move');
            if (move_index > -1) {
                arr.splice(move_index, 1);
                move_num--;
            }
        }
    }
    return arr;
}
// 寻找身体部件中数量最多的部件
function most_body(arr) {
    let bN = {};
    if (!arr || arr.length <= 0) {
        console.log("【自适应】列表有问题");
        return null;
    }
    for (let bc of arr) {
        if (!bN[bc])
            bN[bc] = getSameNum(bc, arr);
    }
    let bM = null;
    if (Object.keys(bN).length == 1)
        return arr[0];
    for (let i in bN) {
        if (bN[i] > 1 && ((bM == null) ? (bN[i] > 1) : ((bN[i] > bN[bM]) || (bN[i] == bN[bM] && i !== 'move'))))
            bM = i;
    }
    if (!bM) {
        console.log("【自适应】查找最多部件数量错误 arr:", arr);
        return null;
    }
    return bM;
}
/**
     * 获取数组中相同元素的个数
     * @param val 相同的元素
     * @param arr 传入数组
     */
function getSameNum(val, arr) {
    var processArr = [];
    for (var i of arr) {
        if (i == val)
            processArr.push(i);
    }
    return processArr.length;
}
/* 判断孵化所需能量 */
function CalculateEnergy(abilityList) {
    var num = 0;
    for (var part of abilityList) {
        if (part == WORK)
            num += 100;
        if (part == MOVE)
            num += 50;
        if (part == CARRY)
            num += 50;
        if (part == ATTACK)
            num += 80;
        if (part == RANGED_ATTACK)
            num += 150;
        if (part == HEAL)
            num += 250;
        if (part == CLAIM)
            num += 600;
        if (part == TOUGH)
            num += 10;
    }
    return num;
}
/* 向列表中添加指定数量元素 */
function AddList(arr, time_, element) {
    var list_ = arr;
    for (var i = 0; i < time_; i++) {
        list_.push(element);
    }
    return list_;
}
/* 按照列表中某个属性进行排序 配合sort使用 */
function compare$1(property) {
    return function (a, b) {
        var value1 = a[property];
        var value2 = b[property];
        return value1 - value2;
    };
}
/* 正则获取房间信息 return {coor:['E','S'],num:[44,45]} */
function regularRoom$1(roomName) {
    var roomName = roomName;
    const regRoom = /[A-Z]/g;
    const regNum = /\d{1,2}/g;
    let Acoord = regRoom.exec(roomName)[0];
    let AcoordNum = parseInt(regNum.exec(roomName)[0]);
    let Bcoord = regRoom.exec(roomName)[0];
    let BcoordNum = parseInt(regNum.exec(roomName)[0]);
    return { coor: [Acoord, Bcoord], num: [AcoordNum, BcoordNum] };
}
/* 计算两个房间之间的距离   */
function roomDistance(roomName1, roomName2) {
    var Data1 = regularRoom$1(roomName1);
    var Data2 = regularRoom$1(roomName2);
    var Xdistance = 0;
    var Ydistance = 0;
    if (Data1.coor[0] == Data2.coor[0]) {
        Xdistance = Math.abs(Data1.num[0] - Data2.num[0]);
    }
    else {
        /* 过渡处 */
        Xdistance = 2 * Data1.num[0];
    }
    if (Data1.coor[1] == Data2.coor[1]) {
        Ydistance = Math.abs(Data1.num[1] - Data2.num[1]);
    }
    else {
        /* 过渡处 */
        Ydistance = 2 * Data1.num[1];
    }
    return Xdistance > Ydistance ? Xdistance : Ydistance;
}
/* 获取两个房间之间最近的星门房 */
function closestPotalRoom(roomName1, roomName2) {
    var Data1 = regularRoom$1(roomName1);
    var Data2 = regularRoom$1(roomName2);
    /* 分别计算距离每个房间最近的portal房，如果两个房的最近是相等的就return该房 */
    /* 如果不相等，就对比 A房--A最近Portal房距离 + A最近Portal房--B房距离 和 B房--B最近Portal房距离 + B最近Portal房--A房距离*/
    var NData1R = `${Data1.coor[0]}${Data1.num[0] % 10 > 5 ? Data1.num[0] + (10 - Data1.num[0] % 10) : Data1.num[0] - Data1.num[0] % 10}${Data1.coor[1]}${Data1.num[1] % 10 > 5 ? Data1.num[1] + (10 - Data1.num[1] % 10) : Data1.num[1] - Data1.num[1] % 10}`;
    var NData2R = `${Data2.coor[0]}${Data2.num[0] % 10 > 5 ? Data2.num[0] + (10 - Data2.num[0] % 10) : Data2.num[0] - Data2.num[0] % 10}${Data2.coor[1]}${Data2.num[1] % 10 > 5 ? Data2.num[1] + (10 - Data2.num[1] % 10) : Data2.num[1] - Data2.num[1] % 10}`;
    if (NData1R == NData2R)
        return NData1R;
    else {
        var Adistance = roomDistance(roomName1, NData1R) + roomDistance(roomName2, NData1R);
        var Bdistance = roomDistance(roomName1, NData2R) + roomDistance(roomName2, NData2R);
        if (Adistance > Bdistance)
            return NData2R;
        else
            return NData1R;
    }
}
/* 获取指定方向相反的方向 */
function getOppositeDirection(direction) {
    return ((direction + 3) % 8 + 1);
}
function Colorful$1(content, colorName = null, bolder = false) {
    const colorStyle = colorName ? `color: ${colors$2[colorName] ? colors$2[colorName] : colorName};` : '';
    const bolderStyle = bolder ? 'font-weight: bolder;' : '';
    return `<text style="${[colorStyle, bolderStyle].join(' ')}">${content}</text>`;
}
/* 生成一个不会重复的ID */
function generateID() {
    return Math.random().toString(36).substr(3) + `${Game.time}`;
}
/* 压缩位置函数 */
function zipPosition(position) {
    let x = position.x;
    let y = position.y;
    let room = position.roomName;
    return `${x}/${y}/${room}`;
}
/* 将压缩出来的字符串解压 例如 23/42/W1N1 */
function unzipPosition(str) {
    var info = str.split('/');
    return info.length == 3 ? new RoomPosition(Number(info[0]), Number(info[1]), info[2]) : undefined;
}
function unzipLayout(str) {
    var info = str.split('/');
    return info.length == 4 ? {
        x: Number(info[0]),
        y: Number(info[1]),
        structureType: info[2],
        level: Number(info[3])
    } : undefined;
}
/**
* 给指定文本添加颜色
*
* @param content 要添加颜色的文本
* @param colorName 要添加的颜色常量字符串
* @param bolder 是否加粗
*/
function colorful(content, colorName = null, bolder = false) {
    const colorStyle = colorName ? `color: ${colors$2[colorName]};` : '';
    const bolderStyle = bolder ? 'font-weight: bolder;' : '';
    return `<text style="${[colorStyle, bolderStyle].join(' ')}">${content}</text>`;
}
const colors$2 = {
    slate: '#cbd5e1',
    gray: '#d1d5db',
    zinc: '#d4d4d8',
    neutral: '#d4d4d4',
    stone: '#d6d3d1',
    red: '#fca5a5',
    orange: '#fdba74',
    amber: '#fcd34d',
    yellow: '#fde047',
    lime: '#bef264',
    green: '#86efac',
    emerald: '#6ee7b7',
    teal: '#5eead4',
    cyan: '#67e8f9',
    sky: '#7dd3fc',
    blue: '#93c5fd',
    indigo: '#a5b4fc',
    violet: '#c4b5fd',
    purple: '#d8b4fe',
    fuchsia: '#f0abfc',
    pink: '#f9a8d4',
    rose: '#fda4af',
};

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
var encode$1 = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
var decode$1 = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};

var base64 = {
	encode: encode$1,
	decode: decode$1
};

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */



// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
var encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
var decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};

var base64Vlq = {
	encode: encode,
	decode: decode
};

function createCommonjsModule(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

/* -*- Mode: js; js-indent-level: 2; -*- */

var util = createCommonjsModule(function (module, exports) {
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port;
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 === null) {
    return 1; // aStr2 !== null
  }

  if (aStr2 === null) {
    return -1; // aStr1 !== null
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */
function parseSourceMapInput(str) {
  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}
exports.parseSourceMapInput = parseSourceMapInput;

/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */
function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  sourceURL = sourceURL || '';

  if (sourceRoot) {
    // This follows what Chrome does.
    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
      sourceRoot += '/';
    }
    // The spec says:
    //   Line 4: An optional source root, useful for relocating source
    //   files on a server or removing repeated values in the
    //   “sources” entry.  This value is prepended to the individual
    //   entries in the “source” field.
    sourceURL = sourceRoot + sourceURL;
  }

  // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //    new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   “sourceRoot”, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).
  if (sourceMapURL) {
    var parsed = urlParse(sourceMapURL);
    if (!parsed) {
      throw new Error("sourceMapURL could not be parsed");
    }
    if (parsed.path) {
      // Strip the last path component, but keep the "/".
      var index = parsed.path.lastIndexOf('/');
      if (index >= 0) {
        parsed.path = parsed.path.substring(0, index + 1);
      }
    }
    sourceURL = join(urlGenerate(parsed), sourceURL);
  }

  return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;
});

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */


var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet$1() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet$1.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet$1();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet$1.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet$1.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet$1.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet$1.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
        return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet$1.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet$1.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

var ArraySet_1 = ArraySet$1;

var arraySet = {
	ArraySet: ArraySet_1
};

/* -*- Mode: js; js-indent-level: 2; -*- */

var binarySearch = createCommonjsModule(function (module, exports) {
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  }
  else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  }
  else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};
});

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
  return Math.round(low + (Math.random() * (high - low)));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;

    swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
var quickSort_1 = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};

var quickSort$1 = {
	quickSort: quickSort_1
};

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */



var ArraySet = arraySet.ArraySet;

var quickSort = quickSort$1.quickSort;

function SourceMapConsumer$1(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  return sourceMap.sections != null
    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}

SourceMapConsumer$1.fromSourceMap = function(aSourceMap, aSourceMapURL) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
};

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer$1.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer$1.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer$1.prototype, '_generatedMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer$1.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer$1.prototype, '_originalMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer$1.prototype._charIsMappingSeparator =
  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer$1.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

SourceMapConsumer$1.GENERATED_ORDER = 1;
SourceMapConsumer$1.ORIGINAL_ORDER = 2;

SourceMapConsumer$1.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer$1.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer$1.prototype.eachMapping =
  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer$1.GENERATED_ORDER;

    var mappings;
    switch (order) {
    case SourceMapConsumer$1.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer$1.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */
SourceMapConsumer$1.prototype.allGeneratedPositionsFor =
  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }

    var mappings = [];

    var index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping &&
               mapping.originalLine === line &&
               mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

var SourceMapConsumer_1 = SourceMapConsumer$1;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  if (sourceRoot) {
    sourceRoot = util.normalize(sourceRoot);
  }

  sources = sources
    .map(String)
    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)
    // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
        ? util.relative(sourceRoot, source)
        : source;
    });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);

  this._absoluteSources = this._sources.toArray().map(function (s) {
    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
  });

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this._sourceMapURL = aSourceMapURL;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer$1.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer$1;

/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */
BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
  var relativeSource = aSource;
  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }

  if (this._sources.has(relativeSource)) {
    return this._sources.indexOf(relativeSource);
  }

  // Maybe aSource is an absolute URL as returned by |sources|.  In
  // this case we can't simply undo the transform.
  var i;
  for (i = 0; i < this._absoluteSources.length; ++i) {
    if (this._absoluteSources[i] == aSource) {
      return i;
    }
  }

  return -1;
};

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);

    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                            smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function (s) {
      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

    return smc;
  };

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._absoluteSources.slice();
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      }
      else if (aStr.charAt(index) === ',') {
        index++;
      }
      else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);

        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64Vlq.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        // Generated column.
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];

          // Original line.
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;

          // Original column.
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;

    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                         aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got '
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got '
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
  function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      // The last mapping for each line spans the entire line.
      mapping.lastGeneratedColumn = Infinity;
    }
  };

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
  function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util.compareByGeneratedPositionsDeflated,
      util.getArg(aArgs, 'bias', SourceMapConsumer$1.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function (sc) { return sc == null; });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
      return this.sourcesContent[index];
    }

    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }

    var url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
  function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    source = this._findSourceIndex(source);
    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }

    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util.compareByOriginalPositions,
      util.getArg(aArgs, 'bias', SourceMapConsumer$1.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

var BasicSourceMapConsumer_1 = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer$1(util.getArg(s, 'map'), aSourceMapURL)
    }
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer$1.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer$1;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections,
      function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (needle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);
        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
        this._sources.add(source);
        source = this._sources.indexOf(source);

        var name = null;
        if (mapping.name) {
          name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
        }

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };

var IndexedSourceMapConsumer_1 = IndexedSourceMapConsumer;

var sourceMapConsumer = {
	SourceMapConsumer: SourceMapConsumer_1,
	BasicSourceMapConsumer: BasicSourceMapConsumer_1,
	IndexedSourceMapConsumer: IndexedSourceMapConsumer_1
};

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var SourceMapConsumer = sourceMapConsumer.SourceMapConsumer;

/**
 * 校正异常的堆栈信息
 *
 * 由于 rollup 会打包所有代码到一个文件，所以异常的调用栈定位和源码的位置是不同的
 * 本模块就是用来将异常的调用栈映射至源代码位置
 *
 * @see https://github.com/screepers/screeps-typescript-starter/blob/master/src/utils/ErrorMapper.ts
 */
// 缓存 SourceMap
let consumer = null;
// 第一次报错时创建 sourceMap
const getConsumer = function () {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    if (consumer == null)
        consumer = new SourceMapConsumer(require('main.js.map'));
    return consumer;
};
// 缓存映射关系以提高性能
const cache = {};
/**
 * 使用源映射生成堆栈跟踪，并生成原始标志位
 * 警告 - global 重置之后的首次调用会产生很高的 cpu 消耗 (> 30 CPU)
 * 之后的每次调用会产生较低的 cpu 消耗 (~ 0.1 CPU / 次)
 *
 * @param {Error | string} error 错误或原始追踪栈
 * @returns {string} 映射之后的源代码追踪栈
 */
const sourceMappedStackTrace = function (error) {
    const stack = error instanceof Error ? error.stack : error;
    // 有缓存直接用
    // eslint-disable-next-line no-prototype-builtins
    if (cache.hasOwnProperty(stack))
        return cache[stack];
    // eslint-disable-next-line no-useless-escape
    const re = /^\s+at\s+(.+?\s+)?\(?([0-z._\-\\\/]+):(\d+):(\d+)\)?$/gm;
    let match;
    let outStack = error.toString();
    console.log('ErrorMapper -> ', stack);
    while ((match = re.exec(stack))) {
        // 解析完成
        if (match[2] !== 'main')
            break;
        // 获取追踪定位
        const pos = getConsumer().originalPositionFor({
            column: parseInt(match[4], 10),
            line: parseInt(match[3], 10)
        });
        // 无法定位
        if (!pos.line)
            break;
        // 解析追踪栈
        if (pos.name)
            outStack += `\n    at ${pos.name} (${pos.source}:${pos.line}:${pos.column})`;
        else {
            // 源文件没找到对应文件名，采用原始追踪名
            if (match[1])
                outStack += `\n    at ${match[1]} (${pos.source}:${pos.line}:${pos.column})`;
            // 源文件没找到对应文件名并且原始追踪栈里也没有，直接省略
            else
                outStack += `\n    at ${pos.source}:${pos.line}:${pos.column}`;
        }
    }
    cache[stack] = outStack;
    return outStack;
};
/**
 * 错误追踪包装器
 * 用于把报错信息通过 source-map 解析成源代码的错误位置
 * 和原本 wrapLoop 的区别是，wrapLoop 会返回一个新函数，而这个会直接执行
 *
 * @param next 玩家代码
 */
const errorMapper = function (next, ...args) {
    try {
        // 执行玩家代码
        next(...args);
    }
    catch (e) {
        if (e instanceof Error) {
            // 渲染报错调用栈，沙盒模式用不了这个
            const errorMessage = Game.rooms.sim
                ? `沙盒模式无法使用 source-map - 显示原始追踪栈<br>${_.escape(e.stack)}`
                : `${_.escape(sourceMappedStackTrace(e))}`;
            console.log(colorful(errorMessage, 'red', true));
        }
        // 处理不了，直接抛出
        else
            throw e;
    }
};

const SHOW_BASE_CPU_COST = 'base';
const collectCost = function (name, type, func, ...args) {
    Game.cpu.getUsed();
    const result = func(...args);
    return result;
};

/**
 * bot 名称的后缀，会加到指定的名称后
 * 防止不小心覆盖 Memory 的关键字段
 */
const BOT_NAME_SUFFIX = 'Framework';
const DEFAULT_OPTIONS = {
    name: `superbitch-${BOT_NAME_SUFFIX}`
};
/**
 * 创建应用
 */
const createApp = function (opt = {}) {
    const { name: appName, roomRunner, creepRunner, powerCreepRunner } = Object.assign(Object.assign({}, DEFAULT_OPTIONS), opt);
    /**
     * 通过中间件包装过的回调
     */
    const lifecycleCallbacks = {
        born: [], tickStart: [], tickEnd: []
    };
    /**
     * 用于标识下个 on 所注册回调的索引
     * 会在 on 执行后自增
     */
    let callbackIndex = 0;
    /**
     * 默认的 Memory 缓存存放处
     */
    let _cachedMemory;
    /**
     * 默认的内存缓存器
     * 来源 @see https://screeps.slack.com/files/U33SKDU0P/F5GKDBBAA/Memory_Cache.js?origin_team=T0HJCPP9T&origin_channel=C2G22RFPF
     */
    let _memoryCacher = next => {
        if (_cachedMemory) {
            // @ts-ignore
            delete global.Memory;
            // @ts-ignore
            global.Memory = _cachedMemory;
        }
        else {
            _cachedMemory = Memory;
        }
        next();
        // @ts-ignore
        RawMemory._parsed = global.Memory;
        // RawMemory.set(JSON.stringify(global.Memory))
    };
    /**
     * 设置新的内存缓存器
     * 设置为空则不使用内存缓存
     *
     * @danger 请务必执行 next 方法！不然框架将无法正常使用
     */
    const setMemoryCacher = function (newCatcher) {
        _memoryCacher = newCatcher;
    };
    /**
     * 设置生命周期回调
     * 同一生命周期阶段可以设置多次，在执行时会按照设置的顺序依次执行
     *
     * @param callbacks 要执行的生命周期回调
     * @returns 该组回调的唯一索引，用于取消监听
     */
    const on = function (callbacks) {
        const id = getCallbackIndex();
        // 保存所有回调并分配唯一索引（不同分组间唯一）
        Object.keys(callbacks).forEach(type => {
            lifecycleCallbacks[type].push({ id, callback: callbacks[type] });
        });
        return id;
    };
    /**
     * 关闭生命周期回调监听
     *
     * @param index 要取消监听的分组索引
     */
    const close = function (deleteTarget) {
        // 遍历所有的回调
        Object.values(lifecycleCallbacks).forEach(callbackList => {
            // 查找每个阶段，找到对应的 id 并删除
            const index = callbackList.findIndex(({ id }) => id === deleteTarget);
            callbackList.splice(index, 1);
        });
    };
    /**
     * 获取唯一的索引
     */
    const getCallbackIndex = function () {
        return callbackIndex++;
    };
    /**
     * 运行 bot
     */
    const run = function () {
        // 有内存缓存的话就包裹一下，否则就直接运行
        if (_memoryCacher)
            _memoryCacher(_run);
        else
            _run();
    };
    const runAllRoom = () => Object.values(Game.rooms).map(room => errorMapper(roomRunner, room));
    const runAllCreep = () => Object.values(Game.creeps).map(creep => errorMapper(creepRunner, creep));
    const runAllPowerCreep = () => Object.values(Game.powerCreeps).map(creep => errorMapper(powerCreepRunner, creep));
    /**
     * 实际的框架工作
     */
    const _run = function () {
        var _a;
        // 检查是否是第一次全局重置
        if (!Memory[appName]) {
            execLifecycleCallback('born');
            Memory[appName] = true;
        }
        var cpu_test = false;
        if ((_a = Memory.Systemswitch) === null || _a === void 0 ? void 0 : _a.Showtestrun) {
            cpu_test = true;
        }
        let cpu_list = [];
        if (cpu_test) {
            cpu_list.push(Game.cpu.getUsed());
        }
        collectCost('tickStart', SHOW_BASE_CPU_COST, execLifecycleCallback, 'tickStart');
        if (cpu_test) {
            cpu_list.push(Game.cpu.getUsed());
        }
        if (roomRunner)
            collectCost('room', SHOW_BASE_CPU_COST, runAllRoom);
        if (cpu_test) {
            cpu_list.push(Game.cpu.getUsed());
        }
        if (creepRunner)
            collectCost('creep', SHOW_BASE_CPU_COST, runAllCreep);
        if (cpu_test) {
            cpu_list.push(Game.cpu.getUsed());
        }
        if (powerCreepRunner)
            collectCost('powerCreep', SHOW_BASE_CPU_COST, runAllPowerCreep);
        if (cpu_test) {
            cpu_list.push(Game.cpu.getUsed());
        }
        collectCost('tickEnd', SHOW_BASE_CPU_COST, execLifecycleCallback, 'tickEnd');
        if (cpu_test) {
            cpu_list.push(Game.cpu.getUsed());
            console.log(Game.time, 'tickStart' + (cpu_list[1] - cpu_list[0]).toFixed(3), 'room' + (cpu_list[2] - cpu_list[1]).toFixed(3), 'creep' + (cpu_list[3] - cpu_list[2]).toFixed(3), 'powerCreep' + (cpu_list[4] - cpu_list[3]).toFixed(3), 'tickEnd' + (cpu_list[5] - cpu_list[4]).toFixed(3), '总计' + (cpu_list[5] - cpu_list[0]).toFixed(3), '初始化' + (cpu_list[0]).toFixed(3));
        }
    };
    /**
     * 执行指定生命周期阶段回调
     *
     * @param type 要执行的生命周期回调名称
     */
    const execLifecycleCallback = function (lifecycleType) {
        for (const { callback } of lifecycleCallbacks[lifecycleType]) {
            errorMapper(callback);
        }
    };
    return { setMemoryCacher, on, close, run };
};

/**
 * Memory初始化
 */
const MemoryInit = function () {
    if (!Memory.whitesheet)
        Memory.whitesheet = [];
    if (!Memory.bypassRooms)
        Memory.bypassRooms = [];
    if (!Memory.ignoreMissonName)
        Memory.ignoreMissonName = [];
    if (!Memory.ignoreLab)
        Memory.ignoreLab = false;
    if (!Memory.RoomControlData)
        Memory.RoomControlData = {};
    if (!global.Gtime)
        global.Gtime = {};
    for (let i in Memory.RoomControlData)
        if (!global.Gtime[i]) {
            global.Gtime = {};
            initGTime();
        }
    if (!global.SpecialBodyData)
        global.SpecialBodyData = {};
    for (let i in Memory.RoomControlData)
        if (!global.SpecialBodyData[i])
            global.SpecialBodyData[i] = {};
    // if (!global.intervalData) global.intervalData = {}
    // for (let i in global.intervalData) if (!global.intervalData[i]) global.intervalData[i] = {}
    if (!global.Stru)
        global.Stru = {};
    if (!global.HostileData)
        global.HostileData = {};
    if (!global.HostileTowerData)
        global.HostileTowerData = {};
    if (!global.HostileCreeps)
        global.HostileCreeps = {};
    if (!global.HostileCreepsData)
        global.HostileCreepsData = {};
    if (!global.HostileGroup)
        global.HostileGroup = {};
    if (!Memory.marketAdjust)
        Memory.marketAdjust = {};
    if (!Memory.ResourceDispatchData)
        Memory.ResourceDispatchData = [];
    if (!global.ResourceLimit)
        global.ResourceLimit = {};
    if (!Memory.outMineData)
        Memory.outMineData = {};
    if (!global.warData)
        global.warData = { tower: {}, enemy: {}, flag: {}, structure: {} };
    if (!global.MSB)
        global.MSB = {};
    if (!Memory.StopPixel)
        Memory.StopPixel = false;
    if (!Memory.pixelInfo || !Memory.pixelInfo.buy || !Memory.pixelInfo.sell)
        Memory.pixelInfo = { buy: { num: 0, price: 0, unit: 1, floor: 0, order: "" }, sell: { num: 0, price: 0, unit: 1, ceil: 0, order: "" } };
    if (!global.Repairlist)
        global.Repairlist = {};
    if (!Memory.creepscpu) {
        Memory.creepscpu = {};
    }
    if (!global.getStructure)
        global.getStructure = {};
    if (!global.getStructureData)
        global.getStructureData = {};
    if (!global.controllerData) {
        global.controllerData = {};
    }
    if (!Memory.PowerSupply) {
        Memory.PowerSupply = [];
    }
    if (!Memory.ObserverList) {
        Memory.ObserverList = {};
    }
    if (!global.PowerDemand)
        global.PowerDemand = [];
    if (!global.RoleMissionNum)
        global.RoleMissionNum = {};
    if (!Memory.Systemswitch) {
        Memory.Systemswitch = {};
    }
    if (!Memory.Findrouteroom) {
        Memory.Findrouteroom = {};
    }
    global.Marketorder = {}; /*tick重置已有的订单列表信息*/
    global.RoomDataVisual = null;
    global.Adaption = {};
    global.RoomResource = {};
    global.HostileCreepsData = {};
    global.MarketAveprice = {};
    global.MarketHighestprice = {};
    global.getMission = {};
    // Memory.SystemEconomy = false;
    if (Game.time % 100) {
        for (let rooms in Memory.rooms) {
            if (!Game.rooms[rooms]) {
                delete Memory.rooms[rooms];
            }
        }
    }
};
const memoryInit = {
    tickStart: MemoryInit
};
function shuffle(array) {
    var i = array.length, j = 0, temp;
    while (i--) {
        j = Math.floor(Math.random() * (i + 1));
        temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
    return array;
}
function initGTime() {
    let j = 0;
    //打乱房间执行顺序，避免多个房间在同一tick执行任务
    let order = shuffle([...Array(Object.keys(Memory.RoomControlData).length).keys()]);
    for (let i in Memory.RoomControlData)
        global.Gtime[i] = Game.time - order[j++] - 1;
}

/* 此文件存放有关mount的基础函数 */
/**
 * name: 对象原型拓展
 * eg: asignPrototype(Creep,CreepMove)
 */
const assignPrototype = function (obj1, obj2) {
    Object.getOwnPropertyNames(obj2.prototype).forEach(key => {
        if (key.includes('Getter')) {
            Object.defineProperty(obj1.prototype, key.split('Getter')[0], {
                get: obj2.prototype[key],
                enumerable: false,
                configurable: true
            });
        }
        else
            obj1.prototype[key] = obj2.prototype[key];
    });
};

const t3 = ['XKH2O', 'XKHO2', 'XZH2O', 'XZHO2', 'XGH2O', 'XGHO2', 'XLHO2', 'XLH2O', 'XUH2O', 'XUHO2'];
const t2 = ['KH2O', 'KHO2', 'ZH2O', 'ZHO2', 'GH2O', 'GHO2', 'LHO2', 'LH2O', 'UH2O', 'UHO2'];
const t1 = ['KH', 'KO', 'GH', 'GO', 'LH', 'LO', 'ZO', 'ZH', 'UH', 'UO'];
// lab合成相关常量信息
const LabMap = {
    // 基本元素
    'OH': { raw1: 'H', raw2: 'O' },
    'ZK': { raw1: 'Z', raw2: 'K' },
    'UL': { raw1: 'U', raw2: 'L' },
    'G': { raw1: 'ZK', raw2: 'UL' },
    'GH': { raw1: 'G', raw2: 'H' },
    'GH2O': { raw1: 'GH', raw2: 'OH' },
    'XGH2O': { raw1: 'GH2O', raw2: 'X' },
    'ZO': { raw1: 'Z', raw2: 'O' },
    'ZHO2': { raw1: 'ZO', raw2: 'OH' },
    'XZHO2': { raw1: 'ZHO2', raw2: 'X' },
    'UH': { raw1: 'U', raw2: 'H' },
    'UH2O': { raw1: 'UH', raw2: 'OH' },
    'XUH2O': { raw1: 'UH2O', raw2: 'X' },
    'KH': { raw1: 'K', raw2: 'H' },
    'KH2O': { raw1: 'KH', raw2: 'OH' },
    'XKH2O': { raw1: 'KH2O', raw2: 'X' },
    'KO': { raw1: 'K', raw2: 'O' },
    'KHO2': { raw1: 'KO', raw2: 'OH' },
    'XKHO2': { raw1: 'KHO2', raw2: 'X' },
    'LH': { raw1: 'L', raw2: 'H' },
    'LH2O': { raw1: 'LH', raw2: 'OH' },
    'XLH2O': { raw1: 'LH2O', raw2: 'X' },
    'LO': { raw1: 'L', raw2: 'O' },
    'LHO2': { raw1: 'LO', raw2: 'OH' },
    'XLHO2': { raw1: 'LHO2', raw2: 'X' },
    'GO': { raw1: 'G', raw2: 'O' },
    'GHO2': { raw1: 'GO', raw2: 'OH' },
    'XGHO2': { raw1: 'GHO2', raw2: 'X' },
    'ZH': { raw1: 'Z', raw2: 'H' },
    'ZH2O': { raw1: 'ZH', raw2: 'OH' },
    'XZH2O': { raw1: 'ZH2O', raw2: 'X' },
    'UO': { raw1: 'U', raw2: 'O' },
    'UHO2': { raw1: 'UO', raw2: 'OH' },
    'XUHO2': { raw1: 'UHO2', raw2: 'X' },
};
// lab合成自动规划等级
const LabLevel = {
    'ZK': 1,
    'UL': 1,
    'G': 2,
    'UH': 3,
    'UO': 3,
    'KH': 3,
    'KO': 3,
    'LH': 3,
    'LO': 3,
    'OH': 3,
    'ZO': 3,
    'ZH': 3,
    'GH': 3,
    'GO': 3,
    'LHO2': 4,
    'LH2O': 4,
    'GH2O': 4,
    'GHO2': 4,
    'KH2O': 4,
    'KHO2': 4,
    'ZH2O': 4,
    'ZHO2': 4,
    'UH2O': 4,
    'UHO2': 4,
    'XLHO2': 5,
    'XLH2O': 5,
    'XUH2O': 5,
    'XUHO2': 5,
    'XZH2O': 5,
    'XZHO2': 5,
    'XKH2O': 5,
    'XKHO2': 5,
    'XGH2O': 5,
    'XGHO2': 5,
};
// 化合物合成顺序 映射
const ResourceMapData = [
    /*  */
    { source: 'ZK', dis: 'G', map: [] },
    { source: 'ZK', dis: 'GH2O', map: ['G', 'GH',] },
    { source: 'ZK', dis: 'GHO2', map: ['G', 'GO'] },
    { source: 'ZK', dis: 'XGH2O', map: ['G', 'GH', 'GH2O'] },
    { source: 'ZK', dis: 'XGHO2', map: ['G', 'GO', 'GHO2'] },
    { source: 'G', dis: 'GH2O', map: [] },
    { source: 'G', dis: 'XGH2O', map: ['GH2O', 'GH'] },
    { source: 'G', dis: 'GHO2', map: [] },
    { source: 'G', dis: 'XGHO2', map: ['GHO2', 'GO'] },
    { source: 'GO', dis: 'GHO2', map: [] },
    { source: 'GO', dis: 'XGHO2', map: ['GHO2'] },
    { source: 'GH', dis: 'GH2O', map: [] },
    { source: 'GH', dis: 'XGH2O', map: ['GH2O'] },
    { source: 'GHO2', dis: 'XGHO2', map: [] },
    { source: 'GH2O', dis: 'XGH2O', map: [] },
    { source: 'UL', dis: 'G', map: [] },
    { source: 'UL', dis: 'GH2O', map: ['G', 'GH',] },
    { source: 'UL', dis: 'GHO2', map: ['G', 'GO',] },
    { source: 'UL', dis: 'XGH2O', map: ['G', 'GH', 'GH2O'] },
    { source: 'UL', dis: 'XGHO2', map: ['G', 'GO', 'GHO2'] },
    { source: 'UH', dis: 'UH2O', map: [] },
    { source: 'UH', dis: 'XUH2O', map: ['UH2O',] },
    { source: 'UH2O', dis: 'XUH2O', map: [] },
    { source: 'UO', dis: 'UHO2', map: [] },
    { source: 'UO', dis: 'XUHO2', map: ['UHO2',] },
    { source: 'UHO2', dis: 'XUHO2', map: [] },
    { source: 'KH', dis: 'KH2O', map: [] },
    { source: 'KH', dis: 'XKH2O', map: ['KH2O'] },
    { source: 'KH2O', dis: 'XKH2O', map: [] },
    { source: 'KO', dis: 'KHO2', map: [] },
    { source: 'KO', dis: 'XKHO2', map: ['KHO2',] },
    { source: 'KHO2', dis: 'XKHO2', map: [] },
    { source: 'LH', dis: 'LH2O', map: [] },
    { source: 'LH', dis: 'XLH2O', map: ['LH2O'] },
    { source: 'LH2O', dis: 'XLH2O', map: [] },
    { source: 'LO', dis: 'LHO2', map: [] },
    { source: 'LO', dis: 'XLHO2', map: ['LHO2'] },
    { source: 'LHO2', dis: 'XLHO2', map: [] },
    { source: 'ZH', dis: 'ZH2O', map: [] },
    { source: 'ZH', dis: 'XZH2O', map: ['ZH2O'] },
    { source: 'ZH2O', dis: 'XZH2O', map: [] },
    { source: 'ZO', dis: 'ZHO2', map: [] },
    { source: 'ZO', dis: 'XZHO2', map: ['ZHO2'] },
    { source: 'ZHO2', dis: 'XZHO2', map: [] },
    { source: 'OH', dis: 'GH2O', map: [] },
    { source: 'OH', dis: 'GHO2', map: [] },
    { source: 'OH', dis: 'XGH2O', map: ['GH2O'] },
    { source: 'OH', dis: 'XGHO2', map: ['GHO2'] },
    { source: 'OH', dis: 'UH2O', map: [] },
    { source: 'OH', dis: 'XUH2O', map: ['UH2O'] },
    { source: 'OH', dis: 'UHO2', map: [] },
    { source: 'OH', dis: 'XUHO2', map: ['UHO2'] },
    { source: 'OH', dis: 'LH2O', map: [] },
    { source: 'OH', dis: 'XLH2O', map: ['LH2O'] },
    { source: 'OH', dis: 'LHO2', map: [] },
    { source: 'OH', dis: 'XLHO2', map: ['LHO2'] },
    { source: 'OH', dis: 'KH2O', map: [] },
    { source: 'OH', dis: 'XKH2O', map: ['KH2O'] },
    { source: 'OH', dis: 'KHO2', map: [] },
    { source: 'OH', dis: 'XKHO2', map: ['KHO2'] },
    { source: 'OH', dis: 'ZH2O', map: [] },
    { source: 'OH', dis: 'XZH2O', map: ['ZH2O'] },
    { source: 'OH', dis: 'ZHO2', map: [] },
    { source: 'OH', dis: 'XZHO2', map: ['ZHO2'] },
];
// 化合物合成规划数据
const resourceComDispatch = {
    'G': ['ZK', 'UL', 'G'],
    'UH': ['UH'],
    'UH2O': ['UH', 'OH', 'UH2O'],
    'XUH2O': ['UH', 'OH', 'UH2O', 'XUH2O'],
    'UO': ['UO'],
    'UHO2': ['UO', 'OH', 'UHO2'],
    'XUHO2': ['UO', 'OH', 'UHO2', 'XUHO2'],
    'GH': ['ZK', 'UL', 'G', 'GH'],
    'GH2O': ['ZK', 'UL', 'G', 'GH', 'OH', 'GH2O'],
    'XGH2O': ['ZK', 'UL', 'G', 'GH', 'OH', 'GH2O', 'XGH2O'],
    'GO': ['ZK', 'UL', 'G', , 'GO'],
    'GHO2': ['ZK', 'UL', 'G', 'GO', 'OH', 'GHO2'],
    'XGHO2': ['ZK', 'UL', 'G', 'GO', 'OH', 'GHO2', 'XGHO2'],
    'LH': ['LH'],
    'LH2O': ['LH', 'LH2O'],
    'XLH2O': ['LH', 'OH', 'LH2O', 'XLH2O'],
    'LO': ['LO'],
    'LHO2': ['LO', 'OH', 'LHO2'],
    'XLHO2': ['LO', 'OH', 'LHO2', 'XLHO2'],
    'KH': ['KH'],
    'KH2O': ['KH', 'OH', 'KH2O'],
    'XKH2O': ['KH', 'OH', 'KH2O', 'XKH2O'],
    'KO': ['KO'],
    'KHO2': ['KO', 'OH', 'KHO2'],
    'XKHO2': ['KO', 'OH', 'KHO2', 'XKHO2'],
    'ZH': ['ZH'],
    'ZH2O': ['ZH', 'OH', 'ZH2O'],
    'XZH2O': ['ZH', 'OH', 'ZH2O', 'XZH2O'],
    'ZO': ['ZO'],
    'ZHO2': ['ZO', 'OH', 'ZHO2'],
    'XZHO2': ['ZO', 'OH', 'ZHO2', 'XZHO2'],
    'UL': ['UL'],
    'ZK': ['ZK'],
    'OH': ['OH']
};
const CompoundColor = {
    'L': '#6cf0a9',
    'LH': '#6cf0a9',
    'LHO2': '#6cf0a9',
    'XLHO2': '#6cf0a9',
    'LH2O': '#6cf0a9',
    'LO': '#6cf0a9',
    'XLH2O': '#6cf0a9',
    'U': '#4ca7e5',
    'UH': '#4ca7e5',
    'UO': '#4ca7e5',
    'UH2O': '#4ca7e5',
    'UHO2': '#4ca7e5',
    'XUH2O': '#4ca7e5',
    'XUHO2': '#4ca7e5',
    'Z': '#f7d492',
    'ZO': '#f7d492',
    'ZH': '#f7d492',
    'ZH2O': '#f7d492',
    'ZHO2': '#f7d492',
    'XZH2O': '#f7d492',
    'XZHO2': '#f7d492',
    'K': '#da6Bf5',
    'KH': '#da6Bf5',
    'KO': '#da6Bf5',
    'KH2O': '#da6Bf5',
    'KHO2': '#da6Bf5',
    'XKH2O': '#da6Bf5',
    'XKHO2': '#da6Bf5',
    'G': '#d9d6c3',
    'GH': '#d9d6c3',
    'GO': '#d9d6c3',
    'GH2O': '#d9d6c3',
    'GHO2': '#d9d6c3',
    'XGH2O': '#d9d6c3',
    'XGHO2': '#d9d6c3',
    'X': '#aa2116',
    'ZK': '#74787c',
    'UL': '#7c8577'
};
const zipMap = {
    'energy': RESOURCE_BATTERY,
    'L': 'lemergium_bar',
    'Z': 'zynthium_bar',
    'K': 'keanium_bar',
    'U': 'utrium_bar',
    'G': 'ghodium_melt',
    'O': 'oxidant',
    'H': 'reductant',
    'X': 'purifier',
};
const unzipMap = {
    'battery': RESOURCE_ENERGY,
    'lemergium_bar': RESOURCE_LEMERGIUM,
    'zynthium_bar': RESOURCE_ZYNTHIUM,
    'keanium_bar': RESOURCE_KEANIUM,
    'utrium_bar': RESOURCE_UTRIUM,
    'ghodium_melt': RESOURCE_GHODIUM,
    'oxidant': RESOURCE_OXYGEN,
    'reductant': RESOURCE_HYDROGEN,
    'purifier': RESOURCE_CATALYST,
};
/*market-Buy-Auto类型处理*/
const AutomarketBuydata = {
    'metal': { max: 200 },
    'alloy': { max: 500 },
    'ops': { max: 30 },
    'O': { max: 20 },
    'H': { max: 20 },
    'Z': { max: 20 },
    'L': { max: 20 },
    'U': { max: 20 },
    'K': { max: 20 },
    'X': { max: 20 },
    'utrium_bar': { max: 20 },
    'lemergium_bar': { max: 20 },
    'zynthium_bar': { max: 20 },
    'keanium_bar': { max: 20 },
    'ghodium_melt': { max: 20 },
    'oxidant': { max: 20 },
    'reductant': { max: 20 },
    'purifier': { max: 20 },
    'power': { max: 200 }
};

/* 杂物堆 */
// 计算平均价格
function avePrice(res, day) {
    if (!Game.cpu.generatePixel) {
        let history = Game.market.getHistory(res);
        if (!history)
            return 0;
        return history[history.length - 1].avgPrice;
    }
    if (day > 14)
        return 0; // 0
    let history = null;
    if (global.MarketAveprice[res]) {
        history = global.MarketAveprice[res];
    }
    else {
        history = Game.market.getHistory(res);
        global.MarketAveprice[res] = history;
    }
    let totalPrice = 0;
    let totalAmount = 0;
    for (var i = 14 - day; i <= 14; i++) { //计入最后一天价格
        if (history[i]) {
            totalPrice += history[i].avgPrice * history[i].volume;
            totalAmount += history[i].volume;
        }
    }
    let avePrice = totalPrice / totalAmount; // 平均能量价格
    return avePrice;
}
// 判断是否已经有相应order了s
function gethaveOrder(roomName, res, mtype, nowPrice, range) {
    for (let i in Game.market.orders) {
        let order = Game.market.getOrderById(i);
        if (order.roomName == roomName && order.resourceType == res && order.type == mtype && order.price >= (Number(nowPrice) + Number(range)))
            return order;
    }
    return false;
}
// 判断是否已经有相应order了s
function haveOrder(roomName, res, mtype, nowPrice, range) {
    if (!nowPrice) //  不考虑价格
     {
        for (let i in Game.market.orders) {
            let order = Game.market.getOrderById(i);
            if (order.roomName == roomName && order.resourceType == res && order.type == mtype)
                return true;
        }
        return false;
    }
    else // 考虑价格区间
     {
        for (let i in Game.market.orders) {
            let order = Game.market.getOrderById(i);
            if (order.roomName == roomName && order.resourceType == res && order.type == mtype && order.price >= (nowPrice + range))
                return true;
        }
        return false;
    }
}
// 计算一定范围内的最高价格
function highestPrice(res, mtype, mprice) {
    let allOrder = Game.market.getAllOrders({ type: mtype, resourceType: res });
    let highestPrice = 0;
    for (var i of allOrder) {
        if (i.price > highestPrice) {
            if (mprice) {
                if (i.price <= mprice)
                    highestPrice = i.price;
            }
            else {
                highestPrice = i.price;
            }
        }
    }
    if (mprice && highestPrice == 0)
        highestPrice = mprice;
    return highestPrice;
}
// 计算一定范围内的最低价格
function lowestPrice(res, mtype, mprice) {
    let allOrder = Game.market.getAllOrders({ type: mtype, resourceType: res });
    let lowestPrice = Number.MAX_SAFE_INTEGER;
    for (var i of allOrder) {
        if (i.price < lowestPrice) {
            if (mprice) {
                if (i.price >= mprice)
                    lowestPrice = i.price;
            }
            else {
                lowestPrice = i.price;
            }
        }
    }
    if (mprice && lowestPrice == Number.MAX_SAFE_INTEGER)
        lowestPrice = mprice;
    return lowestPrice;
}
/*筛选最高价格(剔除自己的房间以及系统的过道房间)-主要用于order挂单购买的情况下*/
function notmehighestPrice(res, mtype, filter_aisle) {
    if (global.MarketHighestprice[res])
        return global.MarketHighestprice[res];
    let allOrder = Game.market.getAllOrders({ type: mtype, resourceType: res });
    let highestPrice = 0;
    for (var i of allOrder) {
        if (Memory.RoomControlData[i.roomName])
            continue;
        var patt = /^[WE]([0-9]+)[NS]([0-9]+)$/;
        var roomparsed = patt.exec(i.roomName);
        // let roomparsed = Number((/^[WE]([0-9]+)[NS]([0-9]+)$/.exec(i.roomName)));
        if ((roomparsed[0] % 10 || roomparsed[1] % 10) || !filter_aisle) {
            if (i.amount > 200 && i.price > highestPrice) {
                highestPrice = i.price;
            }
        }
    }
    // if (mprice && highestPrice == 0) highestPrice = mprice
    global.MarketHighestprice[res] = highestPrice;
    return highestPrice;
}
// 识别lab 合成 or 底物  [轮子]
function RecognizeLab(roomname) {
    var room = Game.rooms[roomname];
    if (!room)
        return null;
    var labs = room.find(FIND_STRUCTURES, { filter: { structureType: STRUCTURE_LAB } });
    if (labs.length < 3)
        return null;
    var centerLabs = [, , []];
    var obj = { centerLabs: [], otherLabs: [] };
    for (let i = 0; i < labs.length; i++) {
        let labA = labs[i];
        for (let j = i + 1; j < labs.length; j++) {
            let labB = labs[j];
            let otherLabs = [];
            if (labA.pos.inRangeTo(labB, 5))
                labs.forEach(labC => {
                    if (labC != labA && labC != labB && labA.pos.inRangeTo(labC, 2) && labB.pos.inRangeTo(labC, 2)) {
                        otherLabs.push(labC);
                    }
                });
            if (otherLabs.length > centerLabs[2].length) {
                centerLabs = [labA, labB, otherLabs];
                if (centerLabs[0]) {
                    obj.centerLabs = [centerLabs[0].id, centerLabs[1].id];
                    obj.otherLabs = centerLabs[2].map(e => e.id);
                }
                else {
                    obj.centerLabs = []; //中央lab
                    obj.otherLabs = []; //剩下lab
                }
            }
        }
    }
    if (obj.centerLabs.length < 2 || obj.otherLabs.length <= 0)
        return null;
    return { raw1: obj.centerLabs[0], raw2: obj.centerLabs[1], com: obj.otherLabs };
}
// 判断是否存在该房间相关资源的调用信息 true 存在 false 不存在
function checkDispatch(roomName, resource) {
    for (let i of Memory.ResourceDispatchData) {
        if (i.sourceRoom == roomName && i.rType == resource)
            return true;
    }
    return false;
}
// 该房间资资源调度数量
function DispatchNum(roomName) {
    let num = 0;
    for (let i of Memory.ResourceDispatchData) {
        if (i.sourceRoom == roomName)
            num++;
    }
    return num;
}
// 判断其他房间是否存在往该房间的资源调度
function checkSend(roomName, resource) {
    for (let i in Memory.RoomControlData) {
        if (!Game.rooms[i] || !Game.rooms[i].memory.Misson || !Game.rooms[i].memory.Misson['Structure'])
            continue;
        for (var t of Game.rooms[i].memory.Misson['Structure']) {
            if (t.name == '资源传送' && t.Data.rType == resource && t.Data.disRoom == roomName)
                return true;
        }
    }
    return false;
}
/* 判断目标资源的上级资源是否已经达到要求 */
function resourceMap(rType, disType) {
    if (isInArray(['XGH2O', 'XGHO2', 'XLH2O', 'XLHO2', 'XUH2O', 'XUHO2', 'XKH2O', 'XKHO2', 'XZH2O', 'XZHO2'], rType)) {
        console.log("是", rType, ' 返回空列表');
        return [];
    }
    for (var i of ResourceMapData) {
        if (i.source == rType && i.dis == disType) {
            return i.map;
        }
    }
    console.log("resourceMap返回了空列表");
    return [];
}
/* 判断爬虫是否是值得防御的目标 */
function deserveDefend(creep) {
    for (var b of creep.body) {
        if (b.boost && isInArray(['XGHO2', 'XKHO2', 'XUHO2', 'XZH2O'], b.boost)) {
            return true;
        }
    }
    return false;
}
/* 判断爬虫是否有某类型部件 */
function parts(creep, bo) {
    for (var b of creep.body) {
        if (b.type == bo)
            return true;
    }
    return false;
}
/* 爬虫攻击部件数据 */
function hurts(creep) {
    var result = { 'attack': 0, 'ranged_attack': 0 };
    for (var i of creep.body) {
        if (i.type == 'attack') {
            if (!i.boost)
                result['attack'] += 30;
            else if (i.boost == 'UH')
                result['attack'] += 60;
            else if (i.boost == 'UH2O')
                result['attack'] += 90;
            else if (i.boost == 'XUH2O')
                result['attack'] += 120;
        }
        else if (i.type == 'ranged_attack') {
            if (!i.boost)
                result['ranged_attack'] += 10;
            else if (i.boost == 'KO')
                result['ranged_attack'] += 20;
            else if (i.boost == 'KHO2')
                result['ranged_attack'] += 30;
            else if (i.boost == 'XKHO2')
                result['ranged_attack'] += 40;
        }
    }
    return result;
}
/* 爬虫攻击数据 */
function bodypartData(creep) {
    var result = { 'attack': 0, 'ranged_attack': 0, 'heal': 0, 'tough': 0 };
    // 其中tough是抵抗的伤害值
    for (var i of creep.body) {
        if (i.type == 'heal') {
            if (!i.boost)
                result['heal'] += 12;
            else if (i.boost == 'LO')
                result['heal'] += 24;
            else if (i.boost == 'LHO2')
                result['heal'] += 36;
            else if (i.boost == 'XLHO2')
                result['heal'] += 48;
        }
        if (i.type == 'attack') {
            if (!i.boost)
                result['attack'] += 30;
            else if (i.boost == 'UH')
                result['attack'] += 60;
            else if (i.boost == 'UH2O')
                result['attack'] += 90;
            else if (i.boost == 'XUH2O')
                result['attack'] += 120;
        }
        else if (i.type == 'ranged_attack') {
            if (!i.boost)
                result['ranged_attack'] += 10;
            else if (i.boost == 'KO')
                result['ranged_attack'] += 20;
            else if (i.boost == 'KHO2')
                result['ranged_attack'] += 30;
            else if (i.boost == 'XKHO2')
                result['ranged_attack'] += 40;
        }
        else if (i.type == 'tough') {
            if (!i.boost)
                result['tough'] += 100;
            else if (i.boost == 'GO')
                result['tough'] += 200;
            else if (i.boost == 'GHO2')
                result['tough'] += 300;
            else if (i.boost == 'XGHO2')
                result['tough'] += 400;
        }
    }
    return result;
}
/* 寻找后一级的爬 */
function findNextData(creep) {
    if (!creep.memory.squad)
        return null;
    for (var i in creep.memory.squad) {
        if (creep.memory.squad[i].index - creep.memory.squad[creep.name].index == 1) {
            return i;
        }
    }
    return null;
}
/**
 * 判断房间thisRoom是否可以直接通过出口到达房间disRoom
 * @param thisRoom 当前房间
 * @param disRoom  目标房价
 * @returns boolean
 * 方向常量 ↑:1 →:3 ↓:5 ←:7
 */
function identifyNext(thisRoom, disRoom) {
    var thisRoomData = regularRoom(thisRoom);
    var disRoomData = regularRoom(disRoom);
    if (thisRoomData.coor[0] == disRoomData.coor[0] && thisRoomData.coor[1] == disRoomData.coor[1]) {
        var Xdistanceabs = Math.abs(thisRoomData.num[0] - disRoomData.num[0]);
        var Ydistanceabs = Math.abs(thisRoomData.num[1] - disRoomData.num[1]);
        if ((Xdistanceabs == 0 && Ydistanceabs == 1) || (Xdistanceabs == 1 && Ydistanceabs == 0) && Game.rooms[thisRoom].findExitTo(disRoom) != -2 && Game.rooms[thisRoom].findExitTo(disRoom) != -10) {
            /* 已经接近房间了 */
            let result = Game.rooms[thisRoom].findExitTo(disRoom);
            if (isInArray([-2, -10], result))
                return false;
            else {
                let direction = null;
                /* 判断一个房间相对另一个房间的方向是否和返回的出口方向一致 */
                if (Xdistanceabs == 1) // x方向相邻
                 {
                    let count = thisRoomData.num[0] - disRoomData.num[0];
                    // W区
                    if (thisRoomData.coor[0] == 'W') {
                        switch (count) {
                            case 1: {
                                direction = 3;
                                break;
                            }
                            case -1: {
                                direction = 7;
                                break;
                            }
                        }
                    }
                    // E区
                    else if (thisRoomData.coor[0] == 'E') {
                        switch (count) {
                            case 1: {
                                direction = 7;
                                break;
                            }
                            case -1: {
                                direction = 3;
                                break;
                            }
                        }
                    }
                }
                else if (Ydistanceabs == 1) // y方向相邻
                 {
                    let count = thisRoomData.num[1] - disRoomData.num[1];
                    // N区
                    if (thisRoomData.coor[1] == 'N') {
                        switch (count) {
                            case 1: {
                                direction = 5;
                                break;
                            }
                            case -1: {
                                direction = 1;
                                break;
                            }
                        }
                    }
                    // S区
                    else if (thisRoomData.coor[1] == 'S') {
                        switch (count) {
                            case 1: {
                                direction = 1;
                                break;
                            }
                            case -1: {
                                direction = 5;
                                break;
                            }
                        }
                    }
                }
                if (!direction)
                    return false;
                else if (direction == result)
                    return true;
            }
        }
    }
    return false;
}
/**
 * 格式化房间名称信息
 * @param roomName 房间名
 * @returns 一个对象 例: W1N2 -----> {coor:["W","N"], num:[1,2]}
 */
function regularRoom(roomName) {
    var roomName = roomName;
    const regRoom = /[A-Z]/g;
    const regNum = /\d{1,2}/g;
    let Acoord = regRoom.exec(roomName)[0];
    let AcoordNum = parseInt(regNum.exec(roomName)[0]);
    let Bcoord = regRoom.exec(roomName)[0];
    let BcoordNum = parseInt(regNum.exec(roomName)[0]);
    return { coor: [Acoord, Bcoord], num: [AcoordNum, BcoordNum] };
}
/* 获取相邻房间相对于本房间的方向 */
function NextRoomDirection(thisRoom, disRoom) {
    var thisRoomData = regularRoom(thisRoom);
    var disRoomData = regularRoom(disRoom);
    if (thisRoomData.coor[0] == disRoomData.coor[0] && thisRoomData.coor[1] == disRoomData.coor[1]) {
        var Xdistanceabs = Math.abs(thisRoomData.num[0] - disRoomData.num[0]);
        var Ydistanceabs = Math.abs(thisRoomData.num[1] - disRoomData.num[1]);
        if ((Xdistanceabs == 0 && Ydistanceabs == 1) || (Xdistanceabs == 1 && Ydistanceabs == 0) && Game.rooms[thisRoom].findExitTo(disRoom) != -2 && Game.rooms[thisRoom].findExitTo(disRoom) != -10) {
            /* 已经接近房间了 */
            let direction = null;
            /* 判断一个房间相对另一个房间的方向是否和返回的出口方向一致 */
            if (Xdistanceabs == 1) // x方向相邻
             {
                let count = thisRoomData.num[0] - disRoomData.num[0];
                // W区
                if (thisRoomData.coor[0] == 'W') {
                    switch (count) {
                        case 1: {
                            direction = "→";
                            break;
                        }
                        case -1: {
                            direction = "←";
                            break;
                        }
                    }
                }
                // E区
                else if (thisRoomData.coor[0] == 'E') {
                    switch (count) {
                        case 1: {
                            direction = "←";
                            break;
                        }
                        case -1: {
                            direction = "→";
                            break;
                        }
                    }
                }
            }
            else if (Ydistanceabs == 1) // y方向相邻
             {
                let count = thisRoomData.num[1] - disRoomData.num[1];
                // N区
                if (thisRoomData.coor[1] == 'N') {
                    switch (count) {
                        case 1: {
                            direction = "↓";
                            break;
                        }
                        case -1: {
                            direction = "↑";
                            break;
                        }
                    }
                }
                // S区
                else if (thisRoomData.coor[1] == 'S') {
                    switch (count) {
                        case 1: {
                            direction = "↑";
                            break;
                        }
                        case -1: {
                            direction = "↓";
                            break;
                        }
                    }
                }
            }
            return direction;
        }
    }
    return null;
}
/**
 * 判断是否处于房间入口指定格数内
 * @param creep
 * @returns
 */
function RoomInRange(thisPos, disRoom, range) {
    let thisroom = thisPos.roomName;
    let direction = NextRoomDirection(thisroom, disRoom);
    if (!direction)
        return false;
    if (!range || range <= 0 || range >= 49)
        return false;
    switch (direction) {
        case "↑": {
            return thisPos.y <= range ? true : false;
        }
        case "↓": {
            return thisPos.y >= (49 - range) ? true : false;
        }
        case "←": {
            return thisPos.x <= range ? true : false;
        }
        case "→": {
            return thisPos.x >= (49 - range) ? true : false;
        }
        default: {
            return false;
        }
    }
}
/* 判断是否可以组队了  需要一个方块的位置都没有墙壁，而且坐标需要 2 -> 47 */
function identifyGarrison(creep) {
    if (creep.pos.x > 47 || creep.pos.x < 2 || creep.pos.y > 47 || creep.pos.y < 2)
        return false;
    for (var i = creep.pos.x; i < creep.pos.x + 2; i++)
        for (var j = creep.pos.y; j < creep.pos.y + 2; j++) {
            var thisPos = new RoomPosition(i, j, creep.room.name);
            if (thisPos.lookFor(LOOK_TERRAIN)[0] == 'wall') {
                return false;
            }
            if (thisPos.GetStructureList(['spawn', 'constructedWall', 'rampart', 'observer', 'link', 'nuker', 'storage', 'tower', 'terminal', 'powerSpawn', 'extension']).length > 0)
                return false;
        }
    return true;
}
/* 寻找前一级的爬 四人小队用 */
function findFollowData(creep) {
    if (!creep.memory.squad)
        return null;
    for (var i in creep.memory.squad) {
        if (creep.memory.squad[creep.name].index - creep.memory.squad[i].index == 1) {
            return i;
        }
    }
    return null;
}
/* 没有房间名的字符串解压 例如 14/23 */
function unzipXandY(str) {
    var info = str.split('/');
    return info.length == 2 ? [Number(info[0]), Number(info[1])] : undefined;
}
// /* 平均cpu统计相关 */
// export function statCPU(): void {
//     var mainEndCpu = Game.cpu.getUsed()
//     if (!global.CpuData) global.CpuData = []
//     global.UsedCpu = mainEndCpu
//     let length_i = 300;
//     if (global.CpuData.length >= length_i) {
//         global.CpuData = global.CpuData.slice(1);
//     }
//     global.CpuData.push(global.UsedCpu)
//     /* 计算平均cpu */
//     var AllCpu = 0
//     for (var cData of global.CpuData) {
//         AllCpu += cData
//     }
//     global.AveCpu = AllCpu / global.CpuData.length
// }

/**
 * 重构跨shard模块
 * {
 *     creep:           // 存储跨shard爬虫memory
 *      {
 *          ...
 *          creep1:          // 爬虫名称
 *          {
 *              MemoryData:{},
 *              state: 0/1  // 状态码：0代表还未传输、1代表已经传输
 *              delay:200 超时倒计时   // 超过200tick将自动删除,所有爬虫数据均是如此
 *          },
 *          ...
 *      },
 *      misson:        // 存储跨shard任务memory
 *      {
 *          ...
 *          Cskfvde23nf34:   // 任务ID
 *          {
 *              MemoryData:{},
 *              state: 0/1  // 状态码：0代表还未传输、1代表已经传输
 *              delay:10000  // 超过10000tick将自动删除
 *          }
 *          ...
 *      },
 *      command:
 *      [
 *          ...
 *          {
 *              name: 指令名称
 *              data: 指令参数
 *          },
 *          ...
 *      ]
 *      shardName: shard3    // 所在shard
 *      hall:               // 沟通大厅
 *      {
 *          shard2:
 *          {
 *              ...
 *          },
 *          ...
 *          shard1:
 *          {
 *              state: 0 //状态码: 0代表无请求、1代表请求发送、2代表发送成功、3代表接受成功
 *              data: {} // 爬虫/任务/指令的数据
 *              type: 1  // 类型：1代表爬虫数据、2代表任务数据、3代表指令
 *              delay: 200     // 超时倒计时
 *              memorydelay: 99999  //记忆超时 (可选)
 *          }
 *      }
 * }
 *
 */
/**
 * 跨shard初始化
 */
function InitShard() {
    let Data = JSON.parse(InterShardMemory.getLocal()) || {};
    global.intershardData = Data;
    if (Object.keys(Data).length != 5 || !Data['creep'] || !Data['mission'] || !Data['command'] || !Data['hall']) {
        let initdata = { 'creep': {}, 'mission': {}, 'command': [], 'shardName': Game.shard.name, 'hall': {} };
        let thisShardList = _.difference(['shard0', 'shard1', 'shard2', 'shard3'], [Game.shard.name]);
        for (let littleshard of thisShardList)
            initdata['hall'][littleshard] = {};
        console.log('已经初始化', Game.shard.name, '的InterShardMemory!');
        global.intershardData = initdata;
        return;
    }
}
/**
 * 跨shard记忆缓存清理
 */
function CleanShard() {
    var Data = global.intershardData;
    /* 爬虫记忆缓存清理 */
    for (var cData in Data['creep']) {
        Data['creep'][cData].delay -= 1;
        if (Data['creep'][cData].delay <= 0) // 超时则删除
         {
            delete Data['creep'][cData];
            continue;
        }
        if (Data['creep'][cData].state == 1) // 已传输则删除
         {
            delete Data['creep'][cData];
            continue;
        }
    }
    /* 任务缓存清理 */
    for (var mData in Data['mission']) {
        if (Data['mission'][mData].delay < 99999)
            Data['mission'][mData].delay -= 1;
        if (Data['mission'][mData].delay <= 0) // 超时则删除
         {
            delete Data['mission'][mData];
            continue;
        }
        if (Data['mission'][mData].state == 1) // 已传输则删除
         {
            delete Data['mission'][mData];
            continue;
        }
    }
    /* 指令缓存清理 */
    if (Data['command'])
        for (var com of Data['command']) {
            if (com.done) // done代表指令完成
             {
                let index = Data['command'].indexOf(com);
                Data['command'].splice(index, 1);
            }
        }
}
/**
 * 发起跨shard请求
 */
function RequestShard(req) {
    if (Game.shard.name == req.relateShard)
        return true; // 跨同shard的星门
    var Data = global.intershardData;
    if (Data['hall'][req.relateShard] && Data['hall'][req.relateShard].data) {
        // console.log(JSON.stringify(Data['hall'][req.relateShard]), Game.time)
        // || isInArray(['E1E4534B【W11N13】'], Data['hall'][req.relateShard].state)
        if (req.data.id == Data['hall'][req.relateShard].data.id) {
            // console.log(req.data.id, true)
            return true;
        }
    }
    if (Data['hall'][req.relateShard] && isInArray([1, 2, 3], Data['hall'][req.relateShard].state) && Game.time < Data['hall'][req.relateShard].time + 50)
        return false; // 房间正在处理其他事务
    Data['hall'][req.relateShard] = {
        state: 1,
        relateShard: req.relateShard,
        sourceShard: req.sourceShard,
        type: req.type,
        data: req.data,
        delay: 100,
        time: Game.time
    };
    // console.log("request data",JSON.stringify(Data['hall'][req.relateShard]))
    return true;
}
/**
 *  获取其他shard的InterShardMemory中对应本shard的信息
 * @param shardName shard名
 * @returns 其他shard的数据
 */
function UpdateShardHallData(shardName) {
    if (shardName == Game.shard.name)
        return null;
    var Data = JSON.parse(InterShardMemory.getRemote(shardName)) || {};
    if (Object.keys(Data).length != 5 || !Data['creep'] || !Data['mission'] || !Data['command'] || !Data['hall'])
        return null; // 说明该shard不存在InterShardMemory
    if (!Data['hall'][Game.shard.name])
        return null;
    return Data['hall'][Game.shard.name];
}
/**
 * 响应其他shard请求，并将请求拷贝到自己记忆里
 */
function ResponseShard() {
    let Data = global.intershardData;
    for (var o_shard of _.difference(['shard0', 'shard1', 'shard2', 'shard3'], [Game.shard.name])) {
        var comData = UpdateShardHallData(o_shard);
        // if (Game.shard.name == 'shard2' && o_shard == 'shard3')
        // {
        //     console.log(JSON.stringify(comData))
        // }
        if (comData === null)
            continue;
        if (comData.state != 1)
            continue;
        Data['hall'][o_shard] = {
            state: 2,
            relateShard: comData.relateShard,
            sourceShard: comData.sourceShard,
            type: comData.type,
            data: comData.data,
            delay: 100,
        };
        if (Game.shard.name == 'shard2' && o_shard == 'shard3') ;
        if (comData.type == 1) {
            Data['creep'][comData.data['id']] = { MemoryData: comData.data['MemoryData'], delay: (comData.memorydelay ? comData.memorydelay : 100), state: 0 };
        }
        else if (comData.type == 2) {
            Data['mission'][comData.data['id']] = { MemoryData: comData.data['MemoryData'], delay: (comData.memorydelay ? comData.memorydelay : 5000), state: 0 };
        }
        else if (comData.type == 3) {
            if (!comData.data.name)
                continue;
            // 如果没有相同指令，则添加
            let name = comData.data.name;
            for (let lcom of Data['command'])
                if (lcom.name == name)
                    continue;
            /**
             *  命令类型comData.data的数据格式
             *  comData
             * {
             *  ...
             *  data:{
             *      name:xxxx,
             *      data:{...}
             *  }
             * }
             */
            Data['command'].push({ name: comData.data.name, done: false, data: comData.data.data });
        }
    }
    // if (Game.shard.name == 'shard2')
    // {
    //     console.log( "Data",JSON.stringify(Data))
    // }
    // if (Game.shard.name == 'shard2')
    // {
    //     console.log( "InterMemory",InterShardMemory.getLocal())
    // }
}
/**
 *  确认已经收到信息
 */
function ConfirmShard() {
    var Data = global.intershardData;
    for (var o_shard of _.difference(['shard0', 'shard1', 'shard2', 'shard3'], [Game.shard.name])) {
        if (!Data['hall'][o_shard] || _.isEmpty(Data['hall'][o_shard]))
            continue;
        var comData = UpdateShardHallData(o_shard);
        if (comData === null)
            continue;
        if (comData.state != 2)
            continue;
        else if (comData.state == 2) {
            Data['hall'][o_shard].state = 3;
            delete Data['hall'][o_shard].data;
        }
    }
}
/**
 * 删除shard无关信息
 */
function DeleteShard() {
    var Data = global.intershardData;
    for (var o_shard of _.difference(['shard0', 'shard1', 'shard2', 'shard3'], [Game.shard.name])) {
        if (!Data['hall'][o_shard] || _.isEmpty(Data['hall'][o_shard]) || Data['hall'][o_shard].state == 1)
            continue;
        var RemoteData = JSON.parse(InterShardMemory.getRemote(o_shard)) || {};
        if (RemoteData['hall'][Game.shard.name].state == 3) {
            if (Game.shard.name == 'shard3')
                console.log(1);
            Data['hall'][o_shard] = {};
        }
        if (_.isEmpty(RemoteData['hall'][Game.shard.name])) {
            if (Game.shard.name == 'shard3')
                console.log(1);
            Data['hall'][o_shard] = {};
        }
    }
}
/**
 * 跨shard管理器
 */
const InterShardManager = function () {
    if (!Game.cpu.generatePixel)
        return;
    InitShard();
    CleanShard();
    ResponseShard();
    // console.log(JSON.stringify(global.intershardData))
    ConfirmShard();
    DeleteShard();
    InterShardMemory.setLocal(JSON.stringify(global.intershardData));
};
/* 保存跨shard信息 */
const SaveShardMessage = function () {
    if (!Game.cpu.generatePixel)
        return;
    let Data = JSON.parse(InterShardMemory.getLocal()) || {};
    InterShardMemory.setLocal(JSON.stringify(global.intershardData ? global.intershardData : Data));
    delete global.intershardData; // 删除global数据
};
const crossShardAppPlugin = {
    tickStart: InterShardManager,
    tickEnd: SaveShardMessage
};

// import { RequestShard } from "@/shard/base"
/* 本地寻路移动 */
class CreepMoveExtension extends Creep {
    // 位置标准化
    standardizePos(pos) {
        return `${pos.roomName}/${pos.x}/${pos.y}/${Game.shard.name}`;
    }
    // 寻找不允许对穿的爬虫的位置
    getStandedPos() {
        var standedCreep = this.room.find(FIND_MY_CREEPS, {
            filter: (creep) => {
                return (creep.memory.standed == true || (creep.memory.crossLevel && this.memory.crossLevel && creep.memory.crossLevel > this.memory.crossLevel));
            }
        });
        if (standedCreep.length > 0) {
            var posList = [];
            for (var i of standedCreep) {
                posList.push(i.pos);
            }
            return posList;
        }
        return [];
    }
    // 通用寻路
    findPath(target, range, ops, ExcludePosition, plain, ExcludePositionroad) {
        /* 全局路线存储 */
        if (!global.routeCache)
            global.routeCache = {};
        if (!this.memory.moveData)
            this.memory.moveData = {};
        this.memory.moveData.index = 0;
        /* 查找全局中是否已经有预定路线，如果有了就直接返回路线 */
        const routeKey = `${this.standardizePos(this.pos)} ${this.standardizePos(target)}`;
        var route = global.routeCache[routeKey];
        if (route && this.room.name != target.roomName) {
            return route;
        }
        // 过道路口优先
        let allowedRooms = { [this.pos.roomName]: true, [target.roomName]: true };
        let swi = false;
        if (target.roomName != this.room.name) {
            const FindrouteKey = `${this.pos.roomName}|${target.roomName}`;
            /*检查是否存在已知的缓存*/
            if (Memory.Findrouteroom[FindrouteKey]) {
                for (let rroom of Memory.Findrouteroom[FindrouteKey].a) {
                    allowedRooms[rroom] = true;
                }
            }
            else {
                let myroomparsed = Number((/^[WE]([0-9]+)[NS]([0-9]+)$/.exec(this.room.name)));
                let disRoomparsed = Number((/^[WE]([0-9]+)[NS]([0-9]+)$/.exec(target.roomName)));
                /* 计算距离 如果两个房间之间距离过短就不这样做 */
                let enoughDistance = Math.sqrt(Math.abs(myroomparsed[0] - disRoomparsed[0]) ** 2 + Math.abs(myroomparsed[1] - disRoomparsed[1]) ** 2);
                if (enoughDistance > 3.6 || range > 3)
                    swi = true;
                if (swi) {
                    let ret = Game.map.findRoute(this.pos.roomName, target.roomName, {
                        routeCallback(roomName) {
                            var _a, _b;
                            // 在全局绕过房间列表的房间 false
                            if (Memory.bypassRooms && Memory.bypassRooms.includes(roomName))
                                return Infinity;
                            let parsed = (/^[WE]([0-9]+)[NS]([0-9]+)$/.exec(roomName));
                            let isHighway = (Number(parsed[1]) % 10 === 0) ||
                                (Number(parsed[2]) % 10 === 0);
                            let isMyRoom = (_b = (_a = Game.rooms[roomName]) === null || _a === void 0 ? void 0 : _a.controller) === null || _b === void 0 ? void 0 : _b.my;
                            if (isHighway || isMyRoom) {
                                return 1;
                            }
                            else {
                                return 2;
                            }
                        }
                    });
                    if (ret != ERR_NO_PATH) {
                        ret.forEach(function (info) {
                            allowedRooms[info.room] = true;
                        });
                        let routea = [];
                        for (let rooms in allowedRooms) {
                            routea.push(rooms);
                        }
                        /*将结果进行格式化存储操作*/
                        Memory.Findrouteroom[FindrouteKey] = {
                            t: Game.time,
                            a: routea
                        };
                    }
                }
            }
        }
        const result = PathFinder.search(this.pos, { pos: target, range: range }, {
            plainCost: plain ? plain : 2,
            swampCost: plain ? plain * 5 : 10,
            maxRooms: target.roomName == this.room.name ? 1 : 32,
            maxOps: ops ? ops : (target.roomName == this.room.name ? 750 : 8000),
            roomCallback: roomName => {
                if (!swi && Memory.bypassRooms && Memory.bypassRooms.includes(roomName))
                    return false;
                if (swi && allowedRooms[roomName] === undefined) {
                    return false;
                }
                // 在爬虫记忆绕过房间列表的房间 false
                const room = Game.rooms[roomName];
                let costs = new PathFinder.CostMatrix;
                if (ExcludePositionroad) { /*预制线路*/
                    if (ExcludePositionroad[roomName]) {
                        for (let _pos of ExcludePositionroad[roomName]) {
                            if (_pos.roomName != roomName) {
                                continue;
                            }
                            // console.log('排除位置',JSON.stringify(_pos))
                            costs.set(_pos.x, _pos.y, 1);
                        }
                    }
                }
                // 没有视野的房间只观察地形
                if (!room)
                    return;
                // 有视野的房间
                // 将道路的cost设置为1，无法行走的建筑设置为255
                room.find(FIND_STRUCTURES).forEach(struct => {
                    if (struct.structureType === STRUCTURE_ROAD) {
                        costs.set(struct.pos.x, struct.pos.y, 1);
                    }
                    else if (struct.structureType !== STRUCTURE_CONTAINER &&
                        (struct.structureType !== STRUCTURE_RAMPART || !struct.my))
                        costs.set(struct.pos.x, struct.pos.y, 0xff);
                });
                room.find(FIND_MY_CONSTRUCTION_SITES).forEach(cons => {
                    if (cons.structureType != 'road' && cons.structureType != 'rampart' && cons.structureType != 'container')
                        costs.set(cons.pos.x, cons.pos.y, 255);
                });
                /* 防止撞到其他虫子造成堵虫 */
                room.find(FIND_HOSTILE_CREEPS).forEach(creep => {
                    costs.set(creep.pos.x, creep.pos.y, 255);
                });
                room.find(FIND_MY_CREEPS).forEach(creep => {
                    if ((creep.memory.crossLevel && creep.memory.crossLevel > this.memory.crossLevel) || creep.memory.standed) {
                        costs.set(creep.pos.x, creep.pos.y, 255);
                    }
                    else {
                        costs.set(creep.pos.x, creep.pos.y, 3);
                    }
                });
                if (ExcludePosition) {
                    for (let _pos of ExcludePosition) {
                        if (_pos.roomName != roomName) {
                            continue;
                        }
                        // console.log('排除位置',JSON.stringify(_pos))
                        costs.set(_pos.x, _pos.y, 255);
                    }
                }
                return costs;
            }
        });
        // if (range == 18) {
        //     console.log(target.roomName)
        //     console.log(JSON.stringify(allowedRooms));
        //     console.log(JSON.stringify(room_list))
        //     console.log(JSON.stringify(okroom_list))
        //     console.log(this.name, swi, JSON.stringify(result))
        // }
        // 寻路异常返回null
        if (result.path.length <= 0)
            return null;
        // 寻路结果压缩
        route = this.serializeFarPath(result.path);
        if (!result.incomplete)
            global.routeCache[routeKey] = route;
        return route;
    }
    // 使用寻路结果移动
    goByPath() {
        if (!this.memory.moveData)
            return ERR_NO_PATH;
        const index = this.memory.moveData.index;
        // 移动索引超过数组上限代表到达目的地
        if (index >= this.memory.moveData.path.length) {
            delete this.memory.moveData.path;
            return OK;
        }
        // 获取方向，进行移动
        const direction = Number(this.memory.moveData.path[index]);
        const goResult = this.go(direction);
        this.memory.standed = false;
        // 移动成功，更新下次移动索引
        if (goResult == OK)
            this.memory.moveData.index++;
        return goResult;
    }
    // 通用移动 (配合findPath 和 goByPath)
    goTo(target, range = 1, ops, plain, CustomPositionroad) {
        //  var a = Game.cpu.getUsed()
        if (this.pos.inRangeTo(target, range))
            return OK;
        if (this.fatigue)
            return ERR_TIRED;
        if (this.memory.moveData == undefined)
            this.memory.moveData = {};
        // 确认目标没有变化，如果变化了就重新规划路线
        const targetPosTag = this.standardizePos(target);
        var ExcludePosition = {};
        if (targetPosTag !== this.memory.moveData.targetPos) {
            this.memory.moveData.targetPos = targetPosTag;
            if (CustomPositionroad) {
                for (var i of CustomPositionroad) {
                    var thisPos = unzipPosition(i);
                    if (!ExcludePosition[thisPos.roomName]) {
                        ExcludePosition[thisPos.roomName] = [];
                    }
                    ExcludePosition[thisPos.roomName].push(thisPos);
                }
            }
            this.memory.moveData.path = this.findPath(target, range, ops ? ops : null, this.room.memory.DefendDouPosition ? this.room.memory.DefendDouPosition : null, plain, ExcludePosition);
        }
        // 确认缓存有没有被清除
        if (!this.memory.moveData.path) {
            if (CustomPositionroad) {
                for (var i of CustomPositionroad) {
                    var thisPos = unzipPosition(i);
                    if (!ExcludePosition[thisPos.roomName]) {
                        ExcludePosition[thisPos.roomName] = [];
                    }
                    ExcludePosition[thisPos.roomName].push(thisPos);
                }
            }
            this.memory.moveData.path = this.findPath(target, range, ops ? ops : null, this.room.memory.DefendDouPosition ? this.room.memory.DefendDouPosition : null, plain, ExcludePosition);
        }
        // 还为空的话就是没有找到路径
        if (!this.memory.moveData.path) {
            delete this.memory.moveData.path;
            return OK;
        }
        // 使用缓存进行移动
        const goResult = this.goByPath();
        // 如果发生撞停或者参数异常，说明缓存可能存在问题，移除缓存
        if (goResult === ERR_INVALID_TARGET) {
            /*检查是否存在缓存*/
            if (this.room.name != target.roomName) {
                const routeKey = `${this.standardizePos(this.pos)} ${this.standardizePos(target)}`;
                if (global.routeCache[routeKey])
                    delete global.routeCache[routeKey];
            }
            delete this.memory.moveData;
        }
        else if (goResult != OK && goResult != ERR_TIRED) {
            this.say(`异常码：${goResult}`);
        }
        // var b = Game.cpu.getUsed()
        // this.say(`${b-a}`)
        return goResult;
    }
    // 请求对穿 按照对穿等级划分 等级高的可以任意对穿等级低的，等级低的无法请求等级高的对穿，等级相等则不影响
    requestCross(direction) {
        if (!this.memory.crossLevel)
            this.memory.crossLevel = 10; // 10为默认对穿等级
        // 获取目标方向一格的位置
        const fontPos = this.pos.directionToPos(direction);
        // 在出口、边界
        if (!fontPos)
            return ERR_NOT_FOUND;
        const fontCreep = (fontPos.lookFor(LOOK_CREEPS)[0] || fontPos.lookFor(LOOK_POWER_CREEPS)[0]);
        if (!fontCreep)
            return ERR_NOT_FOUND;
        if (fontCreep.owner.username != this.owner.username)
            return;
        this.say("👉");
        if (fontCreep.manageCross(getOppositeDirection(direction), this.memory.crossLevel))
            this.move(direction);
        return OK;
    }
    // 处理对穿
    manageCross(direction, crossLevel) {
        if (!this.memory.crossLevel)
            this.memory.crossLevel = 10;
        if (!this.memory)
            return true;
        if (this.memory.standed || this.memory.crossLevel > crossLevel) {
            if (!(Game.time % 5))
                this.say('👊');
            return false;
        }
        // 同意对穿
        this.say('👌');
        this.move(direction);
        return true;
    }
    // 单位移动 (goByPath中的移动基本函数)
    go(direction) {
        const moveResult = this.move(direction);
        if (moveResult != OK)
            return moveResult;
        // 如果ok的话，有可能撞上东西了或者一切正常
        const currentPos = `${this.pos.x}/${this.pos.y}`;
        if (this.memory.prePos && currentPos == this.memory.prePos) {
            // 这个时候确定在原点驻留了
            const crossResult = this.memory.disableCross ? ERR_BUSY : this.requestCross(direction);
            if (crossResult != OK) {
                delete this.memory.moveData;
                return ERR_INVALID_TARGET;
            }
        }
        this.memory.prePos = currentPos;
        return OK;
    }
    /* 压缩路径 */
    serializeFarPath(positions) {
        if (positions.length == 0)
            return '';
        // 确保路径里第一个位置是自己当前的位置
        if (!positions[0].isEqualTo(this.pos))
            positions.splice(0, 0, this.pos);
        return positions.map((pos, index) => {
            // 最后一个位置就不用再移动
            if (index >= positions.length - 1)
                return null;
            // 由于房间边缘地块会有重叠，所以这里筛除掉重叠的步骤
            if (pos.roomName != positions[index + 1].roomName)
                return null;
            // 获取到下个位置的方向
            return pos.getDirectionTo(positions[index + 1]);
        }).join('');
    }
    // 跨shard移动
    arriveTo(target, range, shard = Game.shard.name, shardData) {
        if (!this.memory.targetShard)
            this.memory.targetShard = shard;
        if (!shardData || shardData.length === 0) {
            if (shard == Game.shard.name) {
                this.goTo(target, range);
            }
            else {
                if (!this.memory.protalRoom) 
                // 寻找最近的十字路口房间
                {
                    if (Game.flags[`${this.memory.belong}/portal`]) {
                        this.memory.protalRoom = Game.flags[`${this.memory.belong}/portal`].room.name;
                    }
                    else {
                        this.memory.protalRoom = closestPotalRoom(this.memory.belong, target.roomName);
                    }
                }
                if (!this.memory.protalRoom || this.memory.protalRoom == null)
                    return;
                if (this.room.name != this.memory.protalRoom) {
                    this.goTo(new RoomPosition(25, 25, this.memory.protalRoom), 20);
                }
                else {
                    /* 寻找星门 */
                    var portal = this.room.find(FIND_STRUCTURES, {
                        filter: (structure) => {
                            return structure.structureType == STRUCTURE_PORTAL;
                        }
                    });
                    if (portal.length <= 0)
                        return;
                    var thisportal;
                    for (var i of portal) {
                        var porType = i.destination;
                        if (porType.shard == shard)
                            thisportal = i;
                    }
                    if (!thisportal)
                        return;
                    if (!this.pos.isNearTo(thisportal))
                        this.goTo(thisportal.pos, 1);
                    else {
                        /* moveData里的shardmemory */
                        /* 靠近后等待信息传送 */
                        var RequestData = {
                            relateShard: shard,
                            sourceShard: Game.shard.name,
                            type: 1,
                            data: { id: this.name, MemoryData: this.memory }
                        };
                        if (RequestShard(RequestData)) {
                            this.moveTo(thisportal);
                        }
                    }
                }
            }
        }
        else {
            /* 存在shardData则说明爬虫可能需要跨越多个shard */
            if (!this.memory.shardAffirm) {
                let data = [];
                for (let data_ of shardData) {
                    data.push({ shardName: data_.shard, roomName: data_.roomName, x: data_.x, y: data_.y, affirm: false });
                }
                this.memory.shardAffirm = data;
            }
            if (this.memory.shardAffirm.length === 0) {
                this.say("shardAffirm赋予错误!");
                return;
            }
            // 更新目的shardRoom
            for (var sr of this.memory.shardAffirm) {
                if (sr.disRoomName == this.pos.roomName && sr.disShardName == Game.shard.name) {
                    // console.log(sr.disRoomName, sr.disShardName, '片区到位切换状态', this.name)
                    sr.affirm = true;
                    break;
                }
            }
            // 确定下一个目的shardRoom
            let nextShardRoom = null;
            for (var nr of this.memory.shardAffirm) {
                if (!nr.affirm) {
                    nextShardRoom = { shard: nr.shardName, roomName: nr.roomName, x: nr.x, y: nr.y };
                    break;
                }
            }
            // 到达目标shard
            if (!nextShardRoom && Game.shard.name == this.memory.targetShard) {
                this.goTo(target, range);
                return;
            }
            // 没到达
            if (!nextShardRoom) {
                this.say('找不到nextShardRoom');
                return;
            }
            if (this.room.name != nextShardRoom.roomName) {
                this.goTo(new RoomPosition(25, 25, nextShardRoom.roomName), 20);
            }
            else {
                // console.log(JSON.stringify(nextShardRoom))
                /* 寻找星门 */
                var portal = this.room.find(FIND_STRUCTURES, {
                    filter: (structure) => {
                        return structure.structureType == STRUCTURE_PORTAL;
                    }
                });
                if (portal.length <= 0)
                    return;
                var thisportal;
                LoopA: for (var i of portal) {
                    var porType = i.destination;
                    // console.log(i.pos.x, nextShardRoom.x, i.pos.y, nextShardRoom.y)
                    if (i.pos.x == nextShardRoom.x && i.pos.y == nextShardRoom.y) {
                        // if (Game.shard.name == 'shard0')
                        // {
                        //     console.log('porType:',JSON.stringify(porType))
                        // }
                        /* 更新一下shardaffirm的disRoomName信息 */
                        LoopB: for (var sr of this.memory.shardAffirm) {
                            if (sr.roomName == this.pos.roomName && sr.shardName == Game.shard.name) {
                                sr.disRoomName = porType.room;
                                nextShardRoom.disShardName = porType.shard;
                                sr.disShardName = porType.shard;
                                // console.log(porType.room, porType.shard, '更新数据', this.name)
                                break LoopB;
                            }
                        }
                        // if (Game.shard.name == 'shard0')
                        // {
                        //     console.log('affirm:',JSON.stringify(sr))
                        // }
                        thisportal = i;
                        break LoopA;
                    }
                }
                // if (Game.shard.name == 'shard0')
                // {
                //     console.log('nextshardRoom:',JSON.stringify(nextShardRoom))
                // }
                if (!thisportal) {
                    console.log("找不到thisportal", this.name, JSON.stringify(this.pos));
                    return;
                }
                if (!this.pos.isNearTo(thisportal))
                    this.goTo(thisportal.pos, 1);
                else {
                    /* moveData里的shardmemory */
                    /* 靠近后等待信息传送 */
                    var RequestData = {
                        relateShard: nextShardRoom.disShardName,
                        sourceShard: Game.shard.name,
                        type: 1,
                        data: { id: this.name, MemoryData: this.memory }
                    };
                    // if (Game.shard.name == 'shard0')
                    // {
                    //     console.log('requestData:',JSON.stringify(RequestData))
                    // }
                    if (RequestData.relateShard) {
                        let RequestShardstate = RequestShard(RequestData);
                        // console.log(JSON.stringify(global.intershardData))
                        // console.log(JSON.stringify(RequestShardstate), this.name)
                        if (RequestShardstate) {
                            this.moveTo(thisportal);
                        }
                    }
                    else {
                        /* 说明可能是本地星门 */
                        this.moveTo(thisportal);
                        for (var nnr of this.memory.shardAffirm) // 更新affirm
                         {
                            if (!nnr.affirm) {
                                nnr.affirm = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
    }
    // 多次跨shard affirm更新模块
    updateShardAffirm() {
        if (this.memory.shardAffirm)
            for (var sr of this.memory.shardAffirm) {
                if (sr.disRoomName == this.pos.roomName && sr.shardName == Game.shard.name) {
                    sr.affirm = true;
                    return;
                }
            }
    }
    // 主动防御寻路
    findPath_defend(target, range) {
        /* 全局路线存储 */
        if (!global.routeCache)
            global.routeCache = {};
        if (!this.memory.moveData)
            this.memory.moveData = {};
        this.memory.moveData.index = 0;
        const routeKey = `${this.standardizePos(this.pos)} ${this.standardizePos(target)}`;
        /* 路线查找 */
        const result = PathFinder.search(this.pos, { pos: target, range: range }, {
            plainCost: 3,
            swampCost: 10,
            maxOps: 600,
            roomCallback: roomName => {
                // 在全局绕过房间列表的房间 false
                if (Memory.bypassRooms && Memory.bypassRooms.includes(roomName))
                    return false;
                // 在爬虫记忆绕过房间列表的房间 false
                if (this.memory.bypassRooms && this.memory.bypassRooms.includes(roomName))
                    return false;
                const room = Game.rooms[roomName];
                // 没有视野的房间只观察地形
                if (!room)
                    return;
                // 有视野的房间
                let costs = new PathFinder.CostMatrix;
                /* 设置主动防御范围 */
                if (room.name == this.memory.belong) {
                    /* 将房间边界设置为255 */
                    for (var x = 0; x < 50; x++)
                        for (var y = 0; y < 50; y++) {
                            if (isInArray([0, 49], x) || isInArray([0, 49], y)) {
                                costs.set(x, y, 255);
                            }
                        }
                }
                // 将rampart设置为 1 
                room.find(FIND_MY_STRUCTURES).forEach(struct => {
                    if (struct.structureType === STRUCTURE_RAMPART) {
                        costs.set(struct.pos.x, struct.pos.y, 1);
                    }
                });
                // 将道路的cost设置为2，无法行走的建筑设置为255
                room.find(FIND_STRUCTURES).forEach(struct => {
                    if (struct.structureType === STRUCTURE_ROAD) {
                        costs.set(struct.pos.x, struct.pos.y, 2);
                    }
                    else if (struct.structureType !== STRUCTURE_CONTAINER &&
                        (struct.structureType !== STRUCTURE_RAMPART || !struct.my))
                        costs.set(struct.pos.x, struct.pos.y, 255);
                });
                room.find(FIND_MY_CONSTRUCTION_SITES).forEach(cons => {
                    if (cons.structureType != 'road' && cons.structureType != 'rampart' && cons.structureType != 'container')
                        costs.set(cons.pos.x, cons.pos.y, 255);
                });
                room.find(FIND_HOSTILE_CREEPS).forEach(creep => {
                    if (parts(creep, 'ranged_attack') && hurts(creep)['ranged_attack'] > 1000) {
                        for (var i = creep.pos.x - 3; i < creep.pos.x + 4; i++)
                            for (var j = creep.pos.y - 3; j < creep.pos.y + 4; j++)
                                if (i > 0 && i < 49 && j > 0 && j < 49) {
                                    var nearpos = new RoomPosition(i, j, creep.room.name);
                                    if (!nearpos.GetStructure('rampart'))
                                        costs.set(i, j, 20);
                                }
                    }
                });
                /* 防止撞到其他虫子造成堵虫 */
                room.find(FIND_HOSTILE_CREEPS).forEach(creep => {
                    costs.set(creep.pos.x, creep.pos.y, 255);
                });
                room.find(FIND_MY_CREEPS).forEach(creep => {
                    if ((creep.memory.crossLevel && creep.memory.crossLevel > this.memory.crossLevel) || creep.memory.standed)
                        costs.set(creep.pos.x, creep.pos.y, 255);
                    else
                        costs.set(creep.pos.x, creep.pos.y, 3);
                });
                return costs;
            }
        });
        // 寻路异常返回null
        if (result.path.length <= 0)
            return null;
        // 寻路结果压缩
        var route = this.serializeFarPath(result.path);
        if (!result.incomplete)
            global.routeCache[routeKey] = route;
        return route;
    }
    /* 主动防御移动 */
    goTo_defend(target, range = 1) {
        Game.cpu.getUsed();
        if (this.memory.moveData == undefined)
            this.memory.moveData = {};
        // 确认目标没有变化，如果变化了就重新规划路线
        this.memory.moveData.path = this.findPath_defend(target, range);
        // 还为空的话就是没有找到路径
        if (!this.memory.moveData.path) {
            delete this.memory.moveData.path;
            return OK;
        }
        // 使用缓存进行移动
        const goResult = this.goByPath();
        // 如果发生撞停或者参数异常，说明缓存可能存在问题，移除缓存
        if (goResult === ERR_INVALID_TARGET) {
            delete this.memory.moveData;
        }
        else if (goResult != OK && goResult != ERR_TIRED) {
            this.say(`异常码：${goResult}`);
        }
        Game.cpu.getUsed();
        //this.say(`b-a`)
        return goResult;
    }
    // 逃离寻路
    Flee(target, range, ExcludePosition) {
        if (!this.pos.inRangeTo(target, range))
            return; //若已逃离目标范围则直接返回
        let avoid_pos = [];
        if (global.warData.tower[this.room.name]) {
            let _tower_data = global.warData.tower[this.room.name];
            if (_tower_data.data) {
                // console.log(this.room.name, JSON.stringify(_tower_data))
                for (let _pos of Object.keys(_tower_data.data)) {
                    let _tower_pos = global.warData.tower[this.room.name].data[_pos];
                    if (_tower_pos.avoid > 0) {
                        let posXY = unzipXandY(_pos);
                        // costs.set(posXY[0], posXY[1], _tower_pos.avoid)
                        avoid_pos.push(new RoomPosition(posXY[0], posXY[1], this.room.name));
                    }
                }
            }
        }
        let path = PathFinder.search(this.pos, { pos: target, range: range }, {
            plainCost: 1,
            swampCost: 20,
            maxOps: 600,
            flee: true,
            roomCallback: roomName => {
                if (Memory.bypassRooms && Memory.bypassRooms.includes(roomName))
                    return false;
                // 在爬虫记忆绕过房间列表的房间 false
                const room = Game.rooms[roomName];
                // 没有视野的房间只观察地形
                if (!room)
                    return;
                // 有视野的房间
                let costs = new PathFinder.CostMatrix;
                // 将道路的cost设置为1，无法行走的建筑设置为255
                room.find(FIND_STRUCTURES).forEach(struct => {
                    if (struct.structureType === STRUCTURE_ROAD) {
                        costs.set(struct.pos.x, struct.pos.y, 1);
                    }
                    else if (struct.structureType !== STRUCTURE_CONTAINER &&
                        (struct.structureType !== STRUCTURE_RAMPART || !struct.my))
                        costs.set(struct.pos.x, struct.pos.y, 0xff);
                });
                room.find(FIND_MY_CONSTRUCTION_SITES).forEach(cons => {
                    if (cons.structureType != 'road' && cons.structureType != 'rampart' && cons.structureType != 'container')
                        costs.set(cons.pos.x, cons.pos.y, 255);
                });
                /* 防止撞到其他虫子造成堵虫 */
                room.find(FIND_HOSTILE_CREEPS).forEach(creep => {
                    costs.set(creep.pos.x, creep.pos.y, 255);
                });
                room.find(FIND_MY_CREEPS).forEach(creep => {
                    if ((creep.memory.crossLevel && creep.memory.crossLevel > this.memory.crossLevel) || creep.memory.standed) {
                        costs.set(creep.pos.x, creep.pos.y, 255);
                    }
                    // else
                    //     costs.set(creep.pos.x, creep.pos.y, 3)
                });
                for (let _pos of avoid_pos) {
                    if (_pos.roomName == roomName) {
                        costs.set(_pos.x, _pos.y, 5);
                    }
                }
                return costs;
            }
        });
        var direction = this.pos.getDirectionTo(path.path[0]);
        if (!direction)
            return;
        this.move(direction);
    }
    // 一体机寻路
    findPath_aio(target, range) {
        /* 全局路线存储 */
        if (!global.routeCache)
            global.routeCache = {};
        if (!this.memory.moveData)
            this.memory.moveData = {};
        this.memory.moveData.index = 0;
        const routeKey = `${this.standardizePos(this.pos)} ${this.standardizePos(target)}`;
        /* 路线查找 */
        const result = PathFinder.search(this.pos, { pos: target, range: range }, {
            plainCost: 2,
            swampCost: 20,
            maxOps: 600,
            roomCallback: roomName => {
                // 在全局绕过房间列表的房间 false
                if (Memory.bypassRooms && Memory.bypassRooms.includes(roomName))
                    return false;
                // 在爬虫记忆绕过房间列表的房间 false
                if (this.memory.bypassRooms && this.memory.bypassRooms.includes(roomName))
                    return false;
                const room = Game.rooms[roomName];
                // 没有视野的房间只观察地形
                if (!room)
                    return;
                // 有视野的房间
                let costs = new PathFinder.CostMatrix;
                /* 设置主动防御范围 */
                if (room.name == this.memory.belong) {
                    /* 将房间边界设置为255 */
                    for (var x = 0; x < 50; x++)
                        for (var y = 0; y < 50; y++) {
                            if (isInArray([0, 49], x) || isInArray([0, 49], y)) {
                                costs.set(x, y, 255);
                            }
                        }
                }
                // 将道路的cost设置为2，无法行走的建筑设置为255
                room.find(FIND_STRUCTURES).forEach(struct => {
                    if (struct.structureType === STRUCTURE_ROAD) {
                        costs.set(struct.pos.x, struct.pos.y, 2);
                    }
                    else if (struct.structureType !== STRUCTURE_CONTAINER &&
                        (struct.structureType !== STRUCTURE_RAMPART || !struct.my))
                        costs.set(struct.pos.x, struct.pos.y, 255);
                });
                room.find(FIND_MY_CONSTRUCTION_SITES).forEach(cons => {
                    if (cons.structureType != 'road' && cons.structureType != 'rampart' && cons.structureType != 'container')
                        costs.set(cons.pos.x, cons.pos.y, 255);
                });
                room.find(FIND_HOSTILE_CREEPS).forEach(creep => {
                    if (parts(creep, 'attack')) {
                        for (var i = creep.pos.x - 3; i < creep.pos.x + 4; i++)
                            for (var j = creep.pos.y - 3; j < creep.pos.y + 4; j++)
                                if (i > 0 && i < 49 && j > 0 && j < 49) {
                                    new RoomPosition(i, j, creep.room.name);
                                    costs.set(i, j, 16);
                                }
                    }
                    else if (parts(creep, 'ranged_attack')) {
                        for (var i = creep.pos.x - 3; i < creep.pos.x + 4; i++)
                            for (var j = creep.pos.y - 3; j < creep.pos.y + 4; j++)
                                if (i > 0 && i < 49 && j > 0 && j < 49) {
                                    new RoomPosition(i, j, creep.room.name);
                                    costs.set(i, j, 15);
                                }
                    }
                });
                /* 防止撞到其他虫子造成堵虫 */
                room.find(FIND_HOSTILE_CREEPS).forEach(creep => {
                    costs.set(creep.pos.x, creep.pos.y, 255);
                });
                room.find(FIND_MY_CREEPS).forEach(creep => {
                    costs.set(creep.pos.x, creep.pos.y, 255);
                });
                return costs;
            }
        });
        // 寻路异常返回null
        if (result.path.length <= 0)
            return null;
        // 寻路结果压缩
        var route = this.serializeFarPath(result.path);
        if (!result.incomplete)
            global.routeCache[routeKey] = route;
        return route;
    }
    /* 一体机移动 */
    goTo_aio(target, range = 1) {
        if (this.memory.moveData == undefined)
            this.memory.moveData = {};
        // 确认目标没有变化，如果变化了就重新规划路线
        this.memory.moveData.path = this.findPath_aio(target, range);
        // 还为空的话就是没有找到路径
        if (!this.memory.moveData.path) {
            delete this.memory.moveData.path;
            return OK;
        }
        // 使用缓存进行移动
        const goResult = this.goByPath();
        // 如果发生撞停或者参数异常，说明缓存可能存在问题，移除缓存
        if (goResult === ERR_INVALID_TARGET) {
            delete this.memory.moveData;
        }
        else if (goResult != OK && goResult != ERR_TIRED) {
            this.say(`异常码：${goResult}`);
        }
        Game.cpu.getUsed();
        return goResult;
    }
}

const BoostedPartData = {
    'UH': 'attack',
    'UH2O': 'attack',
    'XUH2O': 'attack',
    'UO': 'work',
    'UHO2': 'work',
    'XUHO2': 'work',
    'KH': 'carry',
    'KH2O': 'carry',
    'XKH2O': 'carry',
    'KO': 'ranged_attack',
    'KHO2': 'ranged_attack',
    'XKHO2': 'ranged_attack',
    'LH': 'work',
    'LH2O': 'work',
    'XLH2O': 'work',
    'LO': 'heal',
    'LHO2': 'heal',
    'XLHO2': 'heal',
    'ZH': 'work',
    'ZH2O': 'work',
    'XZH2O': 'work',
    'ZO': 'move',
    'ZHO2': 'move',
    'XZHO2': 'move',
    'GH': 'work',
    'GH2O': 'work',
    'XGH2O': 'work',
    'GO': 'tough',
    'GHO2': 'tough',
    'XGHO2': 'tough',
};

/**
 * 名字数据(包括可以说的话)
 */
const nameData = {
    '胡桃': {
        // 日常语音
        peace: [
            '不如去我那喝杯茶？嘿嘿~', '一个客户，两个客户，三个客户', '哎呀,麻烦啦…', '咳咳太阳出来我晒太阳', '月亮出来我晒月亮咯', '打雷啦！起身啦！', '哇！！！是雪！！！', '嗯…真舒服', '啊!帽子都要吹飞了…', '嗯~早起身体好', '晚睡人会飘~', '哟!中午好呀!吃了嘛?', '嘿嘿嘿，月亮出来咯，咱也出来了！', '喔，困了吗？那你好好休息，我一个人四处转转',
            '胡桃的胡，是胡吃海喝的。胡桃的桃，却不是淘气的桃！哈哈哈哈哈…嗯？不好笑嘛', '变个戏法给你看，瞧好咯…火！然后…芜湖~火蝴蝶！飞吧！', '你到处旅行，一定见多识广。有空，也给我讲讲你自己的故事吧？', '需要帮手嘛？需要帮手嘛？我来啦！若你需要帮助，胡桃我定当全力以赴，绝不推辞！', '神之眼…神之眼？嗯…这东西，随缘就好',
            '哦呀？哦呀呀？', '大丘丘病了，二丘丘瞧~三丘丘买药，四丘丘熬~五丘丘死了，六丘丘抬！', '小巷派暗黑打油诗人，正是本人~', '天青海阔，皓月凌空。此情此景正适合作诗一首。', '哎，真想找些新乐子，无所事事比死亡可怕多了', '啦啦啦啦~ 吃水煮鱼配虾饺啦~',
        ],
        // 战时语音
        war: [
            '喝！', '起！', '散！', '吃饱喝饱，一路走好！', '再会啦！', '蝶火燎原！', '嚯——！', '走~', '咻~', '噫——！', '糟糕！', '到我了吗…', '我记…仇…', '呃啊——', '干嘛呀！', '哦？该我出马了？', '你很有眼光嘛！', '一波送走，全送走！'
        ],
    },
    '刻晴': {
        peace: [
            '耽误太多时间，事情可就做不完了', '劳逸结合是不错，但也别放松过头。', '无论是冒险还是做生意，机会都稍纵即逝。', '好大的雨…真耽误事。所以说他们的工作，明明昨天就能做完，为什么要拖到今天？', '没关系，继续前进吧。这种程度的雪，算不了什么。', '啊…天气真好，工作又正好告一段落，要不要…去逛逛街呢？', '夜幕降临，灯火初上。嗯——又是安宁祥和的一天呢。',
            '祝你好梦。我吗？…嗯，还有十来件事要处理，做完就能休息了。', '在你看来，支撑璃月走过千年，最重要的东西是什么？', '心有所向，日复一日，必有精进。', '很好，在需要随机应变的时候，又多了一种选择。', '能和你一路结伴而行，我感觉受益匪浅。如果真的有一天，我抵达了理想中的终点，我的身边，还会有你陪伴吗？'
        ],
        war: [
            '去吧！', '迅影如剑！', '可别眨眼。', '喝啊——！', '嘿！', '哈！', '无处可逃！', '剑出，影随——', '剑光如我，斩尽芜杂！', '以退为进…', '调整战略吧。', '时机…不对。', '太不甘心了…', '辜负了…期待。', '唔…可恶。', '小伤而已。', '只是巧合…', '走吧，时间紧迫。', '是突发事件吗？', '速战速决。'
        ]
    },
    '甘雨': {
        peace: [
            '安逸的氛围…喜欢。', '趴在草地上，能听见大地的心跳', '工作…工作还没有做完…真的可以提前休息吗？', '嗯？天晴了吗？是什么时候…', '嗯。空气很适宜。', '啊，琉璃百合的味道，真好啊…', '早上好…唔？是哪里没有梳理好吗，请不要盯着我的…盯着我的头饰看。', '愿帝君保佑你', '饮必甘露，食必嘉禾。', '力量？…真是久违了。', '如果…可以用和平的方式解决。不，没什么…', '这就是新的生活之道吧…我明白了，我不会抱怨的。'
        ],
        war: [
            '禁止接触。', '闲人勿扰。', '霜寒化生。', '风雪的缩影。', '如琉璃般飘落。', '这项工作，该划掉了。', '为了岩王帝君！', '下一项工作是…', '我会跟上的…', '运动，是必要的…', '…是我久疏战场。', '欸？好像弄砸了？', '需要…补充能量。', '帝君…对不起…', '「契约」…尚未完成…', '我得…再撑一会…', '疏忽了…'
        ]
    },
    '神子': {
        peace: [
            '很多人的一生，写于纸上也不过几行，大多都是些无聊的故事', '嗯~伤脑筋，中午吃些什么呢？', '嗯~伤脑筋，中午吃些什么呢？', '现在的巫女，一个比一个可爱', '明明生命短暂，却能散发映昼光辉', '随我一同去月下漫步吧，不许拒绝。'
        ],
        war: [
            '律令。', '咒禁。', '敕！', '显化。', '留形。', '真瞳显现！', '雷霆侘寂！', '雷光凄美啊。', '这样下去可不行啊。', '可不能再玩下去了。', '好了，要认真一些了哦。', '哎呀，玩过头了…', '结局真是糟糕啊…', '止步于此，何谈永恒…', '就这样？', '真是麻烦。', '这时候想起我了？'
        ]
    },
    '凌人': {
        peace: [
            '暗线已经布置妥当，嗯，差不多该收网了…', '暂且先避下雨吧，不必着急，很快就会有人来送伞了。', '如今的雪景，与多年前的那场雪…并无二致。', '既然在这个时间点找我，不如留下来吃晚饭吧。', '能力提高了？呵，那可真是好事。', '力量这种东西，果然只有掌握在自己手中，才能安心。', '坐上家主之位以后，我少有松懈的时刻。有你在旁的这段日子，却有些奇妙。嗯…就好像在晒太阳一样吧。'
        ],
        war: [
            '苍流水影。', '剑影。', '秋水三尺。', '呵…安息吧。', '神里流…水囿！', '那么，我也认真起来吧。', '不知鹿死谁手呢？', '百密终是有一疏么…', '花无百日红…', '世事无常…', '不过如此。', '不自量力…', '哦？是邀请我去散步吗？'
        ]
    },
    '五郎': {
        peace: [
            '枕戈坐甲，才能应对变数。', '难得没有战事，来场体能训练吧！', '尾巴湿了…找堆篝火烤一烤吧。', '有敌情吗！', '晒太阳虽好，士气却不能松懈啊。', '晨练时间到了，要和我一起去登山吗？', '强大的力量，是为了保护同伴。', '要保护同伴，不能只是被动防守，必须积极进攻。', '攻夺胜利的要领，是牢记战斗的意义，遵循正确的战法，拿出锐不可当的气势。', '有了锐不可当的气势，与战友们紧密配合，方可无往不胜。谢谢你的指点！这是属于你我二人共同的胜利。'
        ],
        war: [
            '进军！', '强攻！', '结阵！', '随我出征！', '势如破竹！', '兵贵先声！', '今日运势不错！', '我还能战斗！', '没到认输的时候！', '兵败了…', '海祇岛的…大家…', '全军…撤退…', '不痛不痒！', '整装待发！', '准备进军！', '行兵列阵！'
        ]
    },
    '申鹤': {
        peace: [
            '回向正道，保身护命...', '刀枪无眼，红绳的力量也有极限，所以我才不喜欢人多的地方。', '按照凡人的做法，这种时候，是否应该…撑伞？', '早安。晨露很甜，要分一点给你吗？', '若是午后困乏，不妨试试打坐养神，很有效果。', '放心休息吧，我睡眠很浅，有什么动静，我会替你查看的。', '邪祟易驱，心魔难除。若自身无法放下执念，仙法与术式都无从挽回。', '我能操控的力量…愈发强大了。', '	师父若知道了，怕是会让我多系几根红绳吧…', '心无杂念，方可超然'
        ],
        war: [
            '听令！', '显！', '魂出！', '炼气化神！', '意生冰身！', '付君真形！', '天真敕奏！', '寒冰变神！', '依律奉行！', '休要怪我…', '我不甘心…', '必须…诛除！', '难逃…宿命…', '死丧既定…', '劫煞为灾…', '不成气候。', '休想！', '别后悔！'
        ]
    },
    '云堇': {
        peace: [
            '不勒头，不画脸，今天乐得清闲。', '云婵娟来花婵娟，风流尽在山水间。', '喂呀，冻煞我了。', '暖阳和煦，真是好风光啊。', '夜里寒气重，早点歇息，晚安。', '业精于勤而荒于嬉', '勤学苦练至今，总算是有了些成果。'
        ],
        war: [
            '着！', '崩！', '旗来！', '飞云旗！', '看枪！', '听我号令！', '戮力同心！', '一鼓作气！', '别把裙子弄坏了…', '得重整旗鼓才行。', '哼，好戏在后面。', '哼，好戏在后面。', '罢了…', '没办法…唱下去了…', '要沉住气…', '有点狼狈…', '下手好重…', '今天该唱哪出呢？'
        ]
    },
    '优菈': {
        peace: [
            '西风剑术？想和我学两手吗？等你学成再找你报仇，想必能增添不少乐趣。', '快到伞下来，别被淋湿了。要是你得了病，身体早早就垮掉，那我找谁报仇去？', '麻烦的天气，雷声会干扰听觉，影响我对周边的感知。', '不错，以我现在的实力，哪怕和代理团长一较高下，也十拿九稳了！', '凉爽的事，我都很中意。', '浓郁的汤品，我实在不能接受。'
        ],
        war: [
            '求饶吧。', '结霜！', '粉化！', '判决！', '破碎！', '以眼还眼！', '冰浪怒涛！', '以霜还怨！', '坚冰，断绝深仇！', '加快脚步。', '开战不利…', '要正式接敌了…', '不赖嘛！', '狼狈的收场…', '我还能…撑住…', '罪人的结局吗…', '游击骑士，率先行动。'
        ]
    },
    '阿贝多': {
        peace: [
            '风景不错，趁着休息，就把这一幕画下来吧。', '「世界的真相」…究竟是什么呢？', '光线充足，生物行为活跃，嗯，很适合写生。', '午安，我听到了你的脚步声', '外面安静下来了，呼。', '天才？…不少人这么称呼我。其实，我不这样认为。', '「黑土」，是炼金术的词源，也是最初的状态。活在这个世界上，我等俗类必须寻找意义。', '「白垩」，即是变化的开始。抽离了杂质，准备好接受一切知识。要和我一起去探索世界吗？', '「赤成」，炼金术的意思是，情感的炼化。我的赤色好像来自于你。', '「黄金」，炼金术最后的阶段。无价值的事物终于找到了自己的意义，变化成了黄金。我，也找到了意义。'
        ],
        war: [
            '绽放吧。', '拟造阳华。', '创生之法。', '此即，诞生之刻。', '冥古，于此显生。', '见证伟业吧。', '大地的秘宝。', '无言的叙事。', '计算失误…', '需要重新评估…', '必须改变策略。', '尘归尘，土归土…', '实验失败了吗？', '我的研究，结束了…', '阈值以内…', '失算了…'
        ]
    },
    '托马': {
        peace: [
            '这几天花得太多，身上只剩十摩拉了，不过幸好还有十摩拉！', '怎么突然下雨了？你没事吧？要不要用我的外套挡挡？', '别在雪地上跑哦，摔了我可不扶你。', '天气真不错啊，一起散步吧。', '嗯，晚安。你这一天也辛苦了吧。早点休息去吧，别熬夜。', '既然得到了神之眼，就得好好珍惜，我可不想把它弄丢了。', '这样就能变强吗？不是在开玩笑吧，我还有衣服没洗完呢。', '似乎…有一股火焰在我心中燃烧。', '拥有了强大的力量，要用来做什么呢？嗯…得好好考虑考虑了啊。', '谢谢你对我的信赖。你给予我的恩惠，比火焰更温暖。放心吧，我找到自己想做的事了。这份力量将化作坚盾，一直守护你。'
        ],
        war: [
            '火之盾！', '看看这个', '小心着火', '后援登场。', '护持之火！', '我来守护你。', '里面有什么好东西呢？', '惨了惨了…', '喂！有必要吗？', '嘶，有那么点疼…', '要回老家了啊…', '各位…保重。', '没能尽到…守护的职责…', '疼疼疼。', '好吧，家务待会再说。'
        ]
    },
    '公子': {
        peace: [
            '哟，伙伴！今天精神不错啊', '哈——吃的真爽。活动活动，消化一下好了。', '真是愉快的一天。明天再见，伙伴！', '	在这干站着，也不会有对手找上门的。', '哈哈哈，不知老家那边，是否也在下雪？', '啊！风中传来了纷争的气息。', '真是畅快的风！', '感觉身体和头脑，都被穿过的风洗净了。真舒畅。', '	只要能让我变强，「神之眼」也好，「邪眼」也好，师承深渊的罪人也好，都无所谓…', '喔！好像变强了一些，找谁试试好了…'
        ],
        war: [
            '要上了！', '哈！', '势如狂澜！', '来吧！', '接下来———', '呼———', '一箭止水！', '逃得掉吗！', '破绽，稍纵即逝！', '忍着点。这可是很痛的！', '兵贵神速。', '哈！有点意思。', '不赖嘛！', '生死边缘而已，我很擅长处理。', '怎能这样...得而复失...', '失手了...', '还挺...有两下子...', '嘁！大意了。', '哈，强敌何在？'
        ]
    },
    '重云': {
        peace: [
            '正午灵气极盛，可得抓紧练功。', '晚间最适静息凝神，更要抓紧练功。', '方士驱邪一靠咒术，二赖武艺。另辟蹊径亦可，但终非正道。', '驱邪缚魅，内外澄清，啊，呃…糟了，后半句口诀忘了。', '雨是无根水，是最澄净的水，对驱邪除魔大有帮助。', '大有帮助。打雷的时候…', '啊…好天气，真是舒服。', '习武与术法一样，都有境界。受你指导，我又有进益了。'
        ],
        war: [
            '剑印染冰！', '剑，出！', '急如敕令', '听我法旨。', '邪魔退去！', '宝印幻剑！', '束手伏诛吧。', '且看踏风纵云的本领。', '这等器物，有助于驱邪除魔。', '不枉你我一番劳苦！', '小伤不足挂齿。', '不能再轻敌了。', '你莫猖狂！', '还是技不如人吗…', '辱没了…方士一门…'
        ]
    },
    '凝光': {
        peace: [
            '「琉璃亭」和「新月轩」，你更常去哪一家？', '茶馆已经客满了？那就来「群玉阁」坐坐吧。只要…你付得起价钱。', '找笔新的投资吧。无论如何，摩拉都不会嫌多。', '哦？下雨了啊。替我打伞吧。', '不过是寻常雪景。我带你见见，真正的「碎雪」。', '	风平浪静？呵，不要相信你的眼睛，眼睛会说谎。', '	这样的大风天，会成为捕鱼人的灾难。也会成为…呵，没什么。', '时间和摩拉作为筹码，等价交换到「力量」吗…有趣。我认可它的价值。', '武斗」缺乏风度，只能作为下策中的下策。'
        ],
        war: [
            '雕虫小技。', '别白费功夫。', '哼，劝你放弃。', '你的性命，我收下了。', '向我臣服吧。', '永别了', '竟然敢伤我', '我记下了。', '哼。', '这世上之人，皆为棋子…', '胜负已分…真是无可奈何。', '这就是，「天权」的终焉？…', '血债血还。'
        ]
    },
    '烟绯': {
        peace: [
            '律法既是约束，也是工具，请你千万记住哦！记不住的话，我就多给你念叨两遍。', '法理与人情有时冲突，有时兼容。权衡二者，真是种学问呢。', '唔唔，居然还有这种案件…天下之大，无奇不有啊。', '这…这是什么倒霉天气，有、有点冷哦…阿嚏…', '趁着天好，背背律条', '钟离先生学识渊博，堪称行走的书库', '「不期修古，不法常可」，这句话是我必须牢记的教诲。', '唯有遵循应守之「律」，人才能获得解开一切问题的「法」。', '生日快乐，这个匣子送你'
        ],
        war: [
            '嘣嘣——', '焚烧吧！', '速速退下！', '律火，引！', '食炎之罚！', '丹书铁契！', '什么，有纰漏？', '得修正错误！', '你犯规…', '判断…失误了吗…', '律法…还有漏洞…', '我不能…接受…', '麻烦了…'
        ]
    },
    '雷神': {
        peace: [
            '徒然无事，对砚枯坐。哼。', '无人相陪，此般花鸟余情，也不过衬托我身不移不变的背景罢了。', '只是雨滴有什么麻烦的。这还没有打雷呢。', '冬将军也来了。', '雷鸣闪电，一瞬即逝。正因如此，才会想要撷取「永恒」。不，才必须掌握「永恒」。', '有什么事情，说来便是。'
        ],
        war: [
            '威光无赦！', '无处遁逃！', '泡影看破！', '无念，断绝！', '此刻，寂灭之时！', '稻光，亦是永恒！', '…枷锁当断。', '…诸恶当斩。', '…肃清阻碍。', '浮世一梦…', '无念，无执…', '雷鸣，将歇…', '无礼…', '荒谬…'
        ]
    },
    '神里': {
        peace: [
            '请多指教哦。', '像这样悠闲安稳的时光，如果再多一点就好了…我真贪心啊。', '剑，就和茶一样，细细品味才能理解其中风雅。', '刀剑抱业，名工怀宝。', '请随我一同避雨吧。', '大御所大人…是在诉说什么吗？', '雪霁银妆素，桔高映琼枝。', '风和日丽，要去哪边走走么？', '晚上好。夜风舒畅，会是一个良宵呢。', '若知是梦何须醒，不比真如一相会。', '	非常感谢。与你切磋使我受益良多，相信在剑术上也能更进一步。', '尝有所思，斯世如磐；孰料浮世事，留驻难。'
        ],
        war: [
            '起舞吧。', '失礼了。', '雪纷飞。', '…拿下了！', '樱吹雪。', '神里流…霜灭！', '久违的对手…', '不容小觑呢。', '该决断了…', '失态了…', '我还有…未竟之事…', '让家族…蒙羞了…', '无礼的家伙…'
        ]
    },
    '九条': {
        peace: [
            '只有保持心、弓、箭三位一体，才能命中正鹄。', '为将军大人实现「永恒」，这就是我的「愿望」。', '想要留住雪花。但在手心里，它只会融化得更快。', '天清气朗，适合演武', '我没有午休的习惯，但如果你想，我可以等你。', '去休息吧，这里有我看着就行。', '满意的弦音，看我一击即中。', '力量已经融入我体内，随时听命。', '我一个人，就是一支幕府军！'
        ],
        war: [
            '羽移！', '散！', '雷闪！', '常道恢弘，鸣神永恒！', '落雷…不悔！', '雷光千道！', '我会坚持到底…', '必须寻找突破点！', '快到极限了…', '生命终非永恒。', '我绝无怨言…', '哼，是我败了。', '战况不顺…'
        ]
    },
    '心海': {
        peace: [
            '我是珊瑚宫心海，海祇岛的「现人神巫女」', '雨中行军，可以隐蔽声息，但对体能却是很大的考验…', '雪…真漂亮呀', '天色真好，一起走走吧？', '嗯…这么大的风，正适合用火攻之计。', '好好休息，养精蓄锐。晚安。', '真希望这次作战快点结束', '越是情况紧迫，越要稳住心态', '我其实，并不擅长与人交流', '我虽然并不崇尚武力，但能够变强是一件好事。', '力量在不断地涌出…想必下次作战，我们可以配合得更好。', '沧海月明，潮起潮落。力量更进一步，心境也会有所不同。'
        ],
        war: [
            '帮帮忙！', '别担心。', '休养生息。', '沧海之约', '翻涌吧！', '深海的加护！', '我们走吧。', '好累…', '需要变更战术。', '谨慎为上。', '计策…出问题了吗？', '失误了…', '不会再犯同样的错误。', '失策！', '真难缠…'
        ]
    },
    '万叶': {
        peace: [
            '飘摇风雨中，带刀归来赤脚行', '既然手边有树叶，我可以为你吹奏一曲。', '在大雨中漫步，让人神志清醒。不过等雨停之后，还是尽快把衣服烤干比较好。', '飘摇风雨中，睹物思故乡，这把刀…是我与故乡唯一的联系了。', '晴空万里，真让人心情愉快。', '我喜欢下雪，雪后的世界很安静，无人来扰我清梦。', '抬头见月，侧耳听风，壶中有酒，我心太平…', '安静的世界，适合好好休息。明天见。', '找个好天气，出海看看如何？', '海上的风浪很大，我也要变得更强。', '这把刀，更加锋利了。', '雪落在地上的声音，细不可闻…但现在的我，应该可以听到了。'
        ],
        war: [
            '起！', '嘿！', '踏风！', '御风而行。', '朔风解意。', '往返自然！', '云隐…雁鸣！', '风共云行。', '可叹，落叶飘零。', '该出发了。', '呼、有一套嘛…', '静心凝神。', '保持专注！', '深感遗憾…', '下次…绝不会再…', '结束了吗…', '不要…紧。'
        ]
    },
    '早柚': {
        peace: [
            '「终末番」早柚，参上。', '呼啊…呼噜呼噜——', '工作还不如睡觉。', '什么时候才能长高呢？', '快躲雨，被雨淋到就长不高了。', '舒舒服服的好天气，啊——好困哦。', '风起之时，便是开溜的好时机。', '好困，午睡时间还没到吗？', '终于…可以睡觉了…晚…晚安…', '我有长高一点点吗？', '太好了，能溜得更快了，这下子肯定不会被抓住了。'
        ],
        war: [
            '走啦。', '溜咯。', '咕噜，哈！…嘿呀。', '极意遁走。', '抓不住我…呜。', '随风而遁…呜。', '分身之术。', '出来吧！', '嘿咻…呜。', '疾风遁术。', '头晕乎乎的。', '逃跑的话，该用…', '没能…逃掉…', '…晚、晚安了…', '不该偷懒的…'
        ]
    },
    '宵宫': {
        peace: [
            '欢迎光临「长野原」', '烟花易逝，人情长存。', '没事做的话，我来给你讲故事吧！', '你养过金鱼吗？很乖巧很可爱哦。', '哈哈，看我搓个雪球，咻——', '	呜哇，烟花要湿透了！得找地方躲躲，啊，要来不及了！', '风好大啊——声音都被吹回来啦——！', '飞得更高，炸得更响！', '邪恶退散！正义必胜！'
        ],
        war: [
            '想看烟花吗？', '点燃引信！', '小心火烛~', '祭典重现！', '金鱼来啦！', '烟花来喽！', '不妙不妙！', '出丑了啊…', '得小心起来了啊…', '一不小心就…', '玩过头了…', '祭典…结束了。'
        ]
    },
    '钟离': {
        peace: [
            '旅程总有一天会迎来终点，不必匆忙', '为「流通」而造的船，遇到港口也会停泊', '欲买桂花同载酒…只可惜故人，何日再见呢？', '嗯…不适合度假的天气。去听听戏吧。', '希望今日也有好景气。', '不以规矩，不能成方圆', '不管是常人还是仙人，惟有各司其职，方能保璃月长久太平。', '当代堂主？嗯…那孩子，我应付不来。', '	怎么，难得闲暇，不好好休息却反来找我。是想听我讲故事吗？', '力量似乎渐渐回来了。不多，但有用。'
        ],
        war: [
            '壁立千仞。', '震天撼地。', '靡坚不摧。', '俱收并蓄。', '安如磐石。', '固若金汤。', '天理长驱。', '此乃天道。', '天动万象。', '你的实力我姑且认可。', '哈，有点意思。', '不太擅长危机应对啊。', '啊，略感疲惫…', '让你看到，难堪的一面了啊。', '磐石…也会归于尘土…'
        ]
    },
    '魈': {
        peace: [
            '荒野上的孤魂，休想伤我分毫。', '…呃啊…哼，想起了一些不愉快的事。', '魔物不会因为下雨就休息。我们走', '天晴了？哼，我不关心天气。', '雪积起来之后，就可以挖着吃了。', '时候不早了。出发吧。', '午餐…回望舒客栈吧。', '夜晚，不祥之物最易骚动。你最好别出门。', '你去吧，我会在这里等你。', '如果有一天，连你也陷入了黑暗。就由我来——', '杀戮是我的强项。如果你下不去手，就叫我来。', '杏仁豆腐的味道，和「美梦」非常相似呢', '力量的尽头，是自我毁灭。回答我，为何如此执着呢？', '新的力量？这力量，也只会被用于斩杀', '只是这种程度而已。没什么值得大惊小怪的。'
        ],
        war: [
            '哼。', '无聊。', '无用。', '这里！', '无能。', '就此消失。', '靖妖傩舞。', '悲鸣吧。', '对你有用便好。', '住口。', '愚蠢。', '这是…报应吗。', '这一天…到来了呀。', '就凭你？', '听召而来。', '诸邪退散。'
        ]
    },
    '可莉': {
        peace: [
            '西风骑士团「火花骑士」，可莉，前来报到！', '哼哼哼，这次的炸弹可是防水的。', '啊！什么东西爆炸了？！…哦，是打雷啊。', '早安！带可莉出去玩吧！我们一起来冒险！', '琴团长是好人！虽然…有点可怕…', '你好！你是来找可莉玩的吗？'
        ],
        war: [
            '蹦蹦炸弹！', '弹起来吧！', '嘿咻！', '轰轰火花！', '火力全开！', '全——都可以炸完！', '啦啦啦~', '哇…怎么会这样…', '琴团长…它欺负我…', '玩累了，有点晕…', '可莉…想回家了…', '又闯祸了…', '好疼啊！'
        ]
    },
    '迪奥娜': {
        peace: [
            '哈～～好舒服，身体都变得更柔软了', '才,才没有在等你。我只是，正好在休息而已！', '唉？！…我没有在发抖！没有！…呜…', '这个凉飕飕的触感，哇…好棒,好有趣。', '猫的眼睛，看得见黑暗中的一切猎物！', '猫的四肢，爬的上全提瓦特最高的树。'
        ],
        war: [
            '嘿…呀！', '咻咻——', '目标确认。', '攻守兼备。', '抓到你了', '我可不好欺负！', '迪奥娜特调！', '贪杯的下场…哼！', '反省吧，酒鬼', '唔，来了。', '我不会认输…！', '酒的味道…好臭…', '泉水精灵…不要走…', '眼睛…睁不开了…'
        ]
    },
    '砂糖': {
        peace: [
            '那是什么？啊…不见了，我可以去看看吗！', '趁现在，赶快整理一下研究笔记…', '嗯——！好久没出来透气了。', '湿度上升，嗯…要不要再加一组实验呢？', '告诉你一个小秘密，我对谁都没有讲过', '「生物炼金」的研究，终于有突破了。', '	这次旅行，我又收集到了很多研究材料，谢谢你，我会好好利用的。'
        ],
        war: [
            '吸附力测试。', '陆叁零捌式风单元！', '确认…安全距离！', '超扩散态！', '柒伍式超级风模块！', '无相之风…拟造！', '有点，超出预想…', '不痛不痛，不痛的…', '研究…又失败了。', '还需要…调整。', '该…睡一会儿了。', '不应该啊…', '眼镜会碎掉的！'
        ]
    },
    '诺艾尔': {
        peace: [
            '只要你需要我，我随时都会出现在你的身边。', '听见了吗？是风神的声音。每到我心烦意乱的时候，听见风声就能平静下来。', '这就是…新的力量？谢谢你，这样我就能帮到更多人了。', '还不能满足，在成为正式的西风骑士之前，我都要加倍努力。'
        ],
        war: [
            '岩石的重量，令人安心。', '一定要干净利落。', '交给我吧。', '该打扫战场了。', '我会注意骑士的风度。', '我会注意女仆的礼仪。', '应该赶得上', '还有人需要帮忙。', '心满意足。', '没关系，轻伤而已。', '唔，衣服都弄脏了…', '我不会退缩的。', '让骑士团…蒙羞了…', '	我还想…保护大家…', '再见了…主人…', '唔…失态了。'
        ]
    },
    '行秋': {
        peace: [
            '「有时明月无人夜，独向昭潭制恶龙。」', '「衣裓贮文章，自言学雕虫。」', '正所谓「偷得浮生半日闲」，哈哈。', '晴了就好，不然藏书会生霉的。', '明天我也在老地方。只要你不中途迷了路，就准能找得到我。', '阁下近来可好？如果闲来无事，可以来「万文集舍」转转。', '咳，咳咳。恭祝你福寿与天齐，庆贺你生辰快乐。', '如果没有能力，那我心中的那个字，可能也就停在纸面上了吧。'
        ],
        war: [
            '雨线难画。', '裁————！', '断！', '古华神秘。', '织诗成锦。', '裁雨留虹。', '形随神至。', '该行动了。', '计划有变。', '「请从绝处，读我侠义。」', '承蒙…赐教…', '灯华易散…我是知道的。', '失手了…', '不妨事。', '大意了。'
        ]
    },
    '七七': {
        peace: [
            '我是七七，是个僵尸…啊，还要说什么来着。', '早上了吗？今天要做的是…我看看笔记', '	…忘记帮白先生分拣药材了。', '晚上好，今天…我做了什么来着…', '想去凉快点的地方。', '又忘记带伞了。', '想堆雪人…可以陪我吗？', '今天不该出门的。', '凉凉的，很舒服。', '你问我吗…？对不起，我不记得了…', '唔，听起来像老古董…'
        ],
        war: [
            '流转不息。', '生生不绝', '去。', '起。', '听诏，宣此诰命。', '真名，度厄真君。', '玉签，仙法开匣。', '要更快一点吗？', '痛。', '啊——', '要活下去…', '还会…被封印吗…', '好冷…', '不要…', '没感觉…', '居然…'
        ]
    },
    '莫娜': {
        peace: [
            '这么大的雨…不仅看不见星光，连水占盘都模糊了。', '这些落雷…究竟是从哪个星空降下的呢？', '你不是这个世界的人', '你的意思是…想要闲聊？', '命中当如此，我早已预知到了。', '虚假之天，星空下的命运早已注定。', '水中之影，涟漪中窥见启明星升起。', '…再进一步，就能找到世界的真实了吗？'
        ],
        war: [
            '水中幻愿。', '…命运的虚影。', '命运，倒映水中。', '命运，在此显现。', '命定于此。', '无法判断…', '天命既定！', '这样更能看清星空了…', '讨厌的命运…', '还没…推算到这！', '无法违抗的…命运…', '推算结束了…', '烦人。'
        ]
    },
    '菲谢尔': {
        peace: [
            '我即断罪之皇女，真名为菲谢尔', '我即断罪之皇女，真名为菲谢尔', '不知在遥远彼方的扈从…', '奥兹，我之眷属啊…', '你的深眠将平安无梦'
        ],
        war: [
            '以断罪之名！', '现身吧，奥兹！', '回应我吧！', '奥兹：又来了…', '黑之翼，屏断昼夜——', '至夜幻现！', '影之鸦，渴求幽夜——', '奥兹：一如小姐所愿！', '奥兹：至夜幻现！', '皇女的命运，不应该在此完结…！', '我将再度降临…呜…', '不敬之徒', '这个世界，也容不得本皇女吗…'
        ]
    },
    '香菱': {
        peace: [
            '嗯，闲着也是闲着，还不如一起找找食材去！', '嗯…我不太喜欢雨天。', '我想想…今天有没有晒衣服出去…', '走走走，我带你去找松茸！', '来的正好！一起去补充点食材吧？', '呼哇~！好爽！全身上下都充满了力量！', '有这种力量的话…终于可以…不好，口水要流下来了！', '大师父教我的枪法，很厉害吧？', '烤鸽子肉，来两串？哎呀~尝尝嘛'
        ],
        war: [
            '锅巴，喷火！', '热和热和嘛。', '开锅了开锅了！', '嘿…哈！', '讲不通，就打扁咯！', '见识下师父的枪法！', '跑起来跑起来！', '哎呀，疼疼疼…', '呜，今天的食材好凶啊。', '搞砸了呢…', '突然…好渴啊…', '救命啊，食材打人啦！'
        ]
    },
    '班尼特': {
        peace: [
            '这就是你的冒险团吗？真好啊…又热闹，又有人情味。', '不如在周围找找看吧，说不定有宝藏呢！', '早上好！我们今天去哪儿冒险啊？', '这样距离你就又近了一步，我会继续努力的！', '所有力量都提升了！除了运气，哈哈。', '我什么都喜欢，但最喜欢的还是冒险！'
        ],
        war: [
            '哈——', '烧起来吧！', '上天去吧！', '喝啊！', '炸飞你们！', '都闪开！', '我来保护大家！', '该总攻击了！', '有大家在身边，伤口就不会痛！', '冒险、冒险！', '好，出发！', '是货真价实的宝藏！', '简直是奇迹！', '别担心…我坚持得住。', '绝地反击？这个我熟，让我来吧。', '不出意料的…坏运气…', '没能突破…厄运的封锁…', '痛死了。'
        ]
    },
    '北斗': {
        peace: [
            '想切磋的话，我随时奉陪。', '啊——干完活，喝口酒。真畅快。', '喂，打雷而已。在海上不用怕，在陆地上，就更不用怕了。', '这天气，很适合出航啊。', '注意扬起来的风沙，别揉眼睛。', '哟，早。我准备出发了，一起来？', '这时间过得可真快。去吧，一帆风顺', '航海准备，兄弟们，各就各位，全新的冒险要开始了！', '痛快！又变强了不少！', '好样的，有你这种得力的兄弟，是我北斗的荣光！我也不能让你小瞧了啊。', '这满载而归的滋味，开瓶美酒来庆祝吧！'
        ],
        war: [
            '闪开！', '哈！', '悉数奉还！', '接下吧！', '——喝啊！', '这是斩灭「海山」的力量！', '给我瞧好了！', '化作焦炭吧！', '哟，真让人开心。', '还没完呢！', '哼，我来精神了。', '我绝不屈服。', '糟透了', '兄弟们…先…撤…', '全员…归航…', '区区小伤。'
        ]
    },
    '安柏': {
        peace: [
            '侦察骑士安柏，前来报到！', '好想跑一会儿步呀', '下雨了…蝴蝶结会淋湿的', '下雨了啊…视野会有影响，要小心哦。', '唔哇~天气真好。', '嗯…要是风大点就好了。', '真舒服呀…', '早上好哟！要不要一起晨跑？', '天黑了，要我点个火把吗？', '蒙德城的飞行冠军，就是我啦！', '就算是你，比赛我也不会放水！', '哇！像乘着风一样轻快~', '现在的速度，没有人能追得上了吧！'
        ],
        war: [
            '靠你咯。', '兔兔伯爵，出击！', '哼哼~哼哼哼~', '百发百中！', '箭如…雨下！', '你没有退路了！', '跑累了…', '好痛…这家伙…', '…我可不会认输！', '交给我吧！', '来比赛吧！'
        ]
    },
    '凯亚': {
        peace: [
            '没想到你也知道忙里偷闲。', '这雨天里，冰冻的力量会更强吧，有趣。', '怎么，你怕冷？', '呼…趁着这雪天，跟你讲一个鬼故事吧。', '真是和平啊，可又能持续多久呢？', '享受这一天吧。', '你该不会怕黑吧？哦？那我…可找到新素材了。', '这就要走了吗。那就下回见了，别让我等太久啊。', '哦？代理团长大人，你可要多多支持她。', '嚯，你也有两下子嘛。', '你好像一直都很照顾我嘛。谢啦。', '力量又增强了啊…我说，你那是什么眼神，怎么感觉比我还兴奋。'
        ],
        war: [
            '老实点！', '冻结吧！', '这个如何？', '小心着凉。', '抱歉哦。', '真是急性子啊你。', '呼，哈哈。', '起风了。', '运气还不错！', '挺有趣的。', '哈哈，真有乐子。', '看来该认真了。', '似乎变得无聊了…', '麻烦的家伙…', '太难看了…', '还没尽…兴…'
        ]
    },
    '琴': {
        peace: [
            '「蒲公英骑士」，琴，申请入队', '行动起来吧，我们不该在这里停留。', '骑士团的大家…有没有认真工作呢？', '走吧，前往下一个目标！', '这样的天气，正适合行动。', '舒适的天气。', '一日之计在于晨', '好，现在开始处理任务吧。', '我以此剑起誓，必将胜利献给你', '丽莎，有她在的话，我会安心很多。', '蒲公英，蒲公英，跟风一起，到远方去吧。', '优秀的骑士不能挑食。', '只要风不停歇，我就不会停下脚步。', '我做得还不够好。自从与你相遇，一直承蒙你的关照。这份感激…'
        ],
        war: [
            '一决胜负！', '…哈！', '…散！', '风，回应我吧。', '以剑为誓！', '风之神，请指引我们。', '我，没事…！', '还有同伴…需要保护…', '还不能放弃…', '蒙德…', '个人的力量是有极限的…', '我…还不够称职…', '这点伤而已！'
        ]
    },
    '丽莎': {
        peace: [
            '啊…早安，琴。嗯？不好意思，我看错了。', '午休时间到了…', '你还不睡吗？我已经困了呢…', '该不会想让我加班吧…那可不好哦。', '锻炼的机会，应该多留给新人，不是吗？', '芭芭拉的歌，你听过么？'
        ],
        war: [
            '哼哼。', '该电一电了。', '别逃哟。', '…Blitz！', '这是…惩罚哦！', '…呵呵~', '酥酥麻麻的哟。', '快点投降吧。', '可别上瘾喔。', '有你的嘛。', '有点生疏了呀…', '哎呀，手套要破了呢。', '出门好累…', '看来我大意了呢…', '不要那么粗暴。', '让姐姐帮帮你吧。'
        ]
    },
    '芭芭拉': {
        peace: [
            '再这样站下去，会…想睡觉的…', '这样淋着不要紧吗？会感冒的吧？', '欸！是雪花欸！冰冰凉凉的~！', '放心，我不会被吹走的！', '早安~今天也要加油呀。', '辛苦了！请好好休息吧。', '是大家脸上的笑容，一直在支持我。', '我不太喜欢苦的东西，特别是…苦瓜。', '芭芭拉的舞步…治愈力UP！', '谢谢你的支持~啊，不好，好像有点太激动了…心脏怦怦跳个不停。'
        ],
        war: [
            '我会保护大家！', '打起精神来哟！', '演唱，开始！', '♪哼哼~哼哼哼~', '准备好了吗~', '大家加油喔！', '芭芭拉，冲呀！', '呼…呼…没问题！', '能跟得上！', '我没关系的！', '大家的声音，听不到呢…', '有点，没力气了…', '姐姐…'
        ]
    },
    '迪卢克': {
        peace: [
            '偶尔悠闲一下，也不错。', '我不用伞，你随意。', '想试试隐藏菜单吗？', '夜晚到了。', '寒暄就免了。昨夜一切平安就好。', '凯亚吗…那个男人说的话，只能信一半。', '力量增强了…虽然还不够，但终归是在向前方探索。', '为了达成目标，力量是必须的。'
        ],
        war: [
            '呵。', '哈。', '在此——宣判！', '火焰——烧尽。', '审判——喝啊！', '哼，就当是聚沙成塔。', '还不赖。', '一点一滴地积累吧。', '你会付出代价。', '败者…没有借口…', '计划…出错了吗…', '要熄灭了吗…', '可恶。'
        ]
    },
    '雷泽': {
        peace: [
            '你的气味…好闻。一起狩猎吧！', '唔，兔子的味道…', '走吗，肚子饿了。', '我去望风，走了叫我。', '怕就快点躲起来。', '避开树，跟我来！', '风…唔…舒服。', '风…嗯…扎扎的，有点疼。', '太阳出来了。狩猎一起去？', '大块吃肉，开心！', '你去睡觉吧，我看月亮', '手臂，更粗了…？', '磨爪子，磨牙，要更强！', '牙齿，爪子，腿。更强，更有力气…保护你！'
        ],
        war: [
            '走开！', '啊！', '嗷！', '别过来！', '杀了你！…', '唔，好难呼吸…', '想回去…', '我的…卢皮卡…', '嘴里，咸的…'
        ]
    },
    '温迪': {
        peace: [
            '早，准备开始新的冒险了吗？', '我还不困哦。要我陪你走走么？', '嗯…想接着听下去的话，送我一个苹果吧。', '动身吧，旅行者。佚失的诗篇，还在等着我们呢。', '等雪积起来…我们来打雪仗吧！', '难得呀，要不要去飞一飞？', '来得正好，旅行者。我想听听，你的愿望是什么？', '来，坐这边。我写了一首新诗哦，就叫它「旅行者之风」吧。', '欸！刚刚发生了什么！'
        ],
        war: [
            '哟呼——', '在这哟。', '留意脚下。', '一起来玩吧。', '别想逃开喔？', '起风咯~', '飞，比跑快吧？', '哎呀，别盯着我打呀。', '等等，这可不好玩！', '啊呀，弦断了…', '稍微睡一下吧…', '好粗鲁哦。'
        ]
    },
};

/**
 * 命名管理器，负责生产不一样的原神角色名字，实在没有则在角色名后加数字，要求每个房间爬的数目最好小于40
 */
class CreepNameManager {
    /**
     * 初始化CreepNameTable名称注册表
     *
     * @param room Room对象
     */
    static init(room) {
        if (!room.memory.creepNameManager) {
            room.memory.creepNameManager = {
                // 所有的名字
                names: Object.keys(nameData),
                // 当前可使用的名字
                index: 0
            };
        }
    }
    /**
     * 注册一个名字，用房间名包装好返回，比如 胡桃 -> E13S14 胡桃
     *
     * @param room Room对象
     */
    static registerName(room) {
        CreepNameManager.init(room);
        const nameManeger = room.memory.creepNameManager;
        const firstIndex = nameManeger.index; // 记下刚开始的序号
        let isNamesEmpty = false; // 标记，判断原神角色名可用是否为空
        let creepName;
        while (Game.creeps[Game.shard.name + room.name + ' ' + nameManeger.names[nameManeger.index]]) {
            nameManeger.index = (nameManeger.index + 1) % nameManeger.names.length;
            // 转回来了说明原神角色名用完了
            if (firstIndex == nameManeger.index) {
                isNamesEmpty = true;
                break;
            }
        }
        if (!isNamesEmpty) {
            creepName = nameManeger.names[nameManeger.index];
            nameManeger.index = (nameManeger.index + 1) % nameManeger.names.length;
        }
        else {
            // 拼一个随机的名字
            while (true) {
                creepName = nameManeger.names[Math.floor(Math.random() * 100) % nameManeger.names.length] + Math.floor(Math.random() * 10);
                if (!Game.creeps[Game.shard.name + room.name + ' ' + creepName])
                    break;
            }
        }
        // 注意返回值已经包装好了房间名
        return Game.shard.name + room.name + ' ' + creepName;
    }
    /**
     * 判断一个名字是否符合原神角色名
     *
     * @param creepName 爬名
     */
    static isYuanshenName(creepName) {
        return creepName in nameData;
    }
    /**
     * 获取台词数组
     *
     * @param creepName 爬名
     * @param type 台词类型：daily or war
     */
    static getLexicon(creepName, type) {
        return nameData[creepName][type];
    }
}

/* 爬虫原型拓展   --功能  --功能 */
class CreepFunctionExtension extends Creep {
    /**
     *
     * working状态
     */
    workstate(rType = RESOURCE_ENERGY, ratio = 1) {
        if (!this.memory.working)
            this.memory.working = false;
        if (this.memory.working && this.store[rType] == 0) {
            this.memory.working = false;
        }
        if (!this.memory.working && (this.store.getFreeCapacity() == 0 || (ratio != 1 && this.store.getUsedCapacity(rType) >= this.store.getCapacity(rType) * ratio))) {
            this.memory.working = true;
        }
    }
    harvest_(source_) {
        if (!this.pos.isNearTo(source_)) {
            this.goTo(source_.pos, 1);
            this.memory.standed = false;
        }
        else {
            this.harvest(source_);
            this.memory.standed = true;
        }
    }
    transfer_(distination, rType = RESOURCE_ENERGY, ops) {
        if (this.transfer(distination, rType) == ERR_NOT_IN_RANGE) {
            this.goTo(distination.pos, 1, ops);
        }
    }
    upgrade_(ops) {
        if (this.room.controller) {
            if (this.upgradeController(this.room.controller) == ERR_NOT_IN_RANGE) {
                this.goTo(this.room.controller.pos, 3, ops ? ops : 500);
                this.memory.standed = false;
            }
            else
                this.memory.standed = true;
        }
    }
    // 考虑到建筑和修复有可能造成堵虫，所以解除钉扎状态
    build_(distination) {
        if (this.build(distination) == ERR_NOT_IN_RANGE) {
            this.goTo(distination.pos, 1);
            this.memory.standed = false;
        }
        else
            this.memory.standed = true;
    }
    repair_(distination, ops = null) {
        let repair_s = this.repair(distination);
        if (repair_s == ERR_NOT_IN_RANGE) {
            this.goTo(distination.pos, 1, ops);
            this.memory.standed = false;
        }
        else
            this.memory.standed = true;
    }
    withdraw_(distination, rType = RESOURCE_ENERGY, range = 1) {
        if (this.withdraw(distination, rType) == ERR_NOT_IN_RANGE) {
            this.goTo(distination.pos, 1);
        }
        this.memory.standed = false;
    }
    // 确认是否boost了,并进行相应Boost
    BoostCheck(boostBody, state = true) {
        if (this.memory.boostState && state)
            return true;
        for (var body in this.memory.boostData) {
            if (!isInArray(boostBody, body))
                continue;
            if (!this.memory.boostData[body].boosted) {
                var tempID;
                var thisRoomMisson = Game.rooms[this.memory.belong].GainMission(this.memory.MissionData.id);
                if (!thisRoomMisson)
                    return false;
                LoopB: for (var j in thisRoomMisson.LabBind) {
                    if (BoostedPartData[thisRoomMisson.LabBind[j]] && body == BoostedPartData[thisRoomMisson.LabBind[j]]) {
                        tempID = j;
                        break LoopB;
                    }
                }
                if (!tempID)
                    continue;
                var disLab = Game.getObjectById(tempID);
                if (!disLab)
                    continue;
                // 计算body部件
                let s = 0;
                for (var b of this.body) {
                    if (b.type == body)
                        s++;
                }
                if (!disLab.mineralType)
                    return false;
                if (!this.pos.isNearTo(disLab))
                    this.goTo(disLab.pos, 1);
                else {
                    for (var i of this.body) {
                        if (i.type == body && i.boost != thisRoomMisson.LabBind[tempID]) {
                            disLab.boostCreep(this);
                            return false;
                        }
                    }
                    this.memory.boostData[body] = { boosted: true, num: s, type: thisRoomMisson.LabBind[tempID] };
                }
                return false;
            }
        }
        this.memory.boostState = true;
        return true;
    }
    // 召唤所有房间内的防御塔治疗/攻击 自己/爬虫 [不一定成功]
    optTower(otype, creep, boolean = false) {
        var _a, _b;
        if ((this.room.name != this.memory.belong || Game.shard.name != this.memory.shard) && !boolean)
            return;
        if (((_b = (_a = Game.rooms[this.room.name].memory.StructureIdData) === null || _a === void 0 ? void 0 : _a.AtowerID) === null || _b === void 0 ? void 0 : _b.length) < 1)
            return;
        for (var i of Game.rooms[this.room.name].memory.StructureIdData.AtowerID) {
            let tower_ = Game.getObjectById(i);
            if (!tower_)
                continue;
            if (otype == 'heal') {
                tower_.heal(creep);
            }
            else {
                tower_.attack(creep);
            }
        }
    }
    isInDefend(creep) {
        for (var i in Game.rooms[this.memory.belong].memory.enemy) {
            for (var id of Game.rooms[this.memory.belong].memory.enemy[i])
                if (creep.id == id)
                    return true;
        }
        return false;
    }
    // 寻找数组里距离自己最近的爬虫 hurt为true则去除没有攻击部件的爬
    closestCreep(creep, hurt) {
        if (creep.length <= 0)
            return null;
        let result = creep[0];
        // 计算距离
        for (var i of creep) {
            // 距离
            if (hurt) {
                if (!i.getActiveBodyparts('attack') && !i.getActiveBodyparts('ranged_attack'))
                    continue;
            }
            let distance0 = Math.max(Math.abs(this.pos.x - result.pos.x), Math.abs(this.pos.y - result.pos.y));
            let distance1 = Math.max(Math.abs(this.pos.x - i.pos.x), Math.abs(this.pos.y - i.pos.y));
            if (distance1 < distance0)
                result = i;
        }
        return result;
    }
    hostileCreep_atk(nearCreep) {
        let all_atk = 0;
        for (let i in nearCreep) {
            var creeps_hostile = nearCreep[i];
            for (let boost_i in creeps_hostile.body) {
                let body_data = creeps_hostile.body[boost_i];
                switch (body_data.type) {
                    case 'attack':
                    case 'ranged_attack':
                        all_atk += this.attack_number(body_data.type, body_data.boost);
                        break;
                }
            }
        }
        return all_atk;
    }
    attack_number(type, boost) {
        let _boost_attack = {
            'UH': 1,
            'KO': 1,
            'LO': 1,
            'UH2O': 2,
            'KHO2': 2,
            'LHO2': 2,
            'XUH2O': 3,
            'XKHO2': 3,
            'XLHO2': 3,
        };
        let _x = 1;
        if (_boost_attack[boost]) {
            _x += _boost_attack[boost];
        }
        let _number = 0;
        switch (type) {
            case 'attack':
                _number = _x * 30;
                break;
            case 'ranged_attack':
                _number = _x * 10;
                break;
            case 'heal':
                _number = _x * 12;
                break;
        }
        return _number;
    }
    SearchHostilecreeps(range = 1) {
        if (!global.HostileCreepsData)
            return null;
        if (!global.HostileCreepsData[this.room.name])
            return null;
        let creeps_list = global.HostileCreepsData[this.room.name];
        for (let creeps of creeps_list) {
            if (this.pos.inRangeTo(creeps, range)) {
                return creeps;
            }
        }
        return null;
    }
    /**
    * 统计爬的某类身体部件数目并缓存
    */
    countBodyPart(bodyType) {
        if (!this.memory.bodyPartCount)
            this.memory.bodyPartCount = {};
        if (!this.memory.bodyPartCount[bodyType]) {
            this.memory.bodyPartCount[bodyType] = this.getActiveBodyparts(bodyType);
        }
        return this.memory.bodyPartCount[bodyType];
    }
    /**
     * 说话，原神中的台词，所有人可见
     *
     * @param type 说话类型，日常语音和战时语音 daily or war
     */
    sayHi(type = 'peace') {
        // 第一次说话
        if (!this.memory.sayHi) {
            this.memory.sayHi = {
                // 上一次说话所处的状态
                state: type,
                // 上一次所说的话
                saying: ''
            };
        }
        // 判断是否可以说原神台词
        if (this.memory.sayHi.canSay === undefined) {
            const nameParts = this.name.split(' ');
            // 不符合命名格式
            if (nameParts.length <= 1) {
                this.memory.sayHi.canSay = false;
                return;
            }
            // 获取原神角色名
            const yuanshenName = nameParts[1];
            if (!CreepNameManager.isYuanshenName(yuanshenName)) {
                this.memory.sayHi.canSay = false;
                return;
            }
            this.memory.sayHi.yuanshenName = yuanshenName;
            this.memory.sayHi.canSay = true;
        }
        if (!this.memory.sayHi.canSay)
            return;
        const lexicon = CreepNameManager.getLexicon(this.memory.sayHi.yuanshenName, type);
        let index;
        let last; // 标记是否是继续说上一次没说完的话
        if (this.memory.sayHi.lastIndex && this.memory.sayHi.state == type) {
            index = this.memory.sayHi.lastIndex;
            last = true;
        }
        else {
            index = Math.floor(Math.random() * lexicon.length);
            last = false;
        }
        this.memory.sayHi.state = type;
        let setence = lexicon[index];
        if (!setence) {
            delete this.memory.sayHi.lastIndex;
            delete this.memory.sayHi.saying;
            return;
        }
        if (last) {
            if (this.memory.sayHi.saying) {
                setence = setence.slice(setence.lastIndexOf(this.memory.sayHi.saying) + this.memory.sayHi.saying.length);
                // 去除首部特殊符号
                if (setence.length && ['。', '？', '…', '，', '！', '~', '——'].includes(setence[0])) {
                    setence = setence.slice(1);
                }
            }
            else {
                delete this.memory.sayHi.lastIndex;
                return;
            }
        }
        const words = setence.split(/[。？…，！~——]/);
        if (words.length <= 1) {
            if (setence.length) {
                this.say(setence, true);
                this.memory.sayHi.saying = setence;
            }
            else {
                delete this.memory.sayHi.lastIndex;
                delete this.memory.sayHi.saying;
            }
            return;
        }
        let len = words[0].length;
        let ii = 1;
        // +1 是因为要计入标点符号
        while (ii < words.length && len + words[ii].length + 1 <= 10) {
            len += words[ii++].length + 1;
        }
        ii--;
        while (ii && !words[ii])
            ii--;
        if (ii >= words.length) {
            if (setence.length) {
                this.say(setence, true);
            }
            delete this.memory.sayHi.lastIndex;
            delete this.memory.sayHi.saying;
        }
        else {
            const w = setence.slice(0, setence.indexOf(words[ii]) + words[ii].length);
            if (w.length) {
                this.say(w, true);
                this.memory.sayHi.saying = w;
            }
            this.memory.sayHi.lastIndex = index;
        }
    }
}

/* 爬虫原型拓展   --任务  --任务基础 */
class CreepMissonBaseExtension extends Creep {
    ManageMisson() {
        if (this.spawning)
            return;
        if (!this.memory.MissionData)
            this.memory.MissionData = {};
        /* 生命低于10就将资源上交 */
        if (isInArray(['transport', 'manage'], this.memory.role)) {
            if (Game.time % 5 == 0)
                this.memory.standed = true;
            else
                this.memory.standed = false;
            if (this.ticksToLive < 10) {
                let storage_ = Game.rooms[this.memory.belong].storage;
                if (!storage_)
                    return;
                if (this.store.getUsedCapacity() > 0) {
                    for (let i in this.store) {
                        this.transfer_(storage_, i);
                        return;
                    }
                }
                return;
            }
        }
        if (Object.keys(this.memory.MissionData).length <= 0) {
            let belongRoom = Game.rooms[this.memory.belong];
            if (this.memory.taskRB) {
                let task_ = belongRoom.GainMission(this.memory.taskRB);
                if (task_) {
                    task_.CreepBind[this.memory.role].bind.push(this.name);
                    this.memory.MissionData.id = task_.id; // 任务id
                    this.memory.MissionData.name = task_.name; // 任务名
                    this.memory.MissionData.Data = task_.Data ? task_.Data : {}; // 任务数据传输
                    task_.processing = true;
                    return;
                }
            }
            /* 每任务的情况下考虑领任务 */
            if (!belongRoom.memory.Misson['Creep'])
                belongRoom.memory.Misson['Creep'] = [];
            let taskList = belongRoom.memory.Misson['Creep'];
            let thisTaskList = [];
            if (taskList.length > 0) {
                for (let Stask of taskList) {
                    if (Stask.CreepBind && isInArray(Object.keys(Stask.CreepBind), this.memory.role))
                        thisTaskList.push(Stask);
                }
            }
            if (thisTaskList.length <= 0) {
                /* 没任务就处理剩余资源 */
                if (this.room.name != this.memory.belong)
                    return;
                let st = this.store;
                if (!st)
                    return;
                let storage_ = belongRoom.storage;
                if (!storage_)
                    return;
                for (let i of Object.keys(st)) {
                    this.say("🛒");
                    if (this.transfer(storage_, i) == ERR_NOT_IN_RANGE)
                        this.goTo(storage_.pos, 1);
                    return;
                }
                return;
            }
            else {
                /* 还没有绑定的任务，就等待接取任务 */
                LoopBind: for (var t of thisTaskList) {
                    if (t.CreepBind && t.CreepBind[this.memory.role] && t.CreepBind[this.memory.role].bind.length < t.CreepBind[this.memory.role].num) {
                        /* 绑定任务了就输入任务数据 */
                        t.processing = true; // 领取任务后，任务开始计时
                        t.CreepBind[this.memory.role].bind.push(this.name);
                        this.memory.MissionData.id = t.id; // 任务id
                        this.memory.MissionData.name = t.name; // 任务名
                        this.memory.MissionData.Data = t.Data ? t.Data : {}; // 任务数据传输
                        // this.memory.MissionData.Sata = t.Sata?t.Sata:{}
                        break LoopBind;
                    }
                }
                if (Object.keys(this.memory.MissionData).length <= 0)
                    this.say("💤");
                return;
            }
        }
        else {
            switch (this.memory.MissionData.name) {
                case '虫卵填充': {
                    this.handle_feed();
                    break;
                }
                case '物流运输': {
                    this.handle_carry();
                    break;
                }
                case '位面运输': {
                    this.handle_Carryshard();
                    break;
                }
                case '拾荒者': {
                    this.handle_carrygleaner();
                    break;
                }
                case '外矿偷取': {
                    this.handle_carrymine();
                    break;
                }
                case '墙体维护': {
                    this.handle_repair();
                    break;
                }
                case 'C计划': {
                    this.handle_planC();
                    break;
                }
                case '黄球拆迁': {
                    this.handle_dismantle();
                    break;
                }
                case '急速冲级': {
                    this.handle_quickRush();
                    break;
                }
                case '扩张援建': {
                    this.handle_expand();
                    break;
                }
                case '紧急支援': {
                    this.handle_support();
                    break;
                }
                case '控制攻击': {
                    this.handle_control();
                    break;
                }
                case '紧急援建': {
                    this.handle_helpBuild();
                    break;
                }
                case '紧急升级': {
                    this.handle_helpUpgrade();
                    break;
                }
                case '紧急墙体': {
                    this.handle_helpRepair();
                    break;
                }
                case '房间签名': {
                    this.handle_sign();
                    break;
                }
                case '攻防一体': {
                    this.handle_aio();
                    break;
                }
                case '踩工地': {
                    this.handle_cconstruction();
                    break;
                }
                case '原矿开采': {
                    this.handle_mineral();
                    break;
                }
                case '外矿开采': {
                    this.handle_outmine();
                    break;
                }
                case 'power采集': {
                    this.handle_power();
                    break;
                }
                case 'deposit采集': {
                    this.handle_deposit();
                    break;
                }
                case '红球防御': {
                    this.handle_defend_attack();
                    break;
                }
                case '蓝球防御': {
                    this.handle_defend_range();
                    break;
                }
                case '双人防御': {
                    this.handle_defend_double();
                    break;
                }
                case '四人小队': {
                    this.handle_task_squard();
                    break;
                }
                case '双人小队': {
                    this.handle_double();
                    break;
                }
                case '智能哨兵': {
                    this.handle_aisentry();
                    break;
                }
            }
        }
    }
}

/* 爬虫原型拓展   --任务  --搬运工任务 */
class CreepMissonTransportExtension extends Creep {
    handle_feed() {
        // if (!this.room.memory.StructureIdData.storageID) return
        // var storage_ = Game.getObjectById(this.room.memory.StructureIdData.storageID as string) as StructureStorage
        if (!this.room.storage && !this.room.terminal)
            return;
        this.workstate('energy');
        if (Object.keys(this.store).length > 0) {
            for (var r in this.store) {
                if (r != 'energy') {
                    this.say("🚽");
                    /* 如果是自己的房间，则优先扔到最近的storage去 */
                    if (this.room.name == this.memory.belong) {
                        if (!this.room.storage)
                            return;
                        if (this.room.storage.store.getFreeCapacity() > this.store.getUsedCapacity()) {
                            this.transfer_(this.room.storage, r);
                        }
                        else
                            return;
                    }
                    return;
                }
            }
        }
        // console.log('资源搬运-3')
        if (this.memory.working) {
            // console.log('资源搬运-5')
            this.say("🍉");
            let extensions_ = null;
            if (!this.memory.Extensions_id) {
                var extensions = this.pos.findClosestByRange(FIND_MY_STRUCTURES, {
                    filter: (structure) => {
                        return (structure.structureType == 'spawn' || structure.structureType == 'extension') && structure.store.getFreeCapacity('energy') > 0;
                    }
                });
                if (extensions) {
                    extensions_ = extensions;
                    this.memory.Extensions_id = extensions.id;
                }
                else {
                    /* 完成就删除任务和自己的记忆 */
                    Game.rooms[this.memory.belong].DeleteMission(this.memory.MissionData.id);
                    this.memory.MissionData = {};
                }
            }
            if (this.memory.Extensions_id) {
                if (!extensions_) {
                    extensions_ = Game.getObjectById(this.memory.Extensions_id);
                }
                if (!extensions_) {
                    this.memory.Extensions_id = null;
                }
                if (extensions_.store.getFreeCapacity(RESOURCE_ENERGY) < 1) {
                    this.memory.Extensions_id = null;
                }
                let transfer = this.transfer(extensions_, RESOURCE_ENERGY);
                switch (transfer) {
                    case ERR_NOT_IN_RANGE:
                        this.goTo(extensions_.pos, 1, 200, 1);
                        break;
                    case OK:
                        this.memory.Extensions_id = null;
                        break;
                }
            }
        }
        else {
            // 优先提取storage里的能量 不够提取terminal里的
            if (this.room.storage) {
                if (this.room.storage.store['energy'] >= this.store.getCapacity()) {
                    this.withdraw_(this.room.storage, 'energy');
                    return;
                }
            }
            if (this.room.terminal) {
                if (this.room.terminal.store['energy'] >= this.store.getCapacity()) {
                    this.withdraw_(this.room.terminal, 'energy');
                }
            }
        }
    }
    /*位面物资运输*/
    handle_Carryshard() {
        let missionData = this.memory.MissionData;
        let id = missionData.id;
        let data = missionData.Data;
        if (this.room.name == this.memory.belong && this.memory.shard == Game.shard.name && !this.memory.working) {
            if (this.room.name == this.memory.belong) {
                switch (missionData.Data.level) {
                    case 'T3':
                    case 'T2':
                    case 'T1':
                    case 'T11':
                        if (!this.BoostCheck(['move', 'carry']))
                            return;
                        break;
                    case 'T9':
                        if (!this.BoostCheck(['move', 'carry', 'heal', 'tough']))
                            return;
                        break;
                }
            }
            if (this.room.storage.store.getUsedCapacity(data.rType) <= 0) {
                /*发送一个邮件提醒，任务已经完成*/
                Game.notify(`[Carry] 位面搬运任务${this.memory.belong}-${data.rType}已完成`);
                Game.rooms[this.memory.belong].DeleteMission(id);
                if (this.store.getUsedCapacity() == 0) {
                    this.suicide();
                }
                if (!this.memory.working && this.store.getUsedCapacity(data.rType) > 0) {
                    this.memory.working = true;
                }
            }
            this.withdraw_(this.room.storage, data.rType);
            this.workstate(data.rType);
            return;
        }
        if (this.memory.working) {
            // console.log('完成取货准备搬运')
            switch (missionData.Data.level) {
                case 'T9':
                    this.heal(this);
                    break;
            }
            if ((this.room.name != data.disRoom || Game.shard.name != data.shard)) {
                this.arriveTo(new RoomPosition(24, 24, data.disRoom), 23, data.shard, data.shardData ? data.shardData : null);
            }
            else {
                let storage_ = Game.rooms[data.disRoom].storage;
                if (storage_) {
                    if (storage_) {
                        let transfer = this.transfer(storage_, data.rType);
                        switch (transfer) {
                            case ERR_NOT_IN_RANGE:
                                this.goTo(storage_.pos, 1);
                                break;
                        }
                        this.workstate(data.rType);
                    }
                }
                else {
                    /*搜索spawn*/
                    if (this.pos.inRangeTo(this.room.controller, 3)) {
                        var find_dropped_resources = this.room.find(FIND_DROPPED_RESOURCES, {
                            filter: (res) => {
                                return res.amount > 1000 && res.resourceType == 'energy';
                            }
                        });
                        if (find_dropped_resources.length < 1) {
                            this.suicide();
                        }
                    }
                    else {
                        this.goTo(this.room.controller.pos, 1);
                    }
                    // var find_spawn = this.pos.findClosestByRange(FIND_HOSTILE_SPAWNS)
                    // if (!find_spawn) return;
                    // if (this.pos.inRangeTo(find_spawn, 3)) {
                    //     var find_dropped_resources = this.room.find(FIND_DROPPED_RESOURCES, {
                    //         filter: (res) => {
                    //             return res.amount > 1000 && res.resourceType == 'energy'
                    //         }
                    //     })
                    //     if (find_dropped_resources.length < 1) {
                    //         this.suicide();
                    //     }
                    // } else {
                    //     this.goTo(find_spawn.pos, 1)
                    // }
                }
            }
        }
        else {
            console.log('目标闲置操作');
            this.suicide();
        }
    }
    /*拾荒者执行*/
    handle_carrygleaner() {
        let missionData = this.memory.MissionData;
        missionData.id;
        let data = missionData.Data;
        if (this.room.name == this.memory.belong && this.memory.shard == Game.shard.name && !this.memory.boostState) {
            if (this.room.name == this.memory.belong) {
                switch (missionData.Data.level) {
                    case 'T3':
                    case 'T2':
                    case 'T1':
                        if (!this.BoostCheck(['move', 'carry']))
                            return;
                        break;
                    case 'T0':
                        this.memory.boostState = true;
                        break;
                }
                return;
            }
        }
        if (!this.memory.working)
            this.memory.working = false;
        if (this.memory.working && this.store.getUsedCapacity() == 0) {
            this.memory.working = false;
        }
        if (!this.memory.working && (this.store.getFreeCapacity() == 0)) {
            this.memory.working = true;
        }
        if (this.memory.working) {
            if (!Game.rooms[this.memory.belong]) {
                console.log('操作存在异常的情况');
            }
            if (this.memory.belong != this.room.name) {
                this.goTo(Game.rooms[this.memory.belong].storage.pos, 3);
                // this.arriveTo(new RoomPosition(24, 24, this.memory.belong), 23, data.shard, data.shardData ? data.shardData : null)
                return;
            }
            if (data.suicide * 2 > this.ticksToLive && this.store.getUsedCapacity() < 1) {
                this.suicide();
            }
            if (this.hits < this.hitsMax && this.room.memory.state == 'peace' && Game.rooms[this.memory.belong].name == this.room.name) {
                this.optTower('heal', this);
            }
            // if (this.room.storage) {
            //     let transfer = this.transfer(this.room.storage, data.rType)
            //     switch (transfer) {
            //         case ERR_NOT_IN_RANGE:
            //             this.goTo(this.room.storage.pos, 1)
            //             break;
            //     }
            // } else if (this.room.terminal) {
            //     let transfer = this.transfer(this.room.terminal, data.rType)
            //     switch (transfer) {
            //         case ERR_NOT_IN_RANGE:
            //             this.goTo(this.room.terminal.pos, 1)
            //             break;
            //     }
            // }
            if (Object.keys(this.store).length > 0) {
                for (var r in this.store) {
                    this.say("🚽");
                    /* 如果是自己的房间，则优先扔到最近的storage去 */
                    if (this.room.name == this.memory.belong) {
                        if (!this.room.storage)
                            return;
                        if (this.room.storage.store.getFreeCapacity() > this.store.getUsedCapacity()) {
                            this.transfer_(this.room.storage, r);
                        }
                        else
                            return;
                    }
                    return;
                }
            }
        }
        else {
            if (data.suicide > this.ticksToLive && this.store.getUsedCapacity() > 0) {
                this.memory.working = true;
            }
            if (data.disRoom != this.room.name) {
                this.goTo(new RoomPosition(24, 24, data.disRoom), 23);
                // this.arriveTo(new RoomPosition(24, 24, data.disRoom), 23, data.shard, data.shardData ? data.shardData : null)
                return;
            }
            var find_dropped_resources = this.pos.findClosestByRange(FIND_DROPPED_RESOURCES, {
                filter: (res) => {
                    return res.amount > 1000;
                }
            });
            if (!find_dropped_resources) {
                var find_dropped_resources = this.pos.findClosestByRange(FIND_DROPPED_RESOURCES, {
                    filter: (res) => {
                        return res.amount > 0;
                    }
                });
            }
            if (find_dropped_resources) {
                if (!this.pos.isNearTo(find_dropped_resources))
                    this.goTo(find_dropped_resources.pos, 1);
                else
                    this.pickup(find_dropped_resources);
                return;
            }
            /*搜索墓碑*/
            var find_tombstones = null;
            find_tombstones = this.pos.findClosestByRange(FIND_TOMBSTONES, {
                filter: (structure) => {
                    return structure.store.getUsedCapacity() > 0;
                }
            });
            /*搜索废墟*/
            if (!find_tombstones) {
                find_tombstones = this.pos.findClosestByRange(FIND_RUINS, {
                    filter: (structure) => {
                        return structure.store.getUsedCapacity() > 0;
                    }
                });
            }
            if (find_tombstones) {
                // console.log('存在目的信息')
                /*进行资源遍历操作*/
                if (!this.pos.isNearTo(find_tombstones)) {
                    this.goTo(find_tombstones.pos, 1);
                    return;
                }
                if (Object.keys(find_tombstones.store).length > 0) {
                    for (var r in find_tombstones.store) {
                        if (find_tombstones.store[r] > 0) {
                            this.withdraw(find_tombstones, r);
                            return;
                        }
                    }
                }
                if (this.withdraw(find_tombstones, RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {
                    this.moveTo(find_tombstones);
                }
                return;
            }
        }
    }
    /*外矿偷取*/
    handle_carrymine() {
        if (!this.memory.notifyWhenAttacked) {
            this.notifyWhenAttacked(false);
            this.memory.notifyWhenAttacked = true;
        }
        let missionData = this.memory.MissionData;
        let data = missionData.Data;
        if (this.getActiveBodyparts('heal') && this.hits < this.hitsMax) {
            this.heal(this);
        }
        if (!this.memory.working)
            this.memory.working = false;
        if (this.memory.working && this.store.getUsedCapacity() == 0) {
            this.memory.working = false;
        }
        if (!this.memory.working && (this.store.getFreeCapacity() < 0.5 * this.store.getCapacity())) {
            this.memory.working = true;
        }
        if (this.memory.working) {
            if (!Game.rooms[this.memory.belong]) {
                console.log('操作存在异常的情况');
            }
            if (this.memory.belong != this.room.name) {
                this.goTo(Game.rooms[this.memory.belong].storage.pos, 3);
                return;
            }
            if (this.hits < this.hitsMax && this.room.memory.state == 'peace' && Game.rooms[this.memory.belong].name == this.room.name) {
                this.optTower('heal', this);
            }
            if (Object.keys(this.store).length > 0) {
                for (var r in this.store) {
                    this.say("💨");
                    /* 如果是自己的房间，则优先扔到最近的storage去 */
                    if (this.room.name == this.memory.belong) {
                        if (!this.room.storage)
                            return;
                        if (this.room.storage.store.getFreeCapacity() > this.store.getUsedCapacity()) {
                            this.transfer_(this.room.storage, r);
                        }
                        else
                            return;
                    }
                    return;
                }
            }
        }
        else {
            if (data.disRoom != this.room.name) {
                this.goTo(new RoomPosition(24, 24, data.disRoom), 23);
                return;
            }
            var container = this.pos.findClosestByRange(FIND_STRUCTURES, {
                filter: (c) => {
                    return c.structureType === STRUCTURE_CONTAINER &&
                        c.store.getUsedCapacity() > 0.5 * this.store.getCapacity();
                }
            });
            if (container) {
                if (!this.pos.isNearTo(container))
                    this.goTo(container.pos, 1);
                else
                    this.withdraw(container, RESOURCE_ENERGY);
                return;
            }
        }
    }
    /* 物资运输任务  已测试 */
    handle_carry() {
        var Data = this.memory.MissionData.Data;
        let belongRoom = Game.rooms[this.memory.belong];
        /* 数据不全拒绝执行任务 */
        if (!Data || Data.num <= 0) {
            belongRoom.DeleteMission(this.memory.MissionData.id);
            return;
        }
        var thisPos = new RoomPosition(Data.targetPosX, Data.targetPosY, Data.targetRoom);
        var disPos = new RoomPosition(Data.sourcePosX, Data.sourcePosY, Data.sourceRoom);
        if (!thisPos || !disPos) {
            belongRoom.DeleteMission(this.memory.MissionData.id);
            return;
        }
        if (Data.rType) {
            this.say(`📦${Data.rType}`);
            /* 指定了资源类型 */
            this.workstate(Data.rType);
            /* 清除杂质 */
            for (var r in this.store) {
                /* 清除杂志 */
                if (r != Data.rType) {
                    this.say("♻️");
                    /* 如果是自己的房间，则优先扔到最近的storage去 */
                    var storage = this.room.storage;
                    if (!storage)
                        return;
                    if (this.room.name == this.memory.belong) {
                        if (storage.store.getFreeCapacity() > this.store.getUsedCapacity(r)) {
                            this.transfer_(storage, r, 200);
                        }
                        else
                            return;
                    }
                    return;
                }
            }
            if (Data.num) {
                /* 如果指定了num-- 任务结束条件：[搬运了指定num] */
                if (this.memory.working) {
                    if (!this.pos.isNearTo(thisPos))
                        this.goTo(thisPos, 1);
                    else {
                        /* 寻找 */
                        var targets = thisPos.GetStructureList(['terminal', 'storage', 'tower', 'powerSpawn', 'container', 'factory', 'nuker', 'lab', 'link', 'extension']);
                        if (targets.length > 0) {
                            var target = targets[0];
                            var capacity = this.store[Data.rType];
                            /* 如果送货正确，就减少房间主任务中的num，num低于0代表任务完成 */
                            if (this.transfer(target, Data.rType) == OK) {
                                var thisMisson = belongRoom.GainMission(this.memory.MissionData.id);
                                if (thisMisson) {
                                    thisMisson.Data.num -= capacity;
                                    if (thisMisson.Data.num <= 0) {
                                        belongRoom.DeleteMission(this.memory.MissionData.id);
                                        return;
                                    }
                                }
                            }
                            else {
                                /* 目标满了、不是正确目标、目标消失了也代表任务完成 */
                                belongRoom.DeleteMission(this.memory.MissionData.id);
                                return;
                            }
                        }
                        else {
                            /*没有建筑的情况下删除任务*/
                            belongRoom.DeleteMission(this.memory.MissionData.id);
                            return;
                        }
                    }
                }
                else {
                    if (!this.pos.isNearTo(disPos)) {
                        if (this.room.name == this.memory.belong)
                            this.goTo(disPos, 1, 200);
                        else
                            this.goTo(disPos, 1);
                    }
                    else {
                        var targets = disPos.GetStructureList(['terminal', 'storage', 'tower', 'powerSpawn', 'container', 'factory', 'nuker', 'lab', 'link', 'extension']);
                        if (targets.length > 0) {
                            var target = targets[0];
                            if ((!target.store || target.store[Data.rType] == 0) && this.store.getUsedCapacity(Data.rType) <= 0) {
                                /* 如果发现没资源了，就取消搬运任务 */
                                belongRoom.DeleteMission(this.memory.MissionData.id);
                                return;
                            }
                            /* 如果已经没资源了 */
                            var thisMisson = belongRoom.GainMission(this.memory.MissionData.id);
                            if (thisMisson.Data.num < this.store.getCapacity() && target.store[Data.rType] && target.store[Data.rType] >= thisMisson.Data.num) {
                                this.withdraw(target, Data.rType, thisMisson.Data.num);
                                this.memory.working = true;
                                return;
                            }
                            if (target.store.getUsedCapacity(Data.rType) < this.store.getUsedCapacity()) {
                                this.withdraw(target, Data.rType);
                                this.memory.working = true;
                                return;
                            }
                            if (this.withdraw(target, Data.rType) == ERR_NOT_ENOUGH_RESOURCES) {
                                this.memory.working = true;
                            }
                        }
                    }
                }
            }
            else {
                /* 未指定数目-- 任务结束条件：[source 空了 或 target 满了] */
                if (this.memory.working) {
                    if (!this.pos.isNearTo(thisPos))
                        this.goTo(thisPos, 1);
                    else {
                        /* 寻找 */
                        var targets = thisPos.GetStructureList(['terminal', 'storage', 'tower', 'powerSpawn', 'container', 'factory', 'nuker', 'lab', 'link', 'extension']);
                        if (targets.length > 0) {
                            var target = targets[0];
                            var capacity = this.store[Data.rType];
                            if (this.transfer(target, Data.rType) != OK) {
                                /* 目标满了、不是正确目标、目标消失了也代表任务完成 */
                                belongRoom.DeleteMission(this.memory.MissionData.id);
                                return;
                            }
                            // 对于类似于防御塔正在使用能量的任务
                            if (target.store.getFreeCapacity() < 50) {
                                belongRoom.DeleteMission(this.memory.MissionData.id);
                                return;
                            }
                        }
                        else {
                            belongRoom.DeleteMission(this.memory.MissionData.id);
                            return;
                        }
                    }
                }
                else {
                    /* 清除杂质 */
                    var storage = this.room.storage;
                    if (storage) {
                        for (var r in this.store) {
                            if (r != Data.rType) {
                                this.say("🚽");
                                /* 如果是自己的房间，则优先扔到最近的storage去 */
                                if (this.room.name == this.memory.belong) {
                                    if (storage.store.getFreeCapacity() > this.store.getUsedCapacity()) {
                                        this.transfer_(storage, r);
                                    }
                                    else
                                        return;
                                }
                                return;
                            }
                        }
                    }
                    /*  */
                    if (!this.pos.isNearTo(disPos))
                        this.goTo(disPos, 1);
                    else {
                        var targets = disPos.GetStructureList(['terminal', 'storage', 'tower', 'powerSpawn', 'container', 'factory', 'nuker', 'lab', 'link', 'extension']);
                        var ruin = disPos.GetRuin();
                        if (targets.length > 0 || ruin) {
                            var target = targets[0];
                            var targetR = ruin;
                            if (target) {
                                if ((!target.store || target.store[Data.rType] == 0) && this.store.getUsedCapacity(Data.rType) == 0) {
                                    /* 如果发现没资源了，就取消搬运任务 */
                                    belongRoom.DeleteMission(this.memory.MissionData.id);
                                    return;
                                }
                                else {
                                    this.withdraw(target, Data.rType);
                                    this.memory.working = true;
                                }
                            }
                            if (targetR) {
                                if (!targetR.store || targetR.store.getUsedCapacity() == 0) {
                                    /* 如果发现没资源了，就取消搬运任务 */
                                    belongRoom.DeleteMission(this.memory.MissionData.id);
                                    return;
                                }
                                for (var t in targetR.store) {
                                    this.withdraw(targetR, t);
                                }
                                return;
                            }
                        }
                    }
                }
            }
        }
        else {
            this.say(`📦`);
            /* 未指定资源类型 */
            /* working状态转换条件 */
            if (!this.memory.working)
                this.memory.working = false;
            if (this.memory.working) {
                if (!this.store || Object.keys(this.store).length <= 0)
                    this.memory.working = false;
            }
            else {
                if (this.store.getFreeCapacity() == 0)
                    this.memory.working = true;
            }
            if (Data.num) {
                /* 不考虑这种类型的任务 */
                belongRoom.DeleteMission(this.memory.MissionData.id);
                return;
            }
            else {
                /* 只考虑这种任务 */
                if (this.memory.working) {
                    if (!this.pos.isNearTo(thisPos))
                        this.goTo(thisPos, 1);
                    else {
                        /* 寻找 */
                        var targets = thisPos.GetStructureList(['terminal', 'storage', 'tower', 'powerSpawn', 'container', 'factory', 'nuker', 'lab', 'link']);
                        if (targets.length > 0) {
                            var target = targets[0];
                            var capacity = this.store[Data.rType];
                            /* 如果送货正确，就减少房间主任务中的num，num低于0代表任务完成 */
                            for (var i in this.store) {
                                if (this.transfer(target, i) != OK) {
                                    /* 目标满了、不是正确目标、目标消失了也代表任务完成 */
                                    belongRoom.DeleteMission(this.memory.MissionData.id);
                                    return;
                                }
                            }
                            if (this.memory.role == 'truck' && target.store.getFreeCapacity() < 40000) {
                                /* 目标满了、不是正确目标、目标消失了也代表任务完成 */
                                belongRoom.DeleteMission(this.memory.MissionData.id);
                                this.suicide();
                            }
                        }
                        else {
                            belongRoom.DeleteMission(this.memory.MissionData.id);
                            return;
                        }
                    }
                }
                else {
                    if (Data.st) {
                        if (this.ticksToLive < Data.st) {
                            this.suicide();
                            return;
                        }
                    }
                    if (this.ticksToLive < 10) {
                        this.suicide();
                        return;
                    }
                    var disPos = new RoomPosition(Data.sourcePosX, Data.sourcePosY, Data.sourceRoom);
                    if (!disPos) {
                        belongRoom.DeleteMission(this.memory.MissionData.id);
                        return;
                    }
                    if (!this.pos.isNearTo(disPos))
                        this.goTo(disPos, 1);
                    else {
                        var targets = disPos.GetStructureList(['terminal', 'storage', 'tower', 'powerSpawn', 'container', 'factory', 'nuker', 'lab', 'link']);
                        var ruin = disPos.GetRuin();
                        if (targets.length > 0 || ruin) {
                            var target = targets[0];
                            var targetR = ruin;
                            if (target) {
                                if (!target.store || target.store.getUsedCapacity() == 0) {
                                    /* 如果发现没资源了，就取消搬运任务 */
                                    belongRoom.DeleteMission(this.memory.MissionData.id);
                                    return;
                                }
                                for (var t in target.store) {
                                    this.withdraw(target, t);
                                }
                                return;
                            }
                            if (targetR) {
                                if (!targetR.store || targetR.store.getUsedCapacity() == 0) {
                                    /* 如果发现没资源了，就取消搬运任务 */
                                    belongRoom.DeleteMission(this.memory.MissionData.id);
                                    return;
                                }
                                for (var t in targetR.store) {
                                    this.withdraw(targetR, t);
                                }
                                return;
                            }
                            this.memory.working = true;
                        }
                        else {
                            var tomb = disPos.lookFor(LOOK_TOMBSTONES)[0];
                            var droppedResource = disPos.lookFor(LOOK_RESOURCES);
                            if (droppedResource.length > 0) {
                                for (var res of droppedResource) {
                                    this.pickup(res);
                                }
                            }
                            else if (tomb && tomb.store.getUsedCapacity() > 0) {
                                for (var t in tomb.store) {
                                    this.withdraw(tomb, t);
                                }
                            }
                            else {
                                belongRoom.DeleteMission(this.memory.MissionData.id);
                                return;
                            }
                            this.memory.working = true;
                        }
                    }
                }
            }
        }
    }
}

/* 爬虫原型拓展   --任务  --任务行为 */
class CreepMissonActionExtension extends Creep {
    // 刷墙
    handle_repair() {
        let missionData = this.memory.MissionData;
        let id = missionData.id;
        let belongRoom = Game.rooms[this.memory.belong];
        let mission = belongRoom.GainMission(id);
        if (!id)
            return;
        let storage_ = belongRoom.storage;
        this.workstate('energy');
        /* boost检查 */
        // var a = Game.cpu.getUsed();
        if (mission.LabBind && !this.memory.boostState) {
            // if (!storage_) return   // 如果是boost的，没有仓库就不刷了
            // console.log('检查boost',this.name)
            // 需要boost检查，必要情况下可以不检查
            let boo = false;
            for (var ids in mission.LabBind) {
                var lab_ = Game.getObjectById(ids);
                if (!lab_ || !lab_.mineralType || lab_.store.getUsedCapacity(lab_.mineralType) < 500)
                    boo = true;
            }
            if (!boo) {
                switch (missionData.Data.level) {
                    case 'T1':
                    case 'T3':
                        if (!this.BoostCheck(['work', 'move', 'carry']))
                            return;
                        break;
                    default:
                        if (!this.BoostCheck(['work']))
                            return;
                        break;
                }
            }
        }
        if (belongRoom && belongRoom.memory.state == 'war') {
            if (this.hitsMax - this.hits > 500)
                this.optTower('heal', this);
        }
        if (this.memory.working) {
            switch (mission.Data.RepairType) {
                case 'global':
                case 'globalrampart':
                case 'globalwall':
                    if (this.memory.targetID) {
                        this.say("🛠️");
                        var target_ = Game.getObjectById(this.memory.targetID);
                        if (!target_) {
                            delete this.memory.targetID;
                            return;
                        }
                        this.repair_(target_);
                        if (this.room.memory.state == 'war') {
                            let hostileCreep = this.pos.findInRange(FIND_HOSTILE_CREEPS, 3, {
                                filter: (creep) => {
                                    return creep.getActiveBodyparts('ranged_attack') > 0;
                                }
                            });
                            if (hostileCreep.length > 0)
                                this.Flee(hostileCreep[0].pos, 4);
                        }
                    }
                    else {
                        if (this.room.memory.state == 'peace') {
                            var construction = this.pos.findClosestByRange(FIND_MY_CONSTRUCTION_SITES);
                            if (construction) {
                                this.build_(construction);
                                return;
                            }
                            if (mission.CreepBind.repair.historynum) { /*和平状态下会进行数量调整*/
                                mission.CreepBind.repair.num = mission.CreepBind.repair.historynum;
                                delete mission.CreepBind.repair.historynum;
                                mission.Data.hangstate = false;
                            }
                        }
                        let _getListHitsleast = [STRUCTURE_RAMPART, STRUCTURE_WALL];
                        switch (mission.Data.RepairType) {
                            case 'globalrampart':
                                _getListHitsleast = [STRUCTURE_RAMPART];
                                break;
                            case 'globalwall':
                                _getListHitsleast = [STRUCTURE_WALL];
                                break;
                        }
                        var leastRam = this.room.getListHitsleast(_getListHitsleast, 3);
                        if (!leastRam)
                            return;
                        if (mission.Data.maxhit) {
                            /*检查是否已经完成所有的刷墙任务*/
                            if (leastRam.hits > mission.Data.maxhit) {
                                /*检测任务已经完成后将会标记新生成爬数量为0 同时保持任务，等待任务检测进程*/
                                mission.CreepBind.repair.num = 0;
                                mission.Data.hangstate = true;
                            }
                        }
                        this.memory.targetID = leastRam.id;
                    }
                    if (this.memory.containerID) {
                        delete this.memory.containerID;
                    }
                    break;
                case 'nuker':
                    // 核弹防御
                    /* 防核函数  测试成功！*/
                    if (!belongRoom.memory.nukeData)
                        return;
                    if (Object.keys(belongRoom.memory.nukeData.damage).length <= 0) {
                        belongRoom.DeleteMission(id);
                        return;
                    }
                    /* 优先修spawn和terminal */
                    if (!this.memory.targetID) {
                        for (var dmgPoint in belongRoom.memory.nukeData.damage) {
                            if (belongRoom.memory.nukeData.damage[dmgPoint] <= 0)
                                continue;
                            var position_ = unzipPosition(dmgPoint);
                            if (!position_.GetStructure('rampart')) {
                                position_.createConstructionSite('rampart');
                                if (!this.memory.working)
                                    this.withdraw_(storage_, 'energy');
                                else
                                    this.build_(position_.lookFor(LOOK_CONSTRUCTION_SITES)[0]);
                                return;
                            }
                            this.memory.targetID = position_.GetStructure('rampart').id;
                            return;
                        }
                        if (!belongRoom.DeleteMission(id))
                            this.memory.MissionData = {};
                        return;
                    }
                    else {
                        this.memory.standed = false;
                        if (this.memory.crossLevel > 10)
                            this.memory.crossLevel = 10 - Math.ceil(Math.random() * 10);
                        var wall_ = Game.getObjectById(this.memory.targetID);
                        var strPos = zipPosition(wall_.pos);
                        if (!wall_ || wall_.hits >= belongRoom.memory.nukeData.damage[strPos] + belongRoom.memory.nukeData.rampart[strPos] + 500000) {
                            delete this.memory.targetID;
                            belongRoom.memory.nukeData.damage[strPos] = 0;
                            belongRoom.memory.nukeData.rampart[strPos] = 0;
                            return;
                        }
                        this.repair_(wall_);
                        let hostileCreep = this.pos.findInRange(FIND_HOSTILE_CREEPS, 3, {
                            filter: (creep) => {
                                return creep.getActiveBodyparts('ranged_attack') > 0;
                            }
                        });
                        if (hostileCreep.length > 0)
                            this.Flee(hostileCreep[0].pos, 4);
                    }
                    break;
                case 'special':
                    if (this.memory.targetID) {
                        this.say("🛠️");
                        var target_ = Game.getObjectById(this.memory.targetID);
                        if (!target_) {
                            delete this.memory.targetID;
                            return;
                        }
                        this.repair_(target_);
                        let hostileCreep = this.pos.findInRange(FIND_HOSTILE_CREEPS, 3, {
                            filter: (creep) => {
                                return creep.getActiveBodyparts('ranged_attack') > 0;
                            }
                        });
                        if (hostileCreep.length > 0)
                            this.Flee(hostileCreep[0].pos, 4);
                    }
                    else {
                        /* 寻找插了旗子的hits最小的墙 */
                        var flags = this.room.find(FIND_FLAGS, {
                            filter: (flag) => {
                                return flag.name.indexOf('repair') == 0;
                            }
                        });
                        if (flags.length <= 0)
                            return;
                        let disWall = null;
                        for (var f of flags) {
                            let fwall = f.pos.GetStructureList(['rampart', 'constructedWall'])[0];
                            if (!fwall)
                                f.remove();
                            else {
                                if (!disWall || fwall.hits < disWall.hits)
                                    disWall = fwall;
                            }
                        }
                        if (!disWall) {
                            // 没有旗子就删除任务
                            belongRoom.DeleteMission(id);
                            return;
                        }
                        this.memory.targetID = disWall.id;
                    }
                    delete this.memory.containerID;
                    break;
            }
        }
        else {
            if (this.memory.targetID)
                delete this.memory.targetID;
            if (this.room.terminal && this.room.terminal.store.getUsedCapacity('energy') >= 60000) {
                var tank_ = this.room.terminal;
            }
            else if (storage_ && storage_.store.getUsedCapacity('energy') >= this.store.getCapacity()) {
                var tank_ = storage_;
            }
            else {
                if (!this.memory.containerID) {
                    if (this.room.terminal && this.room.controller.level < 8) {
                        this.memory.containerID = this.room.terminal.id;
                    }
                    else {
                        var tank = this.pos.findClosestByPath(FIND_MY_STRUCTURES, {
                            filter: (stru) => {
                                return (stru.structureType == 'storage' || stru.structureType == 'terminal' ||
                                    (stru.structureType == 'link' && isInArray(belongRoom.memory.StructureIdData.comsume_link, stru.id))) && stru.store.getUsedCapacity('energy') > this.store.getCapacity();
                            }
                        });
                        if (tank) {
                            this.memory.containerID = tank.id;
                        }
                        else {
                            let closestStore = this.pos.findClosestByRange(FIND_STRUCTURES, { filter: (stru) => { return (stru.structureType == 'container' || stru.structureType == 'tower') && stru.store.getUsedCapacity('energy') >= this.store.getFreeCapacity(); } });
                            if (closestStore)
                                this.withdraw_(closestStore, 'energy');
                            return;
                        }
                    }
                }
                var tank_ = Game.getObjectById(this.memory.containerID);
                if (!tank_) {
                    /*没有能量的获取途径*/
                    this.say("无法提取能量");
                    return;
                }
            }
            this.withdraw_(tank_, 'energy');
        }
    }
    // C计划
    handle_planC() {
        let mission = this.memory.MissionData;
        // if (Game.rooms[mission.Data.disRoom] && !Game.rooms[mission.Data.disRoom].controller.safeMode) Game.rooms[mission.Data.disRoom].controller.activateSafeMode()
        if (this.memory.role == 'cclaim') {
            if (this.room.name != mission.Data.disRoom || Game.shard.name != mission.Data.shard) {
                this.arriveTo(new RoomPosition(25, 25, mission.Data.disRoom), 20, mission.Data.shard);
                return;
            }
            else {
                if (!this.pos.isNearTo(this.room.controller))
                    this.goTo(this.room.controller.pos, 1);
                else {
                    if (!this.room.controller.owner)
                        this.claimController(this.room.controller);
                    this.signController(this.room.controller, 'better to rua BB cat at home!');
                }
            }
        }
        else {
            this.workstate('energy');
            if (this.room.name == this.memory.belong && !this.memory.working) {
                let store = this.pos.findClosestByRange(FIND_STRUCTURES, {
                    filter: (stru) => {
                        return (stru.structureType == 'container' ||
                            stru.structureType == 'tower' ||
                            stru.structureType == 'storage') && stru.store.getUsedCapacity('energy') >= this.store.getFreeCapacity();
                    }
                });
                if (store) {
                    this.withdraw_(store, 'energy');
                }
                return;
            }
            if (!Game.rooms[mission.Data.disRoom]) {
                this.goTo(new RoomPosition(25, 25, mission.Data.disRoom), 20);
                return;
            }
            if (Game.rooms[mission.Data.disRoom].controller.level >= 2) {
                global.SpecialBodyData[this.memory.belong]['cupgrade'] = GenerateAbility(1, 1, 1, 0, 0, 0, 0, 0);
            }
            if (this.memory.working) {
                if (this.room.name != mission.Data.disRoom) {
                    this.goTo(Game.rooms[mission.Data.disRoom].controller.pos, 1);
                    return;
                }
                let cons = this.pos.findClosestByRange(FIND_MY_CONSTRUCTION_SITES);
                if (cons)
                    this.build_(cons);
                else {
                    this.upgrade_();
                    this.say("cupgrade");
                }
            }
            else {
                let source = this.pos.findClosestByRange(FIND_SOURCES_ACTIVE);
                if (source)
                    this.harvest_(source);
            }
        }
    }
    // 扩张援建
    handle_expand() {
        let missionData = this.memory.MissionData;
        let id = missionData.id;
        if (this.getActiveBodyparts('heal') && this.hits < this.hitsMax)
            this.heal(this);
        if (this.room.name == this.memory.belong) {
            switch (this.memory.role) {
                case 'Ebuild':
                case 'Eupgrade':
                    switch (missionData.Data.level) {
                        case 'T3':
                            if (!this.BoostCheck(['work', 'move', 'carry']))
                                return;
                            break;
                        case 'T7':
                            if (!this.BoostCheck(['work', 'move', 'carry', 'heal']))
                                return;
                            break;
                        default:
                            if (!this.BoostCheck(['work', 'move']))
                                return;
                            break;
                    }
                    break;
            }
        }
        // pandaflower 修复 援建从旗帜房(应该是援建房隔壁的房间)采集资源 卡在门口横跳的问题
        // 再采集房插旗`${this.memory.belong}/HB/harvest`, 在援建房插旗 `${this.memory.belong}/expand`
        if (!this.memory.arrived || this.memory.working) {
            if (this.room.name != missionData.Data.disRoom || Game.shard.name != missionData.Data.shard) {
                this.arriveTo(new RoomPosition(24, 24, missionData.Data.disRoom), 10, missionData.Data.shard, missionData.Data.shardData ? missionData.Data.shardData : null);
                return;
            }
        }
        // end
        if (this.room.name == missionData.Data.disRoom && Game.shard.name == missionData.Data.shard) ;
        if (!this.memory.arrived && Game.flags[`${this.memory.belong}/expand`] && Game.flags[`${this.memory.belong}/expand`].pos.roomName == this.room.name) {
            if (!this.pos.isEqualTo(Game.flags[`${this.memory.belong}/expand`]))
                this.goTo(Game.flags[`${this.memory.belong}/expand`].pos, 0);
            else
                this.memory.arrived = true;
            return;
        }
        if (this.room.memory.state == 'peace' && (this.room.controller.my && this.room.controller.level >= 5)) {
            if (this.hits < this.hitsMax) {
                this.optTower('heal', this, true);
            }
        }
        this.workstate('energy');
        if (this.memory.role == 'claim') {
            if (!this.pos.isNearTo(Game.rooms[missionData.Data.disRoom].controller))
                this.goTo(Game.rooms[missionData.Data.disRoom].controller.pos, 1);
            else {
                this.claimController(Game.rooms[missionData.Data.disRoom].controller);
                this.say("claim");
            }
            if (missionData.Data.shard == this.memory.shard) {
                if (Game.rooms[missionData.Data.disRoom].controller.level && Game.rooms[missionData.Data.disRoom].controller.owner) {
                    let mission = Game.rooms[this.memory.belong].GainMission(id);
                    if (!mission)
                        return;
                    mission.CreepBind[this.memory.role].num = 0;
                }
            }
        }
        else if (this.memory.role == 'Ebuild') {
            if (this.memory.working) {
                if (this.room.controller.level < 8) {
                    let tower = this.pos.findClosestByPath(FIND_MY_STRUCTURES, {
                        filter: (stru) => {
                            return stru.structureType == 'tower' && stru.store.getFreeCapacity('energy') > 500;
                        }
                    });
                    if (tower) {
                        this.transfer_(tower, 'energy');
                        return;
                    }
                }
                if (Game.flags[`${this.memory.belong}/first_build`]) {
                    let fcon = Game.flags[`${this.memory.belong}/first_build`].pos.lookFor(LOOK_CONSTRUCTION_SITES);
                    if (fcon.length > 0) {
                        this.build_(fcon[0]);
                    }
                    else {
                        Game.flags[`${this.memory.belong}/first_build`].remove();
                    }
                    return;
                }
                /* 优先遭建筑 */
                let cons = this.pos.findClosestByRange(FIND_MY_CONSTRUCTION_SITES);
                if (cons) {
                    this.build_(cons);
                    return;
                }
                if (this.room.controller.level < 6) {
                    let store = this.pos.getClosestStore();
                    if (store) {
                        this.transfer_(store, 'energy');
                        return;
                    }
                }
                if (this.room.controller.level < 4) {
                    let roads = this.pos.findClosestByRange(FIND_STRUCTURES, {
                        filter: (stru) => {
                            return ((stru.structureType == 'road' || stru.structureType == 'container') && stru.hits < stru.hitsMax * 0.8) ||
                                (stru.structureType == 'rampart' && stru.hits < 100000);
                        }
                    });
                    if (roads) {
                        this.repair_(roads);
                        return;
                    }
                }
                if (this.room.controller.level > 6) {
                    if (this.memory.targetID) {
                        this.say("🛠️");
                        var target_ = Game.getObjectById(this.memory.targetID);
                        if (!target_) {
                            delete this.memory.targetID;
                            return;
                        }
                        if (target_.hits > 1000000) {
                            delete this.memory.targetID;
                        }
                        this.repair_(target_);
                        return;
                    }
                    else {
                        var leastRam = this.room.getListHitsleast([STRUCTURE_RAMPART, STRUCTURE_WALL], 3, 1000000);
                        if (leastRam) {
                            this.memory.targetID = leastRam.id;
                        }
                    }
                }
                this.upgrade_();
            }
            else {
                if (this.ticksToLive < 60)
                    this.suicide();
                delete this.memory.targetID;
                // 以withdraw开头的旗帜  例如： withdraw_0
                let withdrawFlag = this.room.find(FIND_FLAGS, {
                    filter: (flag) => {
                        return flag.name.indexOf('withdraw') == 0;
                    }
                });
                if (withdrawFlag.length > 0) {
                    let tank_ = withdrawFlag[0].pos.GetStructureList(['storage', 'terminal', 'container', 'tower']);
                    let ruin_ = withdrawFlag[0].pos.GetRuin();
                    // console.log(this.name, tank_.length)
                    if (tank_.length > 0) {
                        /*扫描周围如果有八个爬 默认为已经占满 执行2空格策略*/
                        let creeps = tank_[0].pos.findInRange(FIND_MY_CREEPS, 1);
                        if (creeps.length >= 8 && !this.pos.isNearTo(tank_[0])) {
                            if (this.pos.inRangeTo(tank_[0], 2)) {
                                /*寻找相临的爬*/
                                for (let i of creeps) {
                                    if (this.pos.isNearTo(i) && i.store.getUsedCapacity('energy') > 200) {
                                        i.transfer(this, 'energy');
                                        return;
                                    }
                                }
                            }
                            this.goTo(tank_[0].pos, 2);
                        }
                        else {
                            this.withdraw_(tank_[0], 'energy');
                        }
                        return;
                    }
                    else if (ruin_ && ruin_.store['energy'] > 0) {
                        if (this.pos.isNearTo(ruin_)) {
                            this.withdraw(ruin_, 'energy');
                        }
                        else {
                            this.goTo(ruin_.pos, 1);
                        }
                        return;
                    }
                }
                if (this.room.storage && this.room.storage.my && this.room.terminal) {
                    if (this.room.storage.store.getUsedCapacity('energy') > this.store.getFreeCapacity('energy')) {
                        this.withdraw_(this.room.storage, 'energy');
                        return;
                    }
                }
                let harvestFlag = Game.flags[`${this.memory.belong}/HB/harvest`];
                if (harvestFlag) {
                    if (this.hits < this.hitsMax) {
                        this.heal(this);
                    }
                    if (this.room.name != harvestFlag.pos.roomName) {
                        this.goTo(harvestFlag.pos, 1);
                    }
                    else {
                        let source = this.pos.findClosestByRange(FIND_SOURCES_ACTIVE);
                        if (source) {
                            this.harvest_(source);
                        }
                    }
                    return;
                }
                let resources = this.pos.findClosestByPath(FIND_DROPPED_RESOURCES, {
                    filter: (res) => {
                        return res.amount > 200 && res.resourceType == 'energy';
                    }
                });
                if (resources) {
                    if (!this.pos.isNearTo(resources))
                        this.goTo(resources.pos, 1);
                    else
                        this.pickup(resources);
                    return;
                }
                else {
                    let tombstones = this.pos.findClosestByPath(FIND_TOMBSTONES, {
                        filter: (res) => {
                            return res.store.getUsedCapacity('energy') > 100;
                        }
                    });
                    if (tombstones) {
                        if (!this.pos.isNearTo(tombstones))
                            this.goTo(tombstones.pos, 1);
                        else
                            this.withdraw(tombstones, 'energy');
                        return;
                    }
                }
                let source = this.pos.findClosestByPath(FIND_SOURCES_ACTIVE);
                if (source) {
                    this.harvest_(source);
                }
                // let tombstones = this.pos.findClosestByPath(FIND_DROPPED_RESOURCES)
                // if (tombstones) {
                //     if (!this.pos.isNearTo(tombstones)) this.goTo(resources.pos, 1)
                //     else this.pickup(tombstones)
                //     return
                // }
                // if (this.ticksToLive < 120 && this.store.getUsedCapacity('energy') <= 20) this.suicide()
                if (this.store.getUsedCapacity('energy') / (this.ticksToLive + 50) > 10)
                    this.memory.working = true;
            }
        }
        else if (this.memory.role == 'Eupgrade') {
            if (this.memory.working) {
                // this.say("upgrade")
                if (Game.flags[`${this.memory.belong}/first_build`]) {
                    let fcon = Game.flags[`${this.memory.belong}/first_build`].pos.lookFor(LOOK_CONSTRUCTION_SITES);
                    if (fcon.length > 0) {
                        this.build_(fcon[0]);
                    }
                    else {
                        Game.flags[`${this.memory.belong}/first_build`].remove();
                    }
                    return;
                }
                this.upgrade_();
            }
            else {
                if (this.ticksToLive < 60)
                    this.suicide();
                if (this.room.controller.level >= 8) {
                    if (missionData.Data.shard == this.memory.shard) {
                        let mission = Game.rooms[this.memory.belong].GainMission(id);
                        if (!mission)
                            return;
                        Game.rooms[this.memory.belong].DeleteMission(id);
                        return;
                    }
                }
                // 以withdraw开头的旗帜  例如： withdraw_0
                let withdrawFlag = this.room.find(FIND_FLAGS, {
                    filter: (flag) => {
                        return flag.name.indexOf('withdraw') == 0;
                    }
                });
                if (withdrawFlag.length > 0) {
                    let tank_ = withdrawFlag[0].pos.GetStructureList(['storage', 'terminal', 'container', 'tower']);
                    let ruin_ = withdrawFlag[0].pos.GetRuin();
                    // console.log(this.name, tank_.length)
                    if (tank_.length > 0) {
                        /*扫描周围如果有八个爬 默认为已经占满 执行2空格策略*/
                        let creeps = tank_[0].pos.findInRange(FIND_MY_CREEPS, 1);
                        if (creeps.length >= 8 && !this.pos.isNearTo(tank_[0])) {
                            if (this.pos.inRangeTo(tank_[0], 2)) {
                                /*寻找相临的爬*/
                                for (let i of creeps) {
                                    if (this.pos.isNearTo(i) && i.store.getUsedCapacity('energy') > 200) {
                                        i.transfer(this, 'energy');
                                        return;
                                    }
                                }
                            }
                            this.goTo(tank_[0].pos, 2);
                        }
                        else {
                            this.withdraw_(tank_[0], 'energy');
                        }
                        return;
                    }
                    else if (ruin_ && ruin_.store['energy'] > 0) {
                        if (this.pos.isNearTo(ruin_)) {
                            this.withdraw(ruin_, 'energy');
                        }
                        else {
                            this.goTo(ruin_.pos, 1);
                        }
                        return;
                    }
                }
                if (this.room.storage && this.room.storage.my && this.room.terminal) {
                    if (this.room.storage.store.getUsedCapacity('energy') > this.store.getFreeCapacity('energy')) {
                        this.withdraw_(this.room.storage, 'energy');
                        return;
                    }
                }
                let harvestFlag = Game.flags[`${this.memory.belong}/HB/harvest`];
                if (harvestFlag) {
                    if (this.hits < this.hitsMax) {
                        this.heal(this);
                    }
                    if (this.room.name != harvestFlag.pos.roomName) {
                        this.goTo(harvestFlag.pos, 1);
                    }
                    else {
                        let source = this.pos.findClosestByRange(FIND_SOURCES_ACTIVE);
                        if (source) {
                            this.harvest_(source);
                        }
                    }
                    return;
                }
                let resources = this.pos.findClosestByPath(FIND_DROPPED_RESOURCES, {
                    filter: (res) => {
                        return res.amount > 200 && res.resourceType == 'energy';
                    }
                });
                if (resources) {
                    if (!this.pos.isNearTo(resources))
                        this.goTo(resources.pos, 1);
                    else
                        this.pickup(resources);
                    return;
                }
                let source = this.pos.findClosestByPath(FIND_SOURCES_ACTIVE);
                if (source)
                    this.harvest_(source);
                // if (this.ticksToLive < 120 && this.store.getUsedCapacity('energy') <= 20) this.suicide()
                if (this.store.getUsedCapacity('energy') / (this.ticksToLive + 50) > 10)
                    this.memory.working = true;
            }
        }
    }
    // 急速冲级
    handle_quickRush() {
        let missionData = this.memory.MissionData;
        let id = missionData.id;
        let mission = Game.rooms[this.memory.belong].GainMission(id);
        if (!mission)
            return;
        // boost检查
        if (!this.memory.boostState) {
            if (mission.LabBind && !this.BoostCheck(['work']))
                return;
        }
        this.workstate('energy');
        var terminal_ = this.room.terminal;
        if (!terminal_) {
            this.say("找不到terminal!");
            return;
        }
        if (this.memory.working) {
            this.upgrade_();
            if (this.store.getUsedCapacity('energy') < 35 && terminal_.pos.isNearTo(this))
                this.withdraw_(terminal_, 'energy');
        }
        else {
            this.withdraw_(terminal_, 'energy');
        }
        this.memory.standed = mission.Data.standed;
    }
    // 普通冲级
    handle_normalRush() {
        let missionData = this.memory.MissionData;
        let id = missionData.id;
        let mission = Game.rooms[this.memory.belong].GainMission(id);
        if (!mission)
            return;
        var link_ = Game.getObjectById(Game.rooms[this.memory.belong].memory.StructureIdData.upgrade_link);
        if (!link_) {
            this.say("找不到冲级link!");
            return;
        }
        // boost检查
        if (mission.LabBind && !this.BoostCheck(['work']))
            return;
        this.workstate('energy');
        if (this.memory.working) {
            this.upgrade_();
            if (this.store.getUsedCapacity('energy') < 35 && link_.pos.isNearTo(this))
                this.withdraw_(link_, 'energy');
        }
        else {
            this.withdraw_(link_, 'energy');
        }
    }
    // 紧急援建
    handle_helpBuild() {
        var _a, _b;
        let missionData = this.memory.MissionData;
        missionData.id;
        let data = missionData.Data;
        if (!missionData)
            return;
        if (this.room.name == this.memory.belong && Game.shard.name == this.memory.shard) {
            if (!this.BoostCheck(['move', 'work', 'heal', 'tough', 'carry']))
                return;
            if (this.store.getUsedCapacity('energy') <= 0 && (this.room.name != data.disRoom || Game.shard.name != data.shard)) {
                let stroge_ = this.room.storage;
                if (stroge_) {
                    this.withdraw_(stroge_, 'energy');
                    return;
                }
            }
        }
        if ((this.room.name != data.disRoom || Game.shard.name != data.shard) && !this.memory.swith) {
            if (this.hits < this.hitsMax) {
                this.heal(this);
            }
            this.arriveTo(new RoomPosition(24, 24, data.disRoom), 23, data.shard, data.shardData ? data.shardData : null);
        }
        else {
            this.memory.swith = true;
            let runFlag = this.pos.findClosestByRange(FIND_FLAGS, {
                filter: (flag) => {
                    return flag.color == COLOR_BLUE;
                }
            });
            if (runFlag) {
                this.goTo(runFlag.pos, 0);
                return;
            }
            this.workstate('energy');
            if (this.memory.working) {
                if (this.room.name != data.disRoom) {
                    this.arriveTo(new RoomPosition(24, 24, data.disRoom), 23, data.shard);
                    return;
                }
                if (this.hits < this.hitsMax) {
                    this.heal(this);
                }
                if (Game.flags[`${this.memory.belong}/first_build`]) {
                    let fcon = Game.flags[`${this.memory.belong}/first_build`].pos.lookFor(LOOK_CONSTRUCTION_SITES);
                    if (fcon.length > 0) {
                        this.build_(fcon[0]);
                    }
                    else {
                        Game.flags[`${this.memory.belong}/first_build`].remove();
                    }
                    return;
                }
                let cons = this.pos.findClosestByRange(FIND_CONSTRUCTION_SITES);
                if (cons) {
                    this.build_(cons);
                    return;
                }
                let store = this.pos.findClosestByPath(FIND_STRUCTURES, {
                    filter: (stru) => {
                        return (stru.structureType == 'extension' || stru.structureType == 'spawn') && stru.store.getFreeCapacity('energy') > 0;
                    }
                });
                if (store) {
                    this.transfer_(store, 'energy');
                    return;
                }
                let tower = this.pos.findClosestByPath(FIND_STRUCTURES, {
                    filter: (stru) => {
                        return stru.structureType == 'tower' && stru.store.getFreeCapacity('energy') > 0;
                    }
                });
                if (tower) {
                    this.transfer_(tower, 'energy');
                    return;
                }
                let _storage = this.room.storage;
                if (_storage) {
                    this.transfer_(_storage, 'energy');
                    return;
                }
            }
            else {
                if (this.store.getUsedCapacity('energy') / (this.ticksToLive + 50) > 10)
                    this.memory.working = true;
                // 以withdraw开头的旗帜  例如： withdraw_0
                let withdrawFlag = this.pos.findClosestByPath(FIND_FLAGS, {
                    filter: (flag) => {
                        return flag.name.indexOf('withdraw') == 0;
                    }
                });
                if (withdrawFlag) {
                    let tank_ = withdrawFlag.pos.GetStructureList(['storage', 'terminal', 'container', 'tower']);
                    if (tank_.length > 0) {
                        this.withdraw_(tank_[0], 'energy');
                        return;
                    }
                }
                let harvestFlag = Game.flags[`${this.memory.belong}/HB/harvest`];
                if (harvestFlag) {
                    if (this.hits < this.hitsMax) {
                        this.heal(this);
                    }
                    if (this.room.name != harvestFlag.pos.roomName) {
                        this.goTo(harvestFlag.pos, 1);
                    }
                    else {
                        let source = this.pos.findClosestByRange(FIND_SOURCES_ACTIVE);
                        if (source) {
                            this.harvest_(source);
                        }
                    }
                    return;
                }
                if ((this.room.name == data.disRoom && Game.shard.name == data.shard) && !((_a = this.room.controller) === null || _a === void 0 ? void 0 : _a.my)) {
                    if (!((_b = this.room.controller) === null || _b === void 0 ? void 0 : _b.safeMode))
                        this.suicide();
                }
                let resources = this.pos.findClosestByPath(FIND_DROPPED_RESOURCES, {
                    filter: (res) => {
                        return res.amount > 200 && res.resourceType == 'energy';
                    }
                });
                if (resources) {
                    if (!this.pos.isNearTo(resources))
                        this.goTo(resources.pos, 1);
                    else
                        this.pickup(resources);
                    return;
                }
                let tombstones = this.pos.findClosestByPath(FIND_TOMBSTONES, {
                    filter: (res) => {
                        return res.store.getUsedCapacity('energy') > 100;
                    }
                });
                if (tombstones) {
                    if (!this.pos.isNearTo(tombstones))
                        this.goTo(tombstones.pos, 1);
                    else
                        this.withdraw(tombstones, 'energy');
                    return;
                }
                let ruins = this.pos.findClosestByPath(FIND_RUINS, {
                    filter: (res) => {
                        return res.store.getUsedCapacity('energy') > 100;
                    }
                });
                if (ruins) {
                    if (!this.pos.isNearTo(ruins))
                        this.goTo(ruins.pos, 1);
                    else
                        this.withdraw(ruins, 'energy');
                    return;
                }
                let source = this.pos.findClosestByPath(FIND_SOURCES_ACTIVE);
                if (source) {
                    this.harvest_(source);
                }
                else {
                    this.workstate('energy', 0.3);
                }
            }
        }
    }
    /*紧急升级*/
    handle_helpUpgrade() {
        var _a;
        let missionData = this.memory.MissionData;
        missionData.id;
        let data = missionData.Data;
        if (!missionData)
            return;
        if (this.room.name == this.memory.belong && Game.shard.name == this.memory.shard) {
            if (!this.BoostCheck(['move', 'work', 'heal', 'tough', 'carry']))
                return;
            if (this.store.getUsedCapacity('energy') <= 0) {
                let stroge_ = this.room.storage;
                if (stroge_) {
                    this.withdraw_(stroge_, 'energy');
                    return;
                }
            }
        }
        if ((this.room.name != data.disRoom || Game.shard.name != data.shard)) {
            if (this.hits < this.hitsMax) {
                // this.heal(this)
                if ((_a = this.room.controller) === null || _a === void 0 ? void 0 : _a.my) {
                    this.optTower('heal', this, true);
                }
            }
            this.arriveTo(new RoomPosition(24, 24, data.disRoom), 23, data.shard, data.shardData ? data.shardData : null);
        }
        else {
            this.memory.swith = true;
            this.workstate('energy');
            if (this.room.memory.state == 'peace' && this.hits < this.hitsMax) {
                this.optTower('heal', this, true);
            }
            if (this.memory.working) {
                // if (this.hits < this.hitsMax) {
                //     this.optTower('heal', this, true)
                // }
                // if (!this.pos.inRangeTo(this.room.controller, 3)) this.goTo(this.room.controller.pos, 3)
                this.upgrade_();
            }
            else {
                let resources_list = this.pos.findInRange(FIND_DROPPED_RESOURCES, 5, {
                    filter: (res) => {
                        return res.amount > 200 && res.resourceType == 'energy';
                    }
                });
                if (resources_list.length > 0) {
                    let resources = resources_list[0];
                    if (!this.pos.isNearTo(resources))
                        this.goTo(resources.pos, 1);
                    else
                        this.pickup(resources);
                    return;
                }
                let tombstones_list = this.pos.findInRange(FIND_TOMBSTONES, 5, {
                    filter: (res) => {
                        return res.store.getUsedCapacity('energy') > 100;
                    }
                });
                if (tombstones_list.length > 0) {
                    let tombstones = tombstones_list[0];
                    if (!this.pos.isNearTo(tombstones))
                        this.goTo(tombstones.pos, 1);
                    else
                        this.withdraw(tombstones, 'energy');
                    return;
                }
                this.suicide();
            }
        }
    }
    /*紧急墙体*/
    handle_helpRepair() {
        let missionData = this.memory.MissionData;
        let id = missionData.id;
        let data = missionData.Data;
        let belongRoom = Game.rooms[this.memory.belong];
        if (!id)
            return;
        this.workstate('energy');
        /* boost检查 */
        // var a = Game.cpu.getUsed();
        if (this.room.name == this.memory.belong && Game.shard.name == this.memory.shard) {
            switch (missionData.Data.level) {
                case 'T3':
                    if (!this.BoostCheck(['work', 'move', 'carry']))
                        return;
                    break;
                default:
                    if (!this.BoostCheck(['work']))
                        return;
                    break;
            }
            // if (!this.BoostCheck(['move', 'work', 'heal', 'tough', 'carry'])) return
            // if (this.store.getUsedCapacity('energy') <= 0) {
            //     let stroge_ = this.room.storage as StructureStorage
            //     if (stroge_) {
            //         this.withdraw_(stroge_, 'energy')
            //         return
            //     }
            // }
        }
        // if (mission.LabBind && !this.memory.boostState) {
        //     // if (!storage_) return   // 如果是boost的，没有仓库就不刷了
        //     // console.log('检查boost',this.name)
        //     // 需要boost检查，必要情况下可以不检查
        //     let boo = false
        //     for (var ids in mission.LabBind) {
        //         var lab_ = Game.getObjectById(ids as Id<StructureLab>) as StructureLab
        //         if (!lab_ || !lab_.mineralType || lab_.store.getUsedCapacity(lab_.mineralType) < 500)
        //             boo = true
        //     }
        //     if (!boo) {
        //     }
        // }
        if (belongRoom && belongRoom.memory.state == 'war') {
            if (this.hitsMax - this.hits > 500)
                this.optTower('heal', this);
        }
        if ((this.room.name != data.disRoom || Game.shard.name != data.shard)) {
            // if (this.hits < this.hitsMax) {
            //     this.heal(this)
            // }
            if (this.memory.targetID)
                delete this.memory.targetID;
            this.arriveTo(new RoomPosition(24, 24, data.disRoom), 23, data.shard, data.shardData ? data.shardData : null);
        }
        else {
            // this.memory.swith = true
            // console.log('工人信息', this.memory.working)
            if (this.memory.working) {
                if (this.hits < this.hitsMax) {
                    this.optTower('heal', this, true);
                }
                if (this.memory.targetID) {
                    this.say("🛠️");
                    var target_ = Game.getObjectById(this.memory.targetID);
                    if (!target_) {
                        delete this.memory.targetID;
                        return;
                    }
                    if (target_.hits >= target_.hitsMax)
                        delete this.memory.targetID;
                    this.repair_(target_, 400);
                    if (this.room.memory.state == 'war') {
                        let hostileCreep = this.pos.findInRange(FIND_HOSTILE_CREEPS, 3, {
                            filter: (creep) => {
                                return creep.getActiveBodyparts('ranged_attack') > 0;
                            }
                        });
                        if (hostileCreep.length > 0)
                            this.Flee(hostileCreep[0].pos, 4);
                    }
                }
                else {
                    /* 寻找插了旗子的hits最小的墙 */
                    var flags = this.room.find(FIND_FLAGS, {
                        filter: (flag) => {
                            return flag.name.indexOf('repair') == 0;
                        }
                    });
                    if (flags.length > 0) {
                        let disWall = null;
                        for (var f of flags) {
                            let fwall = f.pos.GetStructureList(['rampart', 'constructedWall'])[0];
                            if (!fwall)
                                f.remove();
                            else {
                                if (!disWall || fwall.hits < disWall.hits)
                                    disWall = fwall;
                            }
                        }
                        if (disWall)
                            this.memory.targetID = disWall.id;
                        return;
                    }
                    if (this.room.memory.state == 'peace') {
                        var construction = this.pos.findClosestByRange(FIND_MY_CONSTRUCTION_SITES);
                        if (construction) {
                            this.build_(construction);
                            return;
                        }
                    }
                    var leastRam = this.room.getListHitsleast([STRUCTURE_RAMPART, STRUCTURE_WALL], 3);
                    if (!leastRam)
                        return;
                    this.memory.targetID = leastRam.id;
                }
                if (this.memory.containerID) {
                    delete this.memory.containerID;
                }
            }
            else {
                /* 寻找hits最小的墙 */
                // var leastRam = this.room.getListHitsleast([STRUCTURE_RAMPART, STRUCTURE_WALL], 3)
                // if (!leastRam) return
                if (!Game.rooms[data.disRoom])
                    console.log('错误的房间信息');
                if (this.memory.targetID)
                    delete this.memory.targetID;
                if (Game.rooms[data.disRoom].terminal && Game.rooms[data.disRoom].terminal.store.getUsedCapacity('energy') >= 60000) {
                    var tank_ = Game.rooms[data.disRoom].terminal;
                }
                else if (Game.rooms[data.disRoom].storage && Game.rooms[data.disRoom].storage.store.getUsedCapacity('energy') >= this.store.getCapacity()) {
                    var tank_ = Game.rooms[data.disRoom].storage;
                }
                // console.log('取货目标',tank_.id)
                this.withdraw_(tank_, 'energy');
            }
        }
        // var b = Game.cpu.getUsed();
        // console.log(this.name, '刷墙', this.memory.working, b - a)
    }
    // 房间签名
    handle_sign() {
        let missionData = this.memory.MissionData;
        let id = missionData.id;
        let data = missionData.Data;
        if (!missionData)
            return;
        if (this.room.name != data.disRoom || Game.shard.name != data.shard) {
            this.arriveTo(new RoomPosition(24, 24, data.disRoom), 23, data.shard, data.shardData ? data.shardData : null);
        }
        else {
            let control = this.room.controller;
            if (control) {
                if (!this.pos.isNearTo(control))
                    this.goTo(control.pos, 1);
                else {
                    this.signController(control, data.str);
                }
                if (control.sign == data.str) {
                    Game.rooms[this.memory.belong].DeleteMission(id);
                }
            }
        }
    }
    /* 原矿开采任务处理 */
    handle_mineral() {
        var extractor = Game.getObjectById(Game.rooms[this.memory.belong].memory.StructureIdData.extractID);
        if (!extractor)
            return;
        var container;
        if (!this.memory.containerID) {
            var con = extractor.pos.findInRange(FIND_STRUCTURES, 1, {
                filter: (stru) => {
                    return stru.structureType == 'container';
                }
            });
            if (con.length > 0)
                this.memory.containerID = con[0].id;
            return;
        }
        else {
            container = Game.getObjectById(this.memory.containerID);
            if (!container)
                return;
            /* container杂志清理 */
            if (container.store && container.store.getUsedCapacity() > 0) {
                if (this.pos.isEqualTo(container)) {
                    for (var i in container.store) {
                        this.withdraw(container, i);
                    }
                }
            }
            let getFreeCapacity = this.store.getFreeCapacity();
            let getCapacity = this.store.getCapacity();
            if (!this.memory.working)
                this.memory.working = false;
            if (this.memory.working && getFreeCapacity == getCapacity) {
                this.memory.working = false;
            }
            else if (!this.memory.working && getFreeCapacity == 0) {
                this.memory.working = true;
            }
            if (this.memory.working) {
                var storage_ = Game.rooms[this.memory.belong].storage;
                if (!storage_)
                    return;
                if (!this.pos.isNearTo(storage_))
                    this.goTo(storage_.pos, 1, 300);
                else {
                    for (var i in this.store) {
                        this.transfer(storage_, i);
                        return;
                    }
                }
            }
            else {
                if (!this.pos.isEqualTo(container.pos)) {
                    this.goTo(container.pos, 0);
                    return;
                }
                else {
                    var mineral = Game.getObjectById(Game.rooms[this.memory.belong].memory.StructureIdData.mineralID);
                    if (!extractor.cooldown) {
                        this.harvest(mineral);
                        return;
                    }
                    if (this.ticksToLive < 15) {
                        if (Game.cpu.bucket < 7000 && Memory.StopPixel) {
                            Game.rooms[this.memory.belong].DeleteMission(this.memory.MissionData.id);
                        }
                        this.suicide();
                    }
                    if (!mineral.mineralAmount) {
                        Game.rooms[this.memory.belong].DeleteMission(this.memory.MissionData.id);
                        this.suicide();
                        return;
                    }
                }
            }
        }
    }
}

/* 爬虫原型拓展   --任务  --任务行为 */
class CreepMissonMineExtension extends Creep {
    /* 外矿开采处理 */
    handle_outmine() {
        var _a, _b;
        var creepMission = this.memory.MissionData.Data;
        var globalMission = Game.rooms[this.memory.belong].GainMission(this.memory.MissionData.id);
        //中央九房处理
        function centralSector(creep_, range) {
            var globalMission = Game.rooms[creep_.memory.belong].GainMission(creep_.memory.MissionData.id);
            if (creep_.memory.enemyID) {
                var enemy = Game.getObjectById(creep_.memory.enemyID);
                if (enemy) {
                    if (creep_.pos.inRangeTo(enemy, 6)) {
                        creep_.Flee(enemy.pos, 5);
                        return true;
                    }
                }
                else {
                    creep_.memory.enemyID = undefined;
                }
            }
            if (globalMission.Data.lairID) { //使用缓存减少cpu
                for (const lairID of globalMission.Data.lairID) {
                    var lair = Game.getObjectById(lairID);
                    if (!lair.ticksToSpawn) { //说明有keeper
                        if (creep_.pos.inRangeTo(lair, range)) {
                            var enemies = lair.pos.findInRange(FIND_HOSTILE_CREEPS, range, {
                                filter: (c) => {
                                    return c.getActiveBodyparts(ATTACK) > 0 || c.getActiveBodyparts(RANGED_ATTACK) > 0;
                                }
                            });
                            if (enemies.length > 0) {
                                creep_.memory.enemyID = enemies[0].id;
                                creep_.Flee(enemies[0].pos, 5);
                                return true;
                            }
                        }
                    }
                    else if (lair.ticksToSpawn < 5) { //快产爬了
                        creep_.Flee(lair.pos, 5);
                        return true;
                    }
                }
            }
            else {
                //寻找Keeper
                var keeper = creep_.pos.findInRange(FIND_HOSTILE_CREEPS, range, {
                    filter: (creep) => {
                        return creep.owner.username == 'Source Keeper' || creep.owner.username == 'Invader';
                    }
                });
                //逃离keeper
                if (keeper.length > 0) {
                    creep_.Flee(keeper[0].pos, 5);
                    creep_.memory.enemyID = keeper[0].id;
                    return true;
                }
            }
            return false;
        }
        if (!globalMission) {
            this.say("找不到全局任务了！");
            this.memory.MissionData = {};
            return;
        }
        if (this.hits < this.hitsMax && globalMission.Data.state == 2) {
            var enemy = this.pos.findClosestByPath(FIND_HOSTILE_CREEPS, {
                filter: (creep) => {
                    return !isInArray(Memory.whitesheet, creep.owner.username);
                }
            });
            if (enemy)
                globalMission.Data.state = 3;
        }
        if (this.memory.role == 'out-claim') {
            if (globalMission.Data.state == 4) {
                return;
            }
            if (this.room.name != creepMission.disRoom && !this.memory.disPos) {
                // this.goTo(new RoomPosition(25, 25, creepMission.disRoom), 20, null, 2)
                this.moveTo(new RoomPosition(25, 25, creepMission.disRoom), { range: 20, visualizePathStyle: { stroke: colors$2.purple } });
                if (this.room.name != this.memory.belong) {
                    /* 如果是别人的房间就不考虑 */
                    if (this.room.controller && this.room.controller.owner && this.room.controller.owner.username != this.owner.username)
                        return;
                    // if (Memory.outMineData && Memory.outMineData[this.room.name]) {
                    //     for (var i of Memory.outMineData[this.room.name].road) {
                    //         var thisPos = unzipPosition(i)
                    //         if (thisPos.roomName == this.name && !thisPos.GetStructure('road')) {
                    //             thisPos.createConstructionSite('road')
                    //         }
                    //     }
                    // }
                }
            }
            if (!this.memory.disPos && this.room.name == creepMission.disRoom && this.room.controller) {
                var controllerPos = this.room.controller.pos;
                this.memory.disPos = zipPosition(controllerPos);
            }
            if (this.memory.disPos) {
                if (!this.memory.num)
                    this.memory.num = 5000;
                if (this.room.controller.reservation && this.room.controller.reservation.ticksToEnd && this.room.controller.reservation.username == this.owner.username && this.room.controller.reservation.ticksToEnd <= this.memory.num) {
                    var Cores = this.room.find(FIND_STRUCTURES, {
                        filter: (structure) => {
                            return structure.structureType == STRUCTURE_INVADER_CORE;
                        }
                    });
                    if (Cores.length > 0)
                        globalMission.Data.state = 3;
                }
                if (this.room.controller.reservation && this.room.controller.reservation.ticksToEnd && this.room.controller.reservation.username != this.owner.username) {
                    globalMission.Data.state = 3;
                }
                if (!this.pos.isNearTo(this.room.controller)) {
                    var controllerPos = unzipPosition(this.memory.disPos);
                    if (controllerPos.roomName == this.room.name)
                        // this.goTo(controllerPos, 1, 500)
                        this.moveTo(controllerPos, { range: 1, maxOps: 500, visualizePathStyle: { stroke: colors$2.purple } });
                    else //this.goTo(controllerPos, 1, 800)
                        this.moveTo(controllerPos, { range: 1, maxOps: 800, visualizePathStyle: { stroke: colors$2.purple } });
                }
                else {
                    if (this.room.controller && (!this.room.controller.sign || (Game.time - this.room.controller.sign.time) > 100000)) {
                        if (["somygame"].includes(this.owner.username)) {
                            this.signController(this.room.controller, `麻了，麻了，彻底麻了`);
                        }
                        else if (["Morningtea"].includes(this.owner.username)) {
                            if (this.room.controller.sign) {
                                this.signController(this.room.controller, ``);
                            }
                        }
                        else if (!["superbitch", "ExtraDim"].includes(this.owner.username)) {
                            this.signController(this.room.controller, `${this.owner.username}'s 🌾 room!  Auto clean, Please keep distance!`);
                        }
                        else if (["CalvinG"].includes(this.owner.username)) {
                            this.signController(this.room.controller, `垒土成垛，择高而上🌾`);
                        }
                        else {
                            this.signController(this.room.controller, `躬耕陇亩`);
                        }
                    }
                    /* somygame 改 */
                    let _reserve_state = 0;
                    if (this.room.controller.reservation) {
                        if (this.room.controller.reservation.username == "Invader" && this.room.controller.reservation.ticksToEnd > 0) {
                            this.attackController(this.room.controller);
                            _reserve_state = 1;
                        }
                    }
                    if (_reserve_state < 1) {
                        this.reserveController(this.room.controller);
                    }
                    /* 终 */
                    // if (Game.time % 91 == 0) {
                    //     if (Memory.outMineData && Memory.outMineData[this.room.name]) {
                    //         for (var i of Memory.outMineData[this.room.name].road) {
                    //             var thisPos = unzipPosition(i) as RoomPosition
                    //             if (thisPos.roomName == this.room.name && !thisPos.GetStructure('road')) {
                    //                 thisPos.createConstructionSite('road')
                    //             }
                    //         }
                    //     }
                    // }
                }
                if (this.room.controller.reservation)
                    this.memory.num = this.room.controller.reservation.ticksToEnd;
            }
        }
        else if (this.memory.role == 'out-harvest') {
            if (!Game.rooms[creepMission.disRoom])
                return;
            if (!Memory.outMineData[creepMission.disRoom] || Memory.outMineData[creepMission.disRoom].minepoint.length <= 0)
                return;
            for (var point of Memory.outMineData[creepMission.disRoom].minepoint) {
                if (!point.bind)
                    point.bind = {};
                if (!point.bind.harvest && !this.memory.bindpoint) {
                    point.bind.harvest = this.name;
                    this.memory.bindpoint = point.pos;
                }
            }
            if (!this.memory.bindpoint)
                return;
            if (this.memory.carsourceid) {
                var source = Game.getObjectById(this.memory.carsourceid);
            }
            else {
                var disPos = unzipPosition(this.memory.bindpoint);
                var source = disPos.lookFor(LOOK_SOURCES)[0];
            }
            if (!source)
                return;
            this.workstate('energy');
            //防御状态回到自己房间
            if (globalMission.Data.state == 3 || globalMission.Data.hasInvader || Game.time < globalMission.Data.sleepTime) {
                // this.goTo(new RoomPosition(25, 25, this.memory.belong), 15)
                this.moveTo(new RoomPosition(25, 25, this.memory.belong), { range: 15, visualizePathStyle: { stroke: colors$2.lime } });
                if (this.room.name != this.memory.belong) {
                    return;
                }
                else if ((Game.time - globalMission.Data.sleepTime) > this.ticksToLive + 100) {
                    this.suicide();
                }
                if ((isInArray([0, 49], this.pos.x) || isInArray([0, 49], this.pos.y))) {
                    this.Flee(this.pos, 3);
                }
                else if (this.hits < this.hitsMax) {
                    this.optTower('heal', this);
                }
            }
            //中央九房特殊处理
            if (globalMission.Data.state == 4) {
                if (centralSector(this, 5))
                    return;
            }
            if (this.memory.working) {
                if (this.memory.containerID) {
                    let containerData = Game.getObjectById(this.memory.containerID);
                    if (!containerData)
                        delete this.memory.containerID;
                    if (containerData.store.getFreeCapacity() < 20)
                        return;
                    if (!this.pos.isEqualTo(containerData.pos)) {
                        // this.goTo(containerData.pos, 0)
                        this.moveTo(containerData, { range: 0, visualizePathStyle: { stroke: colors$2.yellow } });
                    }
                    else {
                        if (containerData.hits < containerData.hitsMax) {
                            this.repair(containerData);
                            return;
                        }
                        this.harvest(source);
                    }
                    return;
                }
                var container_ = source.pos.findInRange(FIND_STRUCTURES, 1, { filter: (stru) => { return stru.structureType == 'container'; } });
                if (container_[0]) {
                    if (container_[0].store.getFreeCapacity() < 20)
                        return;
                    if (!this.pos.isEqualTo(container_[0].pos)) {
                        // this.goTo(container_[0].pos, 0)
                        this.moveTo(container_[0], { range: 0, visualizePathStyle: { stroke: colors$2.yellow } });
                    }
                    else {
                        if (container_[0].hits < container_[0].hitsMax) {
                            this.repair(container_[0]);
                            return;
                        }
                        this.memory.containerID = container_[0].id;
                        this.transfer(container_[0], 'energy');
                        // this.harvest(source)
                    }
                    Memory.outMineData[creepMission.disRoom].car = true;
                    this.memory.working = false;
                }
                else {
                    Memory.outMineData[creepMission.disRoom].car = false;
                    var constainer_constru = source.pos.findInRange(FIND_MY_CONSTRUCTION_SITES, 1, { filter: (stru) => { return stru.structureType == 'container'; } });
                    if (constainer_constru[0]) {
                        this.build(constainer_constru[0]);
                    }
                    else {
                        this.pos.createConstructionSite('container');
                    }
                }
            }
            if (!this.memory.working) {
                if (!this.pos.isNearTo(disPos)) {
                    // this.goTo(disPos, 1)
                    this.moveTo(disPos, { range: 1, visualizePathStyle: { stroke: colors$2.yellow } });
                }
                else
                    this.harvest(source);
            }
        }
        else if (this.memory.role == 'out-car') {
            this.memory.crossLevel = 9;
            if (!Game.rooms[creepMission.disRoom])
                return;
            this.workstate('energy', 0.9);
            if (!Memory.outMineData[creepMission.disRoom] || Memory.outMineData[creepMission.disRoom].minepoint.length <= 0)
                return;
            if (!this.memory.bindpoint) {
                for (var point of Memory.outMineData[creepMission.disRoom].minepoint) {
                    if (!point.bind.car) {
                        point.bind.car = this.name;
                        this.memory.bindpoint = point.pos;
                        break;
                    }
                }
            }
            if (!this.memory.bindpoint)
                return;
            var disPos = unzipPosition(this.memory.bindpoint);
            if ((Game.time - global.Gtime[this.memory.belong]) % 91 == 0 && this.room.name != this.memory.belong) {
                if (Memory.outMineData && Memory.outMineData[disPos.roomName]) {
                    for (var i of Memory.outMineData[disPos.roomName].road) {
                        var thisPos = unzipPosition(i);
                        if (!Game.rooms[thisPos.roomName])
                            continue;
                        if (!thisPos.GetStructure('road')) {
                            thisPos.createConstructionSite('road');
                        }
                    }
                }
            }
            //防御状态回到自己房间
            if (globalMission.Data.state == 3 || globalMission.Data.hasInvader || Game.time < globalMission.Data.sleepTime) {
                // this.goTo(new RoomPosition(25, 25, this.memory.belong), 15)
                this.moveTo(new RoomPosition(25, 25, this.memory.belong), { range: 15, visualizePathStyle: { stroke: colors$2.lime } });
                if (this.room.name != this.memory.belong) {
                    return;
                }
                else {
                    if (this.store.getUsedCapacity() > 0) {
                        this.memory.working = true;
                    }
                    else {
                        if ((Game.time - globalMission.Data.sleepTime) > this.ticksToLive + 100)
                            this.suicide();
                        this.memory.working = false;
                        return;
                    }
                }
            }
            //中央九房特殊处理
            if (globalMission.Data.state == 4) {
                if (centralSector(this, 5))
                    return;
            }
            if (this.memory.working) {
                var stroage_ = Game.rooms[this.memory.belong].storage;
                if (!stroage_)
                    return;
                if (!this.pos.isNearTo(stroage_)) {
                    if (this.getActiveBodyparts(WORK) > 0) {
                        if ((Game.time - global.Gtime[this.memory.belong]) % 7 == 0) {
                            var constructions = this.pos.findClosestByRange(FIND_MY_CONSTRUCTION_SITES, {
                                filter: (constr) => {
                                    return constr.structureType == 'road';
                                }
                            });
                            if (constructions) {
                                this.memory.targetID = constructions.id;
                            }
                        }
                        // console.log(this.name, '标记1')
                        if (this.memory.targetID) {
                            var targetRoad = Game.getObjectById(this.memory.targetID);
                            if (targetRoad) {
                                this.build_(targetRoad);
                                return;
                            }
                            else
                                delete this.memory.targetID;
                        }
                        // console.log(this.name, '标记2')
                        if (this.room.name != this.memory.belong) { /*只修理外矿*/
                            var road_ = this.pos.GetStructure('road');
                            if (road_ && road_.hits < road_.hitsMax - 200 && this.ticksToLive > 100) {
                                this.repair(road_);
                                // this.goTo(stroage_.pos, 1, null, 4);
                                this.moveTo(stroage_, { range: 1, plainCost: 4, swampCost: 20, visualizePathStyle: { stroke: colors$2.orange } });
                                return;
                            }
                        }
                    }
                    // console.log(this.name, '标记3')
                    // if (Memory.outMineData && Memory.outMineData[creepMission.roomName]) {
                    // this.goTo(stroage_.pos, 1, null, 4, Memory.outMineData[creepMission.roomName].road)
                    // } else {
                    //     this.goTo(stroage_.pos, 1, null, 4)
                    // }
                    this.moveTo(stroage_, { range: 1, plainCost: 4, swampCost: 20, visualizePathStyle: { stroke: colors$2.orange } });
                }
                else {
                    if (Object.keys(this.store).length > 0) {
                        for (var r in this.store) {
                            if (this.room.storage.store.getFreeCapacity() > this.store.getUsedCapacity()) {
                                this.transfer_(this.room.storage, r);
                                return;
                            }
                            else
                                return;
                        }
                    }
                    if (this.ticksToLive < 100)
                        this.suicide();
                }
            }
            else {
                if (this.memory.dontPullMe)
                    this.memory.dontPullMe = false;
                if (this.ticksToLive < 200 || this.hits < this.hitsMax) {
                    let _path_length = 100;
                    if ((_a = this.memory.moveData) === null || _a === void 0 ? void 0 : _a.path) {
                        _path_length = this.memory.moveData.path.length;
                    }
                    if (this.memory.belong == this.room.name) {
                        if (this.hits < this.hitsMax)
                            this.optTower('heal', this);
                        if (_path_length * 2 + 30 > this.ticksToLive) {
                            this.suicide();
                        }
                    }
                    else {
                        if (this.ticksToLive < _path_length + 20)
                            this.memory.working = true;
                    }
                }
                if (!Game.rooms[disPos.roomName]) {
                    // this.goTo(disPos, 1)
                    this.moveTo(disPos, { range: 1, visualizePathStyle: { stroke: colors$2.orange } });
                    return;
                }
                if (this.memory.containerID) {
                    var containerData = Game.getObjectById(this.memory.containerID);
                    if (!containerData)
                        delete this.memory.containerID;
                    if (!this.pos.isNearTo(containerData)) {
                        // this.goTo(container_[0].pos, 1);
                        this.moveTo(containerData, { range: 1, visualizePathStyle: { stroke: colors$2.orange } });
                        return;
                    }
                    /*检查资源是否大于最大获取量或者接近死亡时间*/
                    if (containerData.store.getUsedCapacity() >= this.store.getFreeCapacity()) {
                        for (var r in containerData.store) {
                            if (containerData.store[r] > 0) {
                                this.withdraw(containerData, r);
                            }
                        }
                    }
                    return;
                }
                // this.say("🚗")
                var container_ = disPos.findInRange(FIND_STRUCTURES, 1, {
                    filter: (stru) => {
                        return stru.structureType == 'container';
                    }
                });
                if (container_[0] && container_[0].store.getUsedCapacity() > 0) {
                    this.memory.containerID = container_[0].id;
                    if (!this.pos.isNearTo(container_[0])) {
                        // this.goTo(container_[0].pos, 1);
                        this.moveTo(container_[0], { range: 1, visualizePathStyle: { stroke: colors$2.orange } });
                        return;
                    }
                    /*进行资源遍历操作*/
                    if (Object.keys(container_[0].store).length > 0) {
                        for (var r in container_[0].store) {
                            if (container_[0].store[r] > 0) {
                                this.withdraw(container_[0], r);
                                return;
                            }
                        }
                    }
                }
                else if (!container_[0]) {
                    // this.goTo(disPos, 2)
                    this.moveTo(disPos, { range: 2, visualizePathStyle: { stroke: colors$2.orange } });
                    return;
                }
            }
        }
        else if (this.memory.role == 'out-carry') {
            this.memory.crossLevel = 9;
            if (!Game.rooms[creepMission.disRoom])
                return;
            this.workstate('energy', 0.9);
            //防御状态回到自己房间
            if (globalMission.Data.state == 3 || globalMission.Data.hasInvader || Game.time < globalMission.Data.sleepTime) {
                // this.goTo(new RoomPosition(25, 25, this.memory.belong), 15)
                this.moveTo(new RoomPosition(25, 25, this.memory.belong), { range: 15, visualizePathStyle: { stroke: colors$2.lime } });
                if (this.room.name != this.memory.belong) {
                    return;
                }
                else {
                    if (this.store.getUsedCapacity() > 0) {
                        this.memory.working = true;
                    }
                    else {
                        if ((Game.time - globalMission.Data.sleepTime) > this.ticksToLive + 100)
                            this.suicide();
                        this.memory.working = false;
                        return;
                    }
                }
            }
            //中央九房特殊处理
            if (globalMission.Data.state == 4) {
                if (centralSector(this, 5))
                    return;
            }
            if (this.memory.working) {
                var stroage_ = Game.rooms[this.memory.belong].storage;
                if (!stroage_)
                    return;
                if (!this.pos.isNearTo(stroage_)) {
                    if (Memory.outMineData && Memory.outMineData[creepMission.roomName]) {
                        // this.goTo(stroage_.pos, 1, null, 4, Memory.outMineData[creepMission.roomName].road)
                        this.moveTo(stroage_, { plainCost: 4, swampCost: 20, visualizePathStyle: { stroke: colors$2.rose } });
                    }
                    else {
                        // this.goTo(stroage_.pos, 1, null, 4)
                        this.moveTo(stroage_, { plainCost: 4, swampCost: 20, visualizePathStyle: { stroke: colors$2.rose } });
                    }
                }
                else {
                    if (Object.keys(this.store).length > 0) {
                        for (var r in this.store) {
                            if (this.room.storage.store.getFreeCapacity() > this.store.getUsedCapacity()) {
                                this.transfer_(this.room.storage, r);
                            }
                            else
                                return;
                        }
                    }
                    if (this.ticksToLive < 100)
                        this.suicide();
                }
            }
            else {
                if (this.ticksToLive < 200 || this.hits < this.hitsMax) {
                    let _path_length = 100;
                    if ((_b = this.memory.moveData) === null || _b === void 0 ? void 0 : _b.path) {
                        _path_length = this.memory.moveData.path.length;
                    }
                    if (this.memory.belong == this.room.name) {
                        if (this.hits < this.hitsMax)
                            this.optTower('heal', this);
                        if (_path_length * 2 + 30 > this.ticksToLive) {
                            this.suicide();
                        }
                    }
                    else {
                        if (this.ticksToLive < _path_length + 20)
                            this.memory.working = true;
                    }
                }
                if (this.room.name != creepMission.disRoom) {
                    // this.goTo(new RoomPosition(25, 25, creepMission.disRoom), 20)
                    this.moveTo(new RoomPosition(25, 25, creepMission.disRoom), { range: 20, visualizePathStyle: { stroke: colors$2.slate } });
                    return;
                }
                // this.say("🚗")
                if (!this.memory.targetID && (Game.time - global.Gtime[this.memory.belong]) % 5 == 0) {
                    var creep_FreeCapacity = this.store.getFreeCapacity();
                    var range = 10;
                    var drop = this.pos.findClosestByRange(FIND_DROPPED_RESOURCES, {
                        filter: (res) => {
                            return (res.resourceType == 'energy' ? res.amount > 300 : true);
                        }
                    });
                    if (drop && drop.pos.getRangeTo(this) < range) {
                        // range = drop.pos.getRangeTo(this)
                        this.memory.targetID = drop.id;
                        return;
                    }
                    var tomb = this.pos.findClosestByRange(FIND_TOMBSTONES, {
                        filter: (tomb) => {
                            return (tomb.store.getUsedCapacity() > 300 || tomb.store.getUsedCapacity() > creep_FreeCapacity);
                        }
                    });
                    if (tomb && tomb.pos.getRangeTo(this) < range) {
                        // range = tomb.pos.getRangeTo(this)
                        this.memory.targetID = tomb.id;
                        return;
                    }
                    var ruin = this.pos.findClosestByRange(FIND_RUINS, {
                        filter: (ruin) => {
                            return (ruin.store.getUsedCapacity() > 300 || ruin.store.getUsedCapacity() > creep_FreeCapacity);
                        }
                    });
                    if (ruin && ruin.pos.getRangeTo(this) < range) {
                        // range = ruin.pos.getRangeTo(this)
                        this.memory.targetID = ruin.id;
                        return;
                    }
                    var container = this.pos.findClosestByRange(FIND_STRUCTURES, {
                        filter: (stru) => {
                            return stru.structureType == 'container' &&
                                (stru.store.getUsedCapacity() > 1800 || stru.store.getUsedCapacity() > creep_FreeCapacity);
                        }
                    });
                    if (container) {
                        this.memory.targetID = container.id;
                    }
                }
                else {
                    var target = Game.getObjectById(this.memory.targetID);
                    if (!target) {
                        delete this.memory.targetID;
                        return;
                    }
                    if (!this.pos.isNearTo(target)) {
                        // this.goTo(target.pos, 1, null, 4)
                        this.moveTo(target, { visualizePathStyle: { stroke: colors$2.rose } });
                    }
                    if (target instanceof Resource) {
                        this.pickup(target);
                    }
                    else {
                        if (target.store.getUsedCapacity() < 300 && target.store.getUsedCapacity('energy') == target.store.getUsedCapacity()) {
                            delete this.memory.targetID;
                            return;
                        }
                        if (Object.keys(target.store).length > 0) {
                            for (const r in target.store) {
                                if (target.store[r] > 0) {
                                    this.withdraw(target, r);
                                }
                            }
                        }
                        else {
                            delete this.memory.targetID;
                        }
                    }
                }
            }
        }
        else if (this.memory.role == 'out-defend') {
            this.memory.crossLevel = 11;
            var heal_state = false;
            if (this.hits < this.hitsMax)
                heal_state = true;
            if (this.room.name != creepMission.disRoom) {
                // this.goTo(new RoomPosition(25, 25, creepMission.disRoom), 20)
                this.moveTo(new RoomPosition(25, 25, creepMission.disRoom), { range: 20, visualizePathStyle: { stroke: colors$2.slate } });
                if (heal_state) {
                    this.heal(this);
                }
            }
            else {
                if (globalMission.Data.state == 2) {
                    if (heal_state) {
                        this.heal(this);
                    }
                    let wounded = this.pos.findClosestByRange(FIND_MY_CREEPS, {
                        filter: (creep) => {
                            return creep.hits < creep.hitsMax && creep != this;
                        }
                    });
                    if (wounded) {
                        if (!this.pos.isNearTo(wounded)) {
                            // this.goTo(wounded.pos, 1)
                            this.moveTo(wounded, { range: 1, visualizePathStyle: { stroke: colors$2.emerald } });
                        }
                        this.heal(wounded);
                    }
                    else {
                        let wounded_isNearTo = this.pos.findInRange(FIND_MY_CREEPS, 1, {
                            filter: (creep) => {
                                return creep.hits < creep.hitsMax && creep != this;
                            }
                        });
                        this.heal(wounded_isNearTo[0]);
                    }
                    if ((Game.time - global.Gtime[this.memory.belong]) % 7 && !this.memory.targetID) {
                        return;
                    }
                }
                if (!this.memory.targetID) {
                    var enemy = this.pos.findClosestByPath(FIND_HOSTILE_CREEPS, {
                        filter: (creep) => {
                            return !isInArray(Memory.whitesheet, creep.owner.username);
                        }
                    });
                    if (enemy) {
                        this.memory.targetID = enemy.id;
                        return;
                    }
                    else {
                        var InvaderCore = this.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES, {
                            filter: (stru) => {
                                return stru.structureType == STRUCTURE_INVADER_CORE;
                            }
                        });
                        if (InvaderCore) {
                            this.memory.targetID = InvaderCore.id;
                            return;
                        }
                    }
                }
                else {
                    var atkTarget = Game.getObjectById(this.memory.targetID);
                    if (!atkTarget) {
                        delete this.memory.targetID;
                        return;
                    }
                    if (atkTarget instanceof Creep) {
                        /*判定是否相邻*/
                        if (this.pos.isNearTo(atkTarget)) {
                            this.attack(atkTarget);
                            this.rangedMassAttack();
                        }
                        else {
                            if ((atkTarget.owner.username == 'Invader') || (atkTarget.getActiveBodyparts(ATTACK) == 0 && atkTarget.getActiveBodyparts(RANGED_ATTACK) == 0)) {
                                // this.goTo(atkTarget.pos, 1)
                                this.moveTo(atkTarget, { range: 1, visualizePathStyle: { stroke: colors$2.red } });
                            }
                            else {
                                if (heal_state) {
                                    this.Flee(atkTarget.pos, 3);
                                }
                                else {
                                    // this.goTo(atkTarget.pos, 3)
                                    this.moveTo(atkTarget, { range: 3, visualizePathStyle: { stroke: colors$2.red } });
                                }
                            }
                            this.rangedAttack(atkTarget);
                        }
                    }
                    else {
                        this.memory.standed = true;
                        if (!this.pos.isNearTo(atkTarget)) {
                            // this.goTo(atkTarget.pos, 1)
                            this.moveTo(atkTarget, { range: 1, visualizePathStyle: { stroke: colors$2.red } });
                            this.rangedAttack(atkTarget);
                        }
                        else {
                            this.rangedMassAttack();
                            this.attack(atkTarget);
                        }
                    }
                }
                if (heal_state) {
                    this.heal(this);
                }
            }
        }
        else { //攻击keeper
            this.memory.crossLevel = 12;
            var heal_state = false;
            if (this.hits < this.hitsMax)
                heal_state = true;
            if (this.room.name != creepMission.disRoom) {
                // this.goTo(new RoomPosition(25, 25, creepMission.disRoom), 20)
                this.moveTo(new RoomPosition(25, 25, creepMission.disRoom), { range: 20, visualizePathStyle: { stroke: colors$2.slate } });
                if (heal_state) {
                    this.heal(this);
                }
            }
            else {
                //缓存据点id
                if (!globalMission.Data.updatedLairs) {
                    const lairFilter = {
                        filter: (stru) => {
                            return stru.structureType == STRUCTURE_KEEPER_LAIR &&
                                (!globalMission.Data.lairID || !globalMission.Data.lairID.includes(stru.id))
                                && stru.pos.findInRange(FIND_SOURCES, 5).length > 0;
                        }
                    };
                    var hasLair = this.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES, lairFilter);
                    let cnt = 1;
                    while (hasLair && cnt < 4) {
                        if (!globalMission.Data.lairID) {
                            globalMission.Data.lairID = [hasLair.id];
                        }
                        else {
                            globalMission.Data.lairID.push(hasLair.id);
                        }
                        hasLair = hasLair.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES, lairFilter);
                        cnt++;
                    }
                    globalMission.Data.updatedLairs = true;
                    if (globalMission.Data.lairID.length > 0) {
                        globalMission.Data.nextLair = 0;
                    }
                }
                //优先攻击Invader
                if (globalMission.Data.hasInvader) {
                    var enemy = this.pos.findClosestByPath(FIND_HOSTILE_CREEPS, {
                        filter: (c) => {
                            return c.owner.username == 'Invader';
                        }
                    });
                    if (enemy) {
                        this.say(`🔪(${enemy.pos.x},${enemy.pos.y})`);
                        if (this.pos.isNearTo(enemy)) {
                            this.attack(enemy);
                        }
                        else {
                            // this.goTo(enemy.pos, 1)
                            this.moveTo(enemy, { range: 1, visualizePathStyle: { stroke: colors$2.red } });
                        }
                        return;
                    }
                    else {
                        globalMission.Data.hasInvader = false;
                    }
                }
                //寻找敌对爬
                var nextLair = Game.getObjectById(globalMission.Data.lairID[globalMission.Data.nextLair]);
                if (!this.memory.targetID) {
                    var enemies = nextLair.pos.findInRange(FIND_HOSTILE_CREEPS, 7, {
                        filter: (c) => {
                            return c.getActiveBodyparts(ATTACK) > 0 || c.getActiveBodyparts(RANGED_ATTACK) > 0;
                        }
                    });
                    if (enemies.length > 0) {
                        this.memory.targetID = enemies[0].id;
                        if (enemies[0].owner.username == 'Source Keeper') {
                            globalMission.Data.nextLair = (globalMission.Data.nextLair + 1) % globalMission.Data.lairID.length;
                        }
                    }
                    else {
                        delete this.memory.targetID;
                        //空闲时治疗其他爬
                        if (!heal_state) {
                            let wounded = this.pos.findInRange(FIND_MY_CREEPS, 5, {
                                filter: (creep) => {
                                    return creep.hits < creep.hitsMax && creep != this;
                                }
                            });
                            if (wounded.length > 0) {
                                if (!this.pos.isNearTo(wounded[0])) {
                                    // this.goTo(wounded[0].pos, 1)
                                    this.moveTo(wounded[0], { range: 1, visualizePathStyle: { stroke: colors$2.emerald } });
                                    this.rangedHeal(wounded[0]);
                                }
                                else {
                                    this.heal(wounded[0]);
                                }
                                return;
                            }
                        }
                        else {
                            this.heal(this);
                        }
                        //没事情干就到下一个据点
                        this.say(`🚨(${nextLair.pos.x},${nextLair.pos.y})`);
                        // this.goTo(nextLair.pos, 1, 800, 2)
                        this.moveTo(nextLair, { range: 1, visualizePathStyle: { stroke: colors$2.slate } });
                    }
                }
                if (this.memory.targetID) {
                    var enemy = Game.getObjectById(this.memory.targetID);
                    if (enemy) {
                        if (this.pos.isNearTo(enemy)) {
                            this.attack(enemy);
                        }
                        else {
                            if (heal_state) {
                                this.heal(this);
                            }
                            this.say(`⚔️(${enemy.pos.x},${enemy.pos.y})`);
                            // this.goTo(enemy.pos, 1, 800, 2)
                            this.moveTo(enemy, { range: 1, visualizePathStyle: { stroke: colors$2.red } });
                        }
                    }
                    else {
                        delete this.memory.targetID;
                    }
                }
            }
        }
    }
    /* power采集 */
    handle_power() {
        if (!this.memory.notifyWhenAttacked) {
            this.notifyWhenAttacked(false);
            this.memory.notifyWhenAttacked = true;
        }
        var creepMission = this.memory.MissionData.Data;
        var globalMission = Game.rooms[this.memory.belong].GainMission(this.memory.MissionData.id);
        if (!globalMission) {
            this.say("找不到全局任务了！");
            this.memory.MissionData = {};
            return;
        }
        var role = this.memory.role;
        var missonPostion = new RoomPosition(creepMission.x, creepMission.y, creepMission.room);
        if (!missonPostion) {
            this.say("找不到目标地点！");
            return;
        }
        if (role == 'power-attack') {
            this.memory.standed = true;
            /* 先组队 */
            if (!this.memory.double) {
                if (Game.time % 7 == 0) {
                    if (globalMission.CreepBind['power-heal'].bind.length > 0) {
                        for (var c of globalMission.CreepBind['power-heal'].bind) {
                            if (Game.creeps[c] && Game.creeps[c].pos.roomName == this.room.name && !Game.creeps[c].memory.double) {
                                var disCreep = Game.creeps[c];
                                disCreep.memory.double = this.name;
                                this.memory.double = disCreep.name;
                            }
                        }
                    }
                }
                return;
            }
            /* 附件没有治疗虫就等 */
            if (!Game.creeps[this.memory.double]) {
                this.suicide();
                return;
            }
            if (Game.creeps[this.memory.double] && !this.pos.isNearTo(Game.creeps[this.memory.double]) && (!isInArray([0, 49], this.pos.x) && !isInArray([0, 49], this.pos.y)))
                return;
            if (this.fatigue || Game.creeps[this.memory.double].fatigue)
                return;
            if (globalMission.Data.state == 1) {
                /*出击 主动攻击*/
                const h_creeps = this.pos.findInRange(FIND_HOSTILE_CREEPS, 4, {
                    filter: function (object) {
                        return !isInArray(Memory.whitesheet, object.owner.username) && (!isInArray([0, 49], object.pos.x) && !isInArray([0, 49], object.pos.y));
                    }
                });
                if (h_creeps.length > 0) {
                    // console.log("找到攻击目标",h_creeps[0].name)
                    /*搜索拥有攻击组件的爬为优先*/
                    let _creeps_data = null;
                    for (var creep_data of h_creeps) {
                        if (!_creeps_data) {
                            if (creep_data.getActiveBodyparts(ATTACK))
                                _creeps_data = creep_data;
                        }
                    }
                    if (!_creeps_data) {
                        _creeps_data = h_creeps[0];
                    }
                    if (this.pos.isNearTo(_creeps_data)) {
                        this.attack(_creeps_data);
                    }
                    else {
                        this.moveTo(_creeps_data.pos, { range: 1 });
                    }
                    return;
                }
                /* 先寻找powerbank周围的空点，并寻找空点上有没有人 */
                if (!this.pos.isNearTo(missonPostion)) {
                    if (!Game.rooms[missonPostion.roomName]) {
                        this.moveTo(missonPostion, { range: 1 });
                        return;
                    }
                    var harvest_void = missonPostion.getSourceVoid();
                    var active_void = [];
                    for (var v of harvest_void) {
                        var creep_ = v.lookFor(LOOK_CREEPS);
                        if (creep_.length <= 0)
                            active_void.push(v);
                    }
                    if (active_void.length > 0) {
                        this.moveTo(missonPostion, { range: 1 });
                    }
                    else {
                        if (!missonPostion.inRangeTo(this.pos.x, this.pos.y, 3))
                            this.moveTo(missonPostion, { range: 3 });
                        else {
                            if (Game.time % 10 == 0) {
                                var powerbank_ = missonPostion.GetStructure('powerBank');
                                if (powerbank_) {
                                    var enemy_creep = powerbank_.pos.findInRange(FIND_HOSTILE_CREEPS, 3);
                                    if (enemy_creep.length > 0 && powerbank_ && powerbank_.hits < 600000) {
                                        globalMission.Data.state = 2;
                                    }
                                }
                            }
                        }
                    }
                }
                else {
                    /* 这是被攻击了 */
                    // if (this.hits < 1000) {
                    //     /* 被攻击停止所有爬虫生产 */
                    //     globalMission.CreepBind['power-attack'].num = 0
                    //     globalMission.CreepBind['power-heal'].num = 0
                    //     let hostileCreep = this.pos.findClosestByRange(FIND_HOSTILE_CREEPS)
                    //     Game.notify(`[warning] 采集爬虫小队${this.name}遭受${hostileCreep ? hostileCreep.owner.username : "不明"}攻击，地点在${this.room.name}！已经停止该power爬虫孵化！`)
                    //     return
                    // }
                    if (!this.memory.tick)
                        this.memory.tick = this.ticksToLive;
                    if (this.hitsMax - 400 > this.hits) {
                        /*等待治疗*/
                        return;
                    }
                    var powerbank_ = missonPostion.GetStructure('powerBank');
                    if (powerbank_) {
                        this.attack(powerbank_);
                        if ((powerbank_.hits / 600) + 30 > this.ticksToLive) // 快没有生命了就增加爬虫数量，以方便继续采集
                         {
                            /* 填充完毕就这么干 */
                            if (globalMission.CreepBind['power-attack'].num == 2 && globalMission.CreepBind['power-attack'].num == globalMission.CreepBind['power-attack'].bind.length && globalMission.CreepBind['power-heal'].num == globalMission.CreepBind['power-heal'].bind.length) {
                                globalMission.CreepBind['power-attack'].num = 1;
                                globalMission.CreepBind['power-heal'].num = 1;
                                if (globalMission.CreepBind['power-attack'].bind.length < 2)
                                    return;
                            }
                            else {
                                if (this.ticksToLive < (1500 - this.memory.tick + 200)) {
                                    globalMission.CreepBind['power-attack'].num = 2;
                                    globalMission.CreepBind['power-heal'].num = 2;
                                }
                            }
                            /* 新增一层逻辑判断 */
                            if (this.ticksToLive < 40) {
                                globalMission.CreepBind['power-attack'].num = 1;
                                globalMission.CreepBind['power-heal'].num = 1;
                            }
                        }
                        var enemy_creep = powerbank_.pos.findInRange(FIND_HOSTILE_CREEPS, 2);
                        if (enemy_creep.length == 0 && powerbank_.hits < 280000) {
                            globalMission.Data.state = 2;
                        }
                        else if (enemy_creep.length > 0 && powerbank_.hits < 550000) {
                            globalMission.Data.state = 2;
                        }
                    }
                    else {
                        /* 说明过期了，删除任务，自杀 */
                        for (var ii in globalMission.CreepBind)
                            for (var jj of globalMission.CreepBind[ii].bind)
                                Game.creeps[jj].suicide();
                        Game.rooms[this.memory.belong].DeleteMission(globalMission.id);
                    }
                }
            }
            else {
                if (!this.pos.isNearTo(missonPostion)) {
                    this.moveTo(missonPostion, { range: 1 });
                    return;
                }
                /* 没有powerbank说明已经打掉了 */
                var powerbank_ = missonPostion.GetStructure('powerBank');
                if (!powerbank_)
                    this.suicide();
                else
                    this.attack(powerbank_);
            }
        }
        else if (role == 'power-heal') {
            if (!this.memory.double) {
                return;
            }
            if (Game.creeps[this.memory.double]) {
                if (this.hits < this.hitsMax) {
                    this.heal(this);
                }
                if (this.pos.isNearTo(Game.creeps[this.memory.double])) {
                    this.memory.standed = true;
                    if (!this.pos.inRangeTo(missonPostion, 2)) {
                        this.memory.standed = false;
                        if (this.room.name == this.memory.belong)
                            this.moveTo(Game.creeps[this.memory.double].pos, {
                                ignoreRoads: true,
                                maxOps: 200,
                                maxRooms: 1
                            });
                        else
                            this.moveTo(Game.creeps[this.memory.double].pos, {
                                ignoreRoads: true,
                                maxOps: 1000,
                                maxRooms: 4
                            });
                    }
                    if (Game.creeps[this.memory.double].hits < Game.creeps[this.memory.double].hitsMax) {
                        this.heal(Game.creeps[this.memory.double]);
                        return;
                    }
                }
                else {
                    this.moveTo(Game.creeps[this.memory.double].pos, { range: 1 });
                }
            }
            else {
                // if (this.room.name == this.memory.belong) {
                //     var powerbank_ = missonPostion.GetStructure('powerBank')
                //     if (!powerbank_) this.suicide()
                //     if (this.hits < this.hitsMax) {
                //         this.heal(this)
                //         return
                //     }
                // }
                this.suicide();
            }
        }
        else if (role == 'power-carry') {
            if (this.fatigue > 0)
                return;
            this.workstate('power');
            if (!this.memory.working) {
                if (!this.pos.inRangeTo(missonPostion, 5)) {
                    this.moveTo(missonPostion, { range: 5 });
                }
                else {
                    /* 寻找powerbank */
                    var powerbank_ = missonPostion.GetStructure('powerBank');
                    if (powerbank_) {
                        if (this.pos.inRangeTo(powerbank_, 4)) {
                            this.memory.dontPullMe = true;
                        }
                        else {
                            this.moveTo(missonPostion, { range: 4 });
                        }
                        if (!this.memory.standed)
                            this.memory.standed = true;
                    }
                    else {
                        /* 寻找掉落资源 */
                        /* 优先寻找ruin */
                        var ruins = missonPostion.lookFor(LOOK_RUINS);
                        if (ruins.length > 0 && ruins[0].store.getUsedCapacity('power') > 0) {
                            if (this.memory.standed)
                                this.memory.standed = false;
                            if (!this.pos.isNearTo(ruins[0]))
                                this.moveTo(ruins[0].pos, { range: 1 });
                            else
                                this.withdraw(ruins[0], 'power');
                            return;
                        }
                        var drop_power = missonPostion.lookFor(LOOK_RESOURCES);
                        if (drop_power.length > 0) {
                            for (var i of drop_power) {
                                if (i.resourceType == 'power') {
                                    if (this.memory.standed)
                                        this.memory.standed = true;
                                    if (!this.pos.isNearTo(i))
                                        this.moveTo(i.pos, { range: 1 });
                                    else
                                        this.pickup(i);
                                    return;
                                }
                            }
                        }
                        /* 说明没有资源了 */
                        if (this.store.getUsedCapacity('power') > 0)
                            this.memory.working = true;
                        if (ruins.length <= 0 && drop_power.length <= 0 && this.store.getUsedCapacity('power') <= 0) {
                            globalMission.CreepBind['power-carry'].num = 0;
                            this.suicide();
                        }
                    }
                }
            }
            else {
                var storage_ = Game.rooms[this.memory.belong].storage;
                if (!storage_)
                    return;
                if (!this.pos.isNearTo(storage_))
                    this.moveTo(storage_.pos, { range: 1 });
                else {
                    this.transfer(storage_, 'power');
                    this.suicide();
                }
            }
        }
    }
    /* deposit采集任务处理 */
    handle_deposit() {
        var _a;
        if (!this.memory.notifyWhenAttacked) {
            this.notifyWhenAttacked(false);
            this.memory.notifyWhenAttacked = true;
        }
        // if (!Game.rooms[this.memory.belong].GainMission(this.memory.MissionData.id)) { this.memory.MissionData = {}; return }
        var creepMission = this.memory.MissionData.Data;
        if (!creepMission)
            return;
        /* 判断是否正在遭受攻击 */
        if (this.hits < this.hitsMax && ((_a = this.memory) === null || _a === void 0 ? void 0 : _a.hitsinjured) < this.hits) {
            this.memory.hitsinjured = this.hits;
            let hcreep = this.pos.findClosestByRange(FIND_HOSTILE_CREEPS);
            Game.notify(`来自${this.memory.belong}的商品爬虫在房间${this.room.name}遭受攻击,攻击者疑似为${hcreep ? hcreep.owner.username : "不明生物"}`);
        }
        let myroom = Game.rooms[this.memory.belong];
        if (this.memory.role == 'deposit-transfer') {
            if (creepMission.creeptime) {
                if (this.ticksToLive <= creepMission.creeptime * 2 && !this.store.getUsedCapacity() && this.pos.roomName == this.memory.belong) {
                    this.suicide();
                    return;
                } /*回传之后不够来回的直接操作自杀*/
                if (this.ticksToLive <= creepMission.creeptime || this.store.getFreeCapacity() < 1) //回家放资源
                 {
                    if (this.store.getUsedCapacity() < 1) {
                        /*没有实际搬运物品*/
                        this.suicide();
                        return;
                    }
                    this.transfer_(myroom.storage ? myroom.storage : myroom.terminal, Object.keys(this.store)[0]);
                    return;
                }
            }
        }
        var missonPostion = new RoomPosition(creepMission.x, creepMission.y, creepMission.room);
        if (!missonPostion) {
            this.say("找不到目标地点！");
            return;
        }
        switch (this.memory.role) {
            case 'deposit-harvest':
                if (!this.memory.standed)
                    this.memory.standed = true;
                /*这里对transfer进行绑定操作*/
                if (this.pos.roomName != creepMission.room) {
                    this.moveTo(missonPostion, { range: 4 });
                    return;
                }
                if (this.pos.roomName == creepMission.room) {
                    if (Game.time % 10 == 0) {
                        if (!this.memory.transfercreep) {
                            var transfercreep = this.pos.findClosestByRange(FIND_MY_CREEPS, {
                                filter: (creep) => {
                                    return creep.memory.role == 'deposit-transfer';
                                }
                            });
                            if (transfercreep) {
                                this.memory.transfercreep = transfercreep.name; /*进行搬运工赋值操作*/
                            }
                        }
                        if (!Game.creeps[this.memory.transfercreep]) {
                            delete this.memory.transfercreep;
                        }
                        else {
                            if (Game.creeps[this.memory.transfercreep].pos.roomName != creepMission.room) {
                                delete this.memory.transfercreep;
                            }
                        }
                        /*地上捡垃圾*/
                        var deposit_ = Game.getObjectById(creepMission.deposit_id);
                        let targets = this.pos.findInRange(FIND_TOMBSTONES, 2, { filter: function (object) { return object.store.getUsedCapacity(deposit_.depositType); } });
                        if (targets.length > 0) {
                            if (this.withdraw(targets[0], deposit_.depositType) == ERR_NOT_IN_RANGE) {
                                this.moveTo(targets[0].pos, { range: 1 });
                            }
                        }
                    }
                }
                if (!Game.creeps[this.memory.transfercreep]) {
                    delete this.memory.transfercreep;
                }
                let User_number = this.store.getUsedCapacity();
                let Free_number = this.store.getFreeCapacity();
                /*检查是否容量已经超过200或者一半*/
                if ((User_number >= 200 || User_number >= Free_number) && this.memory.transfercreep) {
                    if (Game.creeps[this.memory.transfercreep].pos.roomName == this.pos.roomName) {
                        /*这里执行搬运操作*/
                        if (Game.creeps[this.memory.transfercreep].store.getFreeCapacity() > 0) {
                            /*检查是否达到回归时效*/
                            var T_creepMission = Game.creeps[this.memory.transfercreep].memory.MissionData.Data;
                            if (Game.creeps[this.memory.transfercreep].ticksToLive <= T_creepMission.creeptime)
                                return;
                            if (!this.pos.isNearTo(Game.creeps[this.memory.transfercreep])) {
                                Game.creeps[this.memory.transfercreep].moveTo(this.pos, { range: 1 });
                                return;
                            }
                            this.transfer(Game.creeps[this.memory.transfercreep], Object.keys(this.store)[0]);
                            return;
                        }
                    }
                }
                if (Free_number < 1)
                    return;
                if (!deposit_) {
                    var deposit_ = Game.getObjectById(creepMission.deposit_id);
                }
                if (deposit_) {
                    if (!this.pos.isNearTo(missonPostion)) {
                        var harvest_void = missonPostion.getSourceVoid();
                        var active_void = [];
                        for (var v of harvest_void) {
                            var creep_ = v.lookFor(LOOK_CREEPS);
                            if (creep_.length <= 0)
                                active_void.push(v);
                        }
                        if (active_void.length > 0) {
                            this.moveTo(missonPostion, { range: 1, maxOps: 200 });
                        }
                        else {
                            this.moveTo(missonPostion, { range: 3, maxOps: 200 });
                        }
                    }
                    if (!deposit_.cooldown && Free_number > 0) {
                        let harvest_state = this.harvest(deposit_);
                        this.memory.arrive = 1;
                        switch (harvest_state) {
                            case OK:
                                if (!this.memory.tick)
                                    this.memory.tick = this.ticksToLive;
                                break;
                            case ERR_NOT_IN_RANGE:
                                this.moveTo(missonPostion, { range: 1 });
                                break;
                        }
                    }
                }
                else {
                    Game.rooms[this.memory.belong].DeleteMission(this.memory.MissionData.id);
                    return;
                }
                break;
            case 'deposit-transfer':
                if (!this.memory.standed)
                    this.memory.standed = true;
                creepMission.creeptimebool = false; //停止计时
                if (this.pos.roomName == creepMission.room) {
                    if (Game.time % 10 == 0) {
                        /*地上捡垃圾*/
                        var deposit_ = Game.getObjectById(creepMission.deposit_id);
                        if (this.pos.isNearTo(deposit_)) {
                            this.Flee(deposit_.pos, 2);
                        }
                        if (!this.memory.Missionstate && (deposit_ === null || deposit_ === void 0 ? void 0 : deposit_.lastCooldown) > 110) {
                            Game.rooms[this.memory.belong].DeleteMission(this.memory.MissionData.id);
                            this.memory.Missionstate = true;
                        }
                        let targets = this.pos.findInRange(FIND_TOMBSTONES, 3, { filter: function (object) { return object.store.getUsedCapacity(deposit_.depositType); } });
                        if (targets.length > 0) {
                            if (this.withdraw(targets[0], deposit_.depositType) == ERR_NOT_IN_RANGE) {
                                this.moveTo(targets[0].pos, { range: 1 });
                                return;
                            }
                        }
                    }
                    if (!this.pos.inRangeTo(missonPostion, 2)) {
                        this.moveTo(missonPostion, { range: 2, maxOps: 100 });
                    }
                    else {
                        if (!creepMission.creeptime) {
                            /*标记爬的距离信息*/
                            creepMission.creeptime = 1500 - this.ticksToLive + 50;
                        }
                    }
                }
                else {
                    this.moveTo(missonPostion, { range: 2 });
                }
                break;
            default:
                this.workstate(creepMission.rType);
                if (this.memory.working) {
                    var storage_ = Game.rooms[this.memory.belong].storage;
                    if (!storage_)
                        return;
                    if (!this.pos.isNearTo(storage_))
                        this.moveTo(storage_.pos, { range: 1 });
                    else {
                        this.transfer(storage_, creepMission.rType);
                        Game.rooms[this.memory.belong].DeleteMission(this.memory.MissionData.id);
                        this.suicide();
                    }
                }
                else {
                    var missonPostion = new RoomPosition(creepMission.x, creepMission.y, creepMission.room);
                    if (!missonPostion) {
                        this.say("找不到目标地点！");
                        return;
                    }
                    if (!this.pos.isNearTo(missonPostion)) {
                        if (!Game.rooms[missonPostion.roomName]) {
                            this.moveTo(missonPostion, { range: 1 });
                            return;
                        }
                        var harvest_void = missonPostion.getSourceVoid();
                        var active_void = [];
                        for (var v of harvest_void) {
                            var creep_ = v.lookFor(LOOK_CREEPS);
                            if (creep_.length <= 0)
                                active_void.push(v);
                        }
                        if (active_void.length > 0) {
                            this.moveTo(missonPostion, { range: 1 });
                        }
                        else {
                            if (!missonPostion.inRangeTo(this.pos.x, this.pos.y, 3))
                                this.moveTo(missonPostion, { range: 3 });
                        }
                    }
                    else {
                        if (!this.memory.tick)
                            this.memory.tick = this.ticksToLive;
                        if (this.ticksToLive < (1500 - (this.memory.tick ? this.memory.tick : 1000) + 70) && this.store.getUsedCapacity(creepMission.rType) > 0) {
                            this.memory.working = true;
                        }
                        /* 开始采集 */
                        var deposit_ = missonPostion.lookFor(LOOK_DEPOSITS)[0];
                        if (deposit_) {
                            if (!deposit_.cooldown) {
                                this.harvest(deposit_);
                            }
                        }
                        else {
                            Game.rooms[this.memory.belong].DeleteMission(this.memory.MissionData.id);
                            return;
                        }
                    }
                }
                break;
        }
    }
}

/* 战争相关 "基础设施" */
/* -------------------------------战争信息获取及更新区------------------------------------ */
// 获取所有房间内的敌对爬虫
function getAllEnemy(room) {
    if (!room)
        return [];
    let enemy = room.find(FIND_CREEPS, {
        filter: (creep) => {
            return !isInArray(Memory.whitesheet, creep.owner.username);
        }
    });
    return enemy;
}
// 获取所有房间内的旗帜
function getAllFlag(room) {
    if (!room)
        return [];
    let flag = room.find(FIND_FLAGS);
    return flag;
}
// 获取所有房间内的建筑 不包含road controller container
function getAllStructure(room) {
    if (!room)
        return [];
    let structues = room.find(FIND_STRUCTURES, {
        filter: (stru) => {
            return !isInArray([STRUCTURE_CONTAINER, STRUCTURE_ROAD, STRUCTURE_CONTROLLER], stru.structureType);
        }
    });
    return structues;
}
// 返回分类建筑对象
function classifyStructure(stru) {
    if (!stru || stru.length <= 0)
        return {};
    let result = {};
    for (var i of stru) {
        if (!result[i.structureType])
            result[i.structureType] = [];
        result[i.structureType].push(i);
    }
    return result;
}
// 获取房间内的防御塔数据
function getTowerData(room) {
    if (!room)
        return {};
    let towers = room.find(FIND_STRUCTURES, {
        filter: (stru) => {
            return stru.structureType == 'tower';
        }
    });
    if (towers.length <= 0)
        return {};
    let terrianData = room.getTerrain();
    let tempData = {};
    let mask_wall = [];
    for (let i = 0; i < 50; i++) {
        for (let j = 0; j < 50; j++) {
            let thisPos = new RoomPosition(i, j, room.name);
            // 0 平原 1 墙壁 2 沼泽
            let _terrianData = terrianData.get(i, j);
            if (_terrianData == 1) {
                mask_wall.push(thisPos);
                continue;
            }
            let avoid = 0;
            if (_terrianData == TERRAIN_MASK_SWAMP) {
                avoid = 20;
            }
            let tempNum = { attack: 0, heal: 0, repair: 0, avoid: avoid };
            for (var t of towers) {
                // 伤害计算叠加
                thisPos.AddTowerRangeData(t, tempNum);
            }
            tempData[`${thisPos.x}/${thisPos.y}`] = tempNum;
        }
    }
    var excludemaskwall_list = {};
    // console.log(JSON.stringify(mask_wall))
    // console.log(JSON.stringify(tempData))
    for (let i = 0; i < mask_wall.length; i++) {
        excludemaskwall_list = Excludemaskwall(excludemaskwall_list, mask_wall[i]);
    }
    //检查房间的出口信息
    let find_exit = room.find(FIND_EXIT);
    for (let exit_data of find_exit) {
        excludemaskwall_list = Excludemaskwall(excludemaskwall_list, exit_data, -10);
    }
    for (let audit in excludemaskwall_list) {
        // let auditdata = excludemaskwall_list[audit]
        let posXY = unzipXandY(audit);
        let auditnumber = 0;
        let swampnumber = 0;
        for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
                let _terrianData = terrianData.get(posXY[0] + i, posXY[1] + j);
                if (_terrianData == 1) {
                    auditnumber++;
                }
                else if (_terrianData == 2) {
                    swampnumber++;
                }
            }
        }
        if (auditnumber + swampnumber < 3) {
            excludemaskwall_list[audit] = 0;
        }
    }
    // console.log(JSON.stringify(find_exit))
    // console.log(JSON.stringify(excludemaskwall_list))
    for (let Data in excludemaskwall_list) {
        if (tempData[Data]) {
            if (excludemaskwall_list[Data] > tempData[Data].avoid)
                tempData[Data].avoid = excludemaskwall_list[Data];
        }
    }
    return tempData;
}
function Excludemaskwall(excludemaskwall_list, pos, number = 5) {
    for (let i = -1; i <= 1; i++) {
        for (let j = -1; j <= 1; j++) {
            if (i == 0 && j == 0)
                continue;
            let x = pos.x + i;
            let y = pos.y + j;
            let _pos = `${x}/${y}`;
            if (!excludemaskwall_list[_pos]) {
                excludemaskwall_list[_pos] = 0;
            }
            excludemaskwall_list[_pos] += number;
            // if (excludemaskwall_list[_pos] < number) {
            //     excludemaskwall_list[_pos] = 10;
            // }
        }
    }
    return excludemaskwall_list;
}
function cloneObj(obj) {
    var newObj = {};
    if (obj instanceof Array) {
        newObj = [];
    }
    for (var key in obj) {
        var val = obj[key];
        newObj[key] = typeof val === 'object' ? cloneObj(val) : val;
    }
    return newObj;
}
// 整合房间内的所有伤害数据和塔数据获得一个总伤害
function getAllhurt(room) {
    if (!room)
        return {};
    var enemy = cloneObj(global.warData.tower[room.name].data);
    // for (let pos in global.warData.tower[room.name].data) {
    //     enemy[pos] = global.warData.tower[room.name].data[pos]
    // }
    // var enemy = global.warData.tower[room.name].data.fillter(function (item, index, arr) {
    //     return arr.indexOf(item) != -1
    // })
    let system_boost = {
        'UH': 1,
        'KO': 1,
        'UH2O': 2,
        'KHO2': 2,
        'XUH2O': 3,
        'XKHO2': 3
    };
    for (let i in global.warData.enemy[room.name].data) {
        /*检查爬的部位信息*/
        let creep = global.warData.enemy[room.name].data[i];
        // console.log('开始检查', creep.name)
        let attcak_body = 0;
        let ranged_attcak_body = 0;
        for (let body of creep.body) {
            let boost_num = 1;
            if (body.boost) {
                boost_num += system_boost[body.boost];
            }
            switch (body.type) {
                case 'attack':
                    attcak_body += boost_num;
                    break;
                case 'ranged_attack':
                    ranged_attcak_body += boost_num;
                    break;
            }
        }
        /*完成部位统计进行具体伤害的结算*/
        if (attcak_body > 0) {
            // console.log('搜索到attcak')
            /*获取有效范围同时进行伤害标记*/
            let get_Updatehurt = Updatehurt(creep.pos, 1, attcak_body * 30);
            for (let key in get_Updatehurt) {
                if (enemy[key]) {
                    // console.log('数据更新', key, enemy[key]['attack'], global.warData.tower[room.name].data[key]['attack'], get_Updatehurt[key])
                    enemy[key]['attack'] += get_Updatehurt[key];
                }
            }
        }
        if (ranged_attcak_body > 0) {
            // console.log('搜索到ranged_attcak')
            let get_Updatehurt = Updatehurt(creep.pos, 3, attcak_body * 10);
            for (let key in get_Updatehurt) {
                if (enemy[key]) {
                    enemy[key]['attack'] += get_Updatehurt[key];
                }
            }
        }
    }
    return enemy;
}
function Updatehurt(pos, range, hurt) {
    var a = -range;
    let _roomlist = {};
    for (var i = a; i <= range; i++) {
        for (var ii = a; ii <= range; ii++) {
            // console.log(i, ii)
            /*检查具体的距离*/
            let m_range = Math.max(Math.abs(i), Math.abs(ii));
            /*出坐标信息*/
            let x = pos.x + i;
            let y = pos.y + ii;
            let pos_ = `${x}/${y}`;
            if (!global.warData.tower[pos.roomName].data[pos_]) {
                continue;
            }
            // console.log(pos_, '更新伤害', JSON.stringify(this[pos_]))
            switch (m_range) {
                case 1:
                    _roomlist[pos_] = hurt;
                    break;
                case 2:
                    _roomlist[pos_] = hurt * 0.4;
                    break;
                case 3:
                    _roomlist[pos_] = hurt * 0.1;
                    break;
            }
        }
    }
    return _roomlist;
}
/* 更新敌对爬虫列表 每tick更新1次 */
function warUpdateEnemy(room) {
    if (!room)
        return;
    if (!global.warData.enemy)
        global.warData.enemy = {};
    if (!global.warData.enemy[room.name])
        global.warData.enemy[room.name] = { time: Game.time, data: getAllEnemy(room) };
    if (Game.time == global.warData.enemy[room.name].time)
        return; // 跳过
    else // 说明数据过时了，更新数据
     {
        global.warData.enemy[room.name].time = Game.time;
        global.warData.enemy[room.name].data = getAllEnemy(room);
    }
}
/* 更新建筑物列表 将建筑物分类 每tick更新1次*/
function warUpdateStructure(room) {
    if (!room)
        return;
    if (!global.warData.structure)
        global.warData.structure = {};
    if (!global.warData.structure[room.name])
        global.warData.structure[room.name] = { time: Game.time, data: classifyStructure(getAllStructure(room)) };
    if (Game.time == global.warData.structure[room.name].time)
        return; // 跳过
    else // 说明数据过时了，更新数据
     {
        global.warData.structure[room.name].time = Game.time;
        global.warData.structure[room.name].data = classifyStructure(getAllStructure(room));
    }
}
/* 更新旗帜列表 每tick更新1次 */
function warUpdateFlag(room) {
    if (!room)
        return;
    if (!global.warData.flag)
        global.warData.flag = {};
    if (!global.warData.flag[room.name])
        global.warData.flag[room.name] = { time: Game.time, data: getAllFlag(room) };
    if (Game.time == global.warData.flag[room.name].time)
        return; // 跳过
    else // 说明数据过时了，更新数据
     {
        global.warData.flag[room.name].time = Game.time;
        global.warData.flag[room.name].data = getAllFlag(room);
    }
}
/* 更新塔伤数据  非每tick刷新 检测到建筑物中tower数量变化才会进行更新 */
function warUpdateTowerData(room) {
    if (!room)
        return;
    if (!global.warData.tower)
        global.warData.tower = {};
    if (!global.warData.tower[room.name])
        global.warData.tower[room.name] = { count: 0, data: {} };
    if (!global.warData.structure || !global.warData.structure[room.name])
        return;
    if (!global.warData.structure[room.name].data || !global.warData.structure[room.name].data['tower'])
        return;
    let length = global.warData.structure[room.name].data['tower'].length;
    if (length != global.warData.tower[room.name].count) {
        global.warData.tower[room.name].count = length;
        global.warData.tower[room.name].data = getTowerData(room);
    }
    return;
}
/*更新塔伤以及爬的合并伤害  每tick更新1次 */
function warUpdateatkData(room) {
    if (!room)
        return;
    if (!global.warData.allhurt)
        global.warData.allhurt = {};
    if (!global.warData.allhurt[room.name])
        global.warData.allhurt[room.name] = { time: Game.time, data: getAllhurt(room) };
    if (Game.time == global.warData.allhurt[room.name].time)
        return; // 跳过
    else // 说明数据过时了，更新数据
     {
        global.warData.allhurt[room.name].time = Game.time;
        global.warData.allhurt[room.name].data = getAllhurt(room);
    }
}
/**
 * 战争信息初始化及更新
 * 所有参与战争的爬虫，在进入目标房间后，应该运行该函数
 * */
function warDataInit(room) {
    // console.log('战争初始化更新')
    if (!global.warData)
        global.warData = {};
    warUpdateEnemy(room);
    warUpdateStructure(room);
    warUpdateFlag(room);
    warUpdateTowerData(room);
    warUpdateatkData(room);
}
/* -------------------------------战争信息二次加工区------------------------------------ */
/*处理排除列表的ram*/
function CheckExcludeRampart(room, pos) {
    if (!room)
        return true;
    if (room.memory.ExcludeRampart.length < 1)
        return true;
    let pos_ = `${pos.x}/${pos.y}`;
    if (isInArray(room.memory.ExcludeRampart, pos_))
        return false;
    return true;
}
function CheckCreepTeam(Creep, enemys) {
    let _C_list = [];
    for (let C of enemys) {
        if (Creep.pos.isNearTo(C)) {
            _C_list.push(C);
        }
    }
    return _C_list;
}
/* 寻找离自己最近的爬虫 range attck为true会搜寻带有攻击部件的爬虫 ram为true会搜寻所在位置没有rampart的爬虫 */
function RangeClosestCreep(pos, creeps, attack, ram) {
    if (!pos)
        return null;
    return pos.findClosestByRange(creeps, {
        filter: (creep) => {
            return (attack ? (creep.getActiveBodyparts('attack') || creep.getActiveBodyparts('ranged_attack')) : 1) &&
                (ram ? !creep.pos.GetStructure('rampart') : 1) &&
                !creep.my;
        }
    });
}
/* 寻找范围内的爬虫 */
function RangeCreep(pos, creeps, range, attack, ram) {
    if (!pos)
        return [];
    return pos.findInRange(creeps, range, {
        filter: (creep) => {
            return (attack ? (creep.getActiveBodyparts('attack') > 0 || creep.getActiveBodyparts('ranged_attack') > 0) : true) &&
                (ram ? !creep.pos.GetStructure('rampart') : true) &&
                !creep.my;
        }
    });
}
/* 寻找离自己最近的旗帜 path name代表旗帜开始的字符 attack为true代表除去旗帜附近range格有攻击性爬虫的旗帜 */
function pathClosestFlag(pos, flags, name, attack, range) {
    if (!pos)
        return null;
    if (attack) {
        if (!Game.rooms[pos.roomName])
            return null;
        if (global.warData.enemy[pos.roomName].time != Game.time)
            return null;
        let creeps = global.warData.enemy[pos.roomName].data;
        return pos.findClosestByPath(flags, {
            filter: (flag) => {
                return flag.pos.roomName == pos.roomName && flag.name.indexOf(name) == 0 && RangeCreep(flag.pos, creeps, range ? range : 3, true).length <= 0;
            }
        });
    }
    return pos.findClosestByPath(flags, {
        filter: (flag) => {
            return flag.pos.roomName == pos.roomName && flag.name.indexOf(name) == 0;
        }
    });
}
/* 寻找离自己最近的建筑 path wall true代表排除wall rampart true代表排除rampart  attack代表不靠近攻击爬虫的 */
function pathClosestStructure(pos, wall, ram, attack, range) {
    if (!pos)
        return null;
    if (!Game.rooms[pos.roomName])
        return null;
    if (!attack) {
        let structures = Game.rooms[pos.roomName].find(FIND_STRUCTURES, {
            filter: (stru) => {
                return !isInArray(["road", "container", 'controller'], stru.structureType) &&
                    (wall ? stru.structureType != "constructedWall" : true) &&
                    (ram ? (stru.structureType != "rampart" || !stru.pos.GetStructure('rampart')) : true) &&
                    (!stru.room.controller ? stru.structureType != STRUCTURE_KEEPER_LAIR : !stru.room.controller.my);
            }
        });
        return pos.findClosestByPath(structures);
    }
    else {
        if (global.warData.enemy[pos.roomName].time != Game.time)
            return null;
        let creeps = global.warData.enemy[pos.roomName].data;
        let structures = Game.rooms[pos.roomName].find(FIND_STRUCTURES, {
            filter: (stru) => {
                return !isInArray(["road", "container", 'controller'], stru.structureType) &&
                    (wall ? stru.structureType != "constructedWall" : true) &&
                    (ram ? (stru.structureType != "rampart" || !stru.pos.GetStructure('rampart')) : true) &&
                    (!stru.room.controller ? stru.structureType != STRUCTURE_KEEPER_LAIR : !stru.room.controller.my);
            }
        });
        let result = pos.findClosestByPath(structures, {
            filter: (stru) => {
                return RangeCreep(stru.pos, creeps, range ? range : 5, true).length <= 0;
            }
        });
        return result;
    }
}
/* 判断是否抵抗的住爬虫的攻击<只适用于单个爬虫>  敌方爬虫 自己的爬虫 防御塔数据(敌方)  返回true代表不会破防*/
function canSustain(creeps, mycreep, towerData) {
    let bodyData = bodypartData(mycreep);
    let toughNum = mycreep.getActiveBodyparts('tough');
    let toughBoostType = null;
    if (creeps.length <= 0)
        return true;
    for (var i of mycreep.body) // 确定boost类型
     {
        if (i.type == 'tough') {
            if (!i.boost) {
                toughBoostType = null;
                break;
            }
            else if (i.boost == 'GO') {
                toughBoostType = 'GO';
                break;
            }
            else if (i.boost == 'GHO2') {
                toughBoostType = 'GHO2';
                break;
            }
            else if (i.boost == 'XGHO2') {
                toughBoostType = 'XGHO2';
                break;
            }
        }
    }
    let myhealData = bodyData['heal'];
    let hurtData = 0;
    // 计算敌方伤害 hurtData是总伤害
    for (var c of creeps) {
        if (c.name == mycreep.name)
            continue;
        let enData = bodypartData(c);
        let hurt = enData['attack'];
        if (enData['ranged_attack'] > hurt)
            hurt = enData['ranged_attack'];
        hurtData += hurt;
    }
    if (towerData)
        hurtData += towerData;
    // mycreep.say(`${hurtData}`)
    // 判断总伤害能否破防
    if (toughNum <= 0) {
        if (hurtData > myhealData)
            return false;
    }
    else {
        if (!toughBoostType) {
            if (hurtData > myhealData)
                return false;
        }
        else if (toughBoostType == 'GO') {
            let hurt = hurtData / 2;
            if (hurt <= toughNum * 100) {
                if (hurt > myhealData)
                    return false;
            }
            else {
                let superfluous = (hurt - toughNum * 100) * 2;
                if (hurt + superfluous > myhealData)
                    return false;
            }
        }
        else if (toughBoostType == 'GHO2') {
            let hurt = hurtData / 3;
            if (hurt <= toughNum * 100) {
                if (hurt > myhealData)
                    return false;
            }
            else {
                let superfluous = (hurt - toughNum * 100) * 3;
                if (hurt + superfluous > myhealData)
                    return false;
            }
        }
        else if (toughBoostType == 'XGHO2') {
            let hurt = hurtData / 4;
            if (hurt <= toughNum * 100) {
                if (hurt > myhealData)
                    return false;
            }
            else {
                let superfluous = (hurt - toughNum * 100) * 4;
                if (hurt + superfluous > myhealData)
                    return false;
            }
        }
    }
    return true;
}

class CreepMissonWarExtension$1 extends Creep {
    // 黄球拆迁
    handle_dismantle() {
        var _a;
        let missionData = this.memory.MissionData;
        let id = missionData.id;
        let data = missionData.Data;
        if (data.boost) {
            if (!this.BoostCheck(['move', 'work']))
                return;
        }
        if (this.room.name != data.disRoom || data.shard != Game.shard.name) {
            this.arriveTo(new RoomPosition(25, 25, data.disRoom), 20, data.shard, data.shardData ? data.shardData : null);
            return;
        }
        this.memory.standed = true;
        // 对方开安全模式情况下 删除任务
        if (this.room.controller && !this.room.controller.my && this.room.controller.safeMode) {
            if (Game.shard.name == this.memory.shard) {
                Game.rooms[this.memory.belong].DeleteMission(id);
            }
            return;
        }
        if ((((_a = this.room.controller) === null || _a === void 0 ? void 0 : _a.my) && this.room.controller.level >= 5)) {
            if (this.hits < this.hitsMax) {
                this.optTower('heal', this, true);
            }
        }
        /* dismantle_0 */
        let disFlag = this.pos.findClosestByPath(FIND_FLAGS, {
            filter: (flag) => {
                return flag.name.indexOf('dismantle') == 0;
            }
        });
        if (!disFlag) {
            var clostStructure = this.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES, {
                filter: (struc) => {
                    return !isInArray(['controller'], struc.structureType);
                }
            });
            if (clostStructure) {
                let randomStr = Math.random().toString(36).substr(3);
                clostStructure.pos.createFlag(`dismantle_${randomStr}`, COLOR_WHITE);
                return;
            }
            else
                return;
        }
        let stru = disFlag.pos.lookFor(LOOK_STRUCTURES)[0];
        if (stru) {
            if (this.dismantle(stru) == ERR_NOT_IN_RANGE) {
                this.goTo(stru.pos, 1);
                return;
            }
        }
        else {
            disFlag.remove();
        }
    }
    // 控制攻击
    handle_control() {
        let missionData = this.memory.MissionData;
        let id = missionData.id;
        let data = missionData.Data;
        if (this.room.name != data.disRoom || Game.shard.name != data.shard) {
            this.arriveTo(new RoomPosition(24, 24, data.disRoom), 23, data.shard, data.shardData ? data.shardData : null);
        }
        else {
            // 对方开安全模式情况下 删除任务
            if (this.room.controller && this.room.controller.safeMode) {
                if (Game.shard.name == this.memory.shard) {
                    Game.rooms[this.memory.belong].DeleteMission(id);
                }
                return;
            }
            let control = this.room.controller;
            if (control.level < 1) {
                /*完成攻击任务删除*/
                if (Game.shard.name == this.memory.shard) {
                    // console.log('完成攻击',this.memory.taskRB)
                    Game.rooms[this.memory.belong].DeleteMission(this.memory.taskRB);
                    // console.log('完成攻击-A')
                }
            }
            if (!this.pos.isNearTo(control))
                this.goTo(control.pos, 1);
            else {
                if (control.owner && !control.my)
                    this.attackController(control);
                // else this.claimController(control)
                else
                    this.reserveController(control);
                if (control.upgradeBlocked > this.ticksToLive)
                    this.suicide();
            }
        }
    }
    Checkaroundhurt(pos, range = 1, hits = 600) {
        // console.log(this.name)
        if (!global.HostileData[this.room.name])
            return true;
        if (!global.HostileData[this.room.name].data)
            return true;
        // console.log(pos,'开始算伤')
        for (let x = pos.x - range; x < pos.x + range; x++) {
            for (let y = pos.y - range; y < pos.y + range; y++) {
                let pos_ = `${x}/${y}`;
                let _atk_data = global.HostileData[this.room.name].data[pos_];
                if (_atk_data) {
                    if (_atk_data.attack + _atk_data.rattack > hits) {
                        // console.log(this.name, _atk_data.attack + _atk_data.rattack, pos_)
                        return true;
                    }
                }
            }
        }
        return false;
    }
    // 红球防御
    handle_defend_attack() {
        if (!this.BoostCheck(['move', 'attack']))
            return;
        this.memory.standed = true;
        if (this.hitsMax - this.hits > 200)
            this.optTower('heal', this);
        this.memory.crossLevel = 16;
        /* 如果周围1格发现敌人，爬虫联合防御塔攻击 */
        // var nearCreep = this.pos.findInRange(FIND_HOSTILE_CREEPS, 1, {
        //     filter: (creep) => {
        //         return !isInArray(Memory.whitesheet, creep.name)
        //     }
        // })
        let nearCreep = this.SearchHostilecreeps(1);
        if (nearCreep) {
            this.attack(nearCreep);
            this.optTower('attack', nearCreep);
        }
        // var nearCreep_A = this.pos.findInRange(FIND_HOSTILE_CREEPS, 1, {
        //     filter: (creep) => {
        //         return !isInArray(Memory.whitesheet, creep.name)
        //     }
        // })
        // if(nearCreep_A.length>0)
        // {
        //     this.attack(nearCreep_A[0])
        //     this.optTower('attack', nearCreep_A[0])
        //     return;
        // }
        /* 寻路去距离敌对爬虫最近的rampart */
        var hostileCreep = Game.rooms[this.memory.belong].find(FIND_HOSTILE_CREEPS, {
            filter: (creep) => {
                return !isInArray(Memory.whitesheet, creep.name);
            }
        });
        if (hostileCreep.length > 0) {
            let hostileCreep_atk = this.hostileCreep_atk(hostileCreep);
            for (var c of hostileCreep) {
                /* 如果发现Hits/hitsMax低于百分之80的爬虫，直接防御塔攻击 */
                if (c.hits / c.hitsMax <= 0.8)
                    this.optTower('attack', c);
            }
            if (Number(hostileCreep_atk) < 600 && this.room.controller.level >= 8) {
                // this.goTo(hostileCreep[0], 0)
                if (Game.flags['TowerVisualWar']) {
                    this.room.visual.line(this.pos, hostileCreep[0].pos, { color: 'red', lineStyle: 'dashed' });
                }
                this.goTo_defend(hostileCreep[0].pos, 0);
                let attack_state = this.attack(hostileCreep[0]);
                if (attack_state == OK) {
                    this.optTower('attack', hostileCreep[0]);
                }
                return;
            }
        }
        // 以gather_attack开头的旗帜  例如： defend_attack_0 优先前往该旗帜附近
        let gatherFlag = this.pos.findClosestByPath(FIND_FLAGS, {
            filter: (flag) => {
                return flag.name.indexOf('defend_attack') == 0;
            }
        });
        if (gatherFlag) {
            this.goTo(gatherFlag.pos, 0);
            return;
        }
        if (!Game.rooms[this.memory.belong].memory.enemy[this.name])
            Game.rooms[this.memory.belong].memory.enemy[this.name] = [];
        if (Game.rooms[this.memory.belong].memory.enemy[this.name].length <= 0) {
            /* 领取敌对爬虫 */
            let creeps_ = [];
            for (var creep of hostileCreep) {
                /* 判断一下该爬虫的id是否存在于其他爬虫的分配里了 */
                if (this.isInDefend(creep))
                    continue;
                else {
                    creeps_.push(creep);
                }
            }
            if (creeps_.length > 0) {
                let highestAim = creeps_[0];
                for (var i of creeps_) {
                    if (parts(i, 'attack') || parts(i, 'work')) {
                        highestAim = i;
                        break;
                    }
                }
                Game.rooms[this.memory.belong].memory.enemy[this.name].push(highestAim.id);
                /* 方便识别小队，把周围的爬也放进去 【如果本来不是小队但暂时在周围的，后续爬虫会自动更新】 */
                let nearHCreep = highestAim.pos.findInRange(FIND_HOSTILE_CREEPS, 1, {
                    filter: (creep) => {
                        return !isInArray(Memory.whitesheet, creep.name) && !this.isInDefend(creep);
                    }
                });
                if (nearHCreep.length > 0)
                    for (var n of nearHCreep)
                        Game.rooms[this.memory.belong].memory.enemy[this.name].push(n.id);
            }
        }
        else {
            let en = Game.getObjectById(Game.rooms[this.memory.belong].memory.Enemydistribution[this.name]);
            if (!isInArray(global.HostileGroup[this.memory.belong], Game.rooms[this.memory.belong].memory.Enemydistribution[this.name])) {
                delete Game.rooms[this.memory.belong].memory.Enemydistribution[this.name];
                en = null;
            }
            if (!en) {
                /*重新进行任务分配*/
                if (Game.rooms[this.memory.belong].memory.Enemydistribution[this.name]) {
                    delete Game.rooms[this.memory.belong].memory.Enemydistribution[this.name];
                }
                for (let ii in Game.rooms[this.memory.belong].memory.Enemydistribution) {
                    if (isInArray(global.HostileGroup[this.memory.belong], Game.rooms[this.memory.belong].memory.Enemydistribution[ii])) {
                        var index = global.HostileGroup[this.memory.belong].indexOf(Game.rooms[this.memory.belong].memory.Enemydistribution[ii]);
                        global.HostileGroup[this.memory.belong].splice(index, 1);
                    }
                }
                console.log('待分配', global.HostileGroup[this.memory.belong].length);
                if (global.HostileGroup[this.memory.belong].length > 0) {
                    var HostileGroupnearstram = this.pos.findClosestByRange(FIND_HOSTILE_CREEPS, {
                        filter: (stru) => {
                            return isInArray(global.HostileGroup[this.memory.belong], stru.id);
                        }
                    });
                    console.log(this.name, '分配', HostileGroupnearstram.id);
                    Game.rooms[this.memory.belong].memory.Enemydistribution[this.name] = HostileGroupnearstram.id;
                    en = Game.getObjectById(Game.rooms[this.memory.belong].memory.Enemydistribution[this.name]);
                }
            }
            if (en) {
                let nstC = en;
                if (nstC) {
                    // 寻找最近的爬距离最近的rampart,去那里呆着
                    var nearstram = nstC.pos.findClosestByRange(FIND_MY_STRUCTURES, {
                        filter: (stru) => {
                            return (stru.structureType == 'rampart' && stru.pos.GetStructureList(['extension', 'link', 'observer', 'tower', 'controller', 'extractor']).length <= 0 && (stru.pos.lookFor(LOOK_CREEPS).length <= 0 || stru.pos.lookFor(LOOK_CREEPS)[0] == this) && CheckExcludeRampart(this.room, stru.pos));
                        }
                    });
                    if (nearstram) {
                        if (Game.flags['TowerVisualWar']) {
                            this.room.visual.line(this.pos, nearstram.pos, { color: 'red', lineStyle: 'dashed' });
                            this.room.visual.line(nearstram.pos, nstC.pos, { color: 'green', lineStyle: 'dashed' });
                        }
                        /*检查当前范围可能受到的伤害如果不会超过600则追出去*/
                        if (this.Checkaroundhurt(this.pos, 2, 400) || this.Checkaroundhurt(nstC.pos, 2, 400) || this.hitsMax - 1200 > this.hits) {
                            // console.log(this.name, '不满足追踪条件')
                            this.goTo_defend(nearstram.pos, 0);
                        }
                        else {
                            console.log(this.name, '满足伤害要求|追出去');
                            this.goTo_defend(nstC.pos, 0);
                        }
                        // this.goTo_defend(nearstram.pos, 0)
                        /*如果对应的爬不在3的范围内则进行删除操作*/
                        // if (!nearstram.pos.inRangeTo(nstC,2)) {
                        //     // console.log(this.name, '放弃当前目标', nstC.name)
                        //     Game.rooms[this.memory.belong].memory.enemy[this.name].splice(0, 1)
                        // }
                    }
                    else
                        this.moveTo(nstC.pos);
                }
                else {
                    console.log('没有ram');
                    var ramp = this.pos.findClosestByRange(FIND_MY_STRUCTURES, {
                        filter: (stru) => {
                            return stru.structureType == 'rampart' && stru.pos.GetStructureList(['extension', 'link', 'observer', 'tower', 'controller', 'extractor']).length <= 0 && CheckExcludeRampart(this.room, stru.pos);
                        }
                    });
                    console.log(ramp);
                    if (this.pos.inRangeTo(ramp, 3) && !this.pos.isEqualTo(ramp)) {
                        this.moveTo(ramp.pos);
                    }
                }
            }
            else {
                console.log(this.name, '分配已饱和');
                if (this.room.memory.DefendDouId) {
                    let DefendDou = Game.getObjectById(this.room.memory.DefendDouId);
                    if (DefendDou || !this.Checkaroundhurt(DefendDou.pos, 2, 400)) {
                        console.log(this.name, '分配已饱和|追出去');
                        this.goTo_defend(DefendDou.pos, 0);
                    }
                }
            }
            // let en = Game.getObjectById(Game.rooms[this.memory.belong].memory.enemy[this.name][0]) as Creep
            // if (!en) {
            //     Game.rooms[this.memory.belong].memory.enemy[this.name].splice(0, 1)
            //     return
            // }
            // let nstC = en
            // // 查找是否是小队爬, 发现不是小队爬就删除
            // if (Game.rooms[this.memory.belong].memory.enemy[this.name].length > 1) {
            //     B:
            //     for (var id of Game.rooms[this.memory.belong].memory.enemy[this.name]) {
            //         let idCreep = Game.getObjectById(id) as Creep
            //         if (!idCreep) continue B
            //         if (Game.time % 10 == 0)    // 防止敌方爬虫bug
            //             if (Math.abs(idCreep.pos.x - en.pos.x) >= 2 || Math.abs(idCreep.pos.y - en.pos.y) >= 2) {
            //                 let index = Game.rooms[this.memory.belong].memory.enemy[this.name].indexOf(id)
            //                 Game.rooms[this.memory.belong].memory.enemy[this.name].splice(index, 1)
            //                 continue B
            //             }
            //         if (getDistance(this.pos, idCreep.pos) < getDistance(this.pos, nstC.pos))
            //             nstC = idCreep
            //     }
            // }
            // if (nstC) {
            //     // 寻找最近的爬距离最近的rampart,去那里呆着
            //     var nearstram = nstC.pos.findClosestByRange(FIND_MY_STRUCTURES, {
            //         filter: (stru) => {
            //             return (stru.structureType == 'rampart' && stru.pos.GetStructureList(['extension', 'link', 'observer', 'tower', 'controller', 'extractor']).length <= 0 && (stru.pos.lookFor(LOOK_CREEPS).length <= 0 || stru.pos.lookFor(LOOK_CREEPS)[0] == this) && CheckExcludeRampart(this.room, stru.pos))
            //         }
            //     })
            //     if (nearstram) {
            //         if (Game.flags['TowerVisualWar']) {
            //             this.room.visual.line(this.pos, nearstram.pos,
            //                 { color: 'red', lineStyle: 'dashed' });
            //             this.room.visual.line(nearstram.pos, nstC.pos,
            //                 { color: 'green', lineStyle: 'dashed' });
            //         }
            //         this.goTo_defend(nearstram.pos, 0)
            //         /*如果对应的爬不在3的范围内则进行删除操作*/
            //         // if (!nearstram.pos.inRangeTo(nstC,2)) {
            //         //     // console.log(this.name, '放弃当前目标', nstC.name)
            //         //     Game.rooms[this.memory.belong].memory.enemy[this.name].splice(0, 1)
            //         // }
            //     }
            //     else this.moveTo(nstC.pos)
            // } else {
            //     console.log('没有ram')
            //     var ramp = this.pos.findClosestByRange(FIND_MY_STRUCTURES, {
            //         filter: (stru) => {
            //             return stru.structureType == 'rampart' && stru.pos.GetStructureList(['extension', 'link', 'observer', 'tower', 'controller', 'extractor']).length <= 0 && CheckExcludeRampart(this.room, stru.pos)
            //         }
            //     })
            //     console.log(ramp)
            //     if (this.pos.inRangeTo(ramp, 3) && !this.pos.isEqualTo(ramp)) {
            //         this.moveTo(ramp.pos)
            //     }
            // }
        }
        // 仍然没有说明主动防御已经饱和
        if (Game.rooms[this.memory.belong].memory.enemy[this.name].length <= 0) {
            this.say("🔍");
            var closestCreep = this.pos.findClosestByRange(FIND_HOSTILE_CREEPS, {
                filter: (creep) => {
                    return !isInArray(Memory.whitesheet, creep.name);
                }
            });
            if (closestCreep && !this.pos.inRangeTo(closestCreep.pos, 2)) {
                /* 找离虫子最近的rampart */
                var nearstram = closestCreep.pos.findClosestByRange(FIND_MY_STRUCTURES, {
                    filter: (stru) => {
                        return stru.structureType == 'rampart' && stru.pos.GetStructureList(['extension', 'link', 'observer', 'tower', 'controller', 'extractor']).length <= 0 && (stru.pos.lookFor(LOOK_CREEPS).length <= 0 || stru.pos.lookFor(LOOK_CREEPS)[0] == this) && CheckExcludeRampart(this.room, stru.pos);
                    }
                });
                if (nearstram) {
                    if (Game.flags['TowerVisualWar']) {
                        this.room.visual.line(this.pos, nearstram.pos, { color: 'red', lineStyle: 'dashed' });
                    }
                    this.goTo_defend(nearstram.pos, 0);
                }
            }
            else {
                var nearstram = this.pos.findClosestByRange(FIND_MY_STRUCTURES, {
                    filter: (stru) => {
                        return stru.structureType == 'rampart' && stru.pos.GetStructureList(['extension', 'link', 'observer', 'tower', 'controller', 'extractor']).length <= 0 && (stru.pos.lookFor(LOOK_CREEPS).length <= 0 || stru.pos.lookFor(LOOK_CREEPS)[0] == this) && CheckExcludeRampart(this.room, stru.pos);
                    }
                });
                if (nearstram) {
                    if (Game.flags['TowerVisualWar']) {
                        this.room.visual.line(this.pos, nearstram.pos, { color: 'aqua', lineStyle: 'dashed' });
                    }
                    this.goTo_defend(nearstram.pos, 0);
                }
            }
            /*检查是否有相邻的敌对目标。进行进攻*/
            var adjoinCreep = this.pos.findInRange(FIND_HOSTILE_CREEPS, 1, {
                filter: (creep) => {
                    return !isInArray(Memory.whitesheet, creep.name);
                }
            });
            if (adjoinCreep.length > 0) {
                console.log(this.name, '攻击相邻', adjoinCreep[0].name);
                this.attack(adjoinCreep[0]);
            }
        }
        if (this.pos.x >= 48 || this.pos.x <= 1 || this.pos.y >= 48 || this.pos.y <= 1) {
            this.moveTo(new RoomPosition(Memory.RoomControlData[this.memory.belong].center[0], Memory.RoomControlData[this.memory.belong].center[1], this.memory.belong));
        }
    }
    // 蓝球防御
    handle_defend_range() {
        if (!this.BoostCheck(['move', 'ranged_attack']))
            return;
        this.memory.crossLevel = 15;
        if (this.hitsMax - this.hits > 200)
            this.optTower('heal', this);
        /* 如果周围1格发现敌人，爬虫联合防御塔攻击 */
        var nearCreep = this.pos.findInRange(FIND_HOSTILE_CREEPS, 3, {
            filter: (creep) => {
                return !isInArray(Memory.whitesheet, creep.name);
            }
        });
        if (nearCreep.length > 0) {
            var nearstCreep = this.pos.findInRange(FIND_HOSTILE_CREEPS, 1, {
                filter: (creep) => {
                    return !isInArray(Memory.whitesheet, creep.name);
                }
            });
            if (nearstCreep.length > 0)
                this.rangedMassAttack();
            else
                this.rangedAttack(nearCreep[0]);
            if (Game.time % 4 == 0)
                this.optTower('attack', nearCreep[0]);
        }
        /* 寻路去距离敌对爬虫最近的rampart */
        var hostileCreep = Game.rooms[this.memory.belong].find(FIND_HOSTILE_CREEPS, {
            filter: (creep) => {
                return !isInArray(Memory.whitesheet, creep.name);
            }
        });
        if (hostileCreep.length > 0) {
            for (var c of hostileCreep)
                /* 如果发现Hits/hitsMax低于百分之80的爬虫，直接防御塔攻击 */
                if (c.hits / c.hitsMax <= 0.8)
                    this.optTower('attack', c);
        }
        // 以gather_attack开头的旗帜  例如： defend_range_0 优先前往该旗帜附近
        let gatherFlag = this.pos.findClosestByPath(FIND_FLAGS, {
            filter: (flag) => {
                return flag.name.indexOf('defend_range') == 0;
            }
        });
        if (gatherFlag) {
            this.goTo(gatherFlag.pos, 0);
            return;
        }
        if (!Game.rooms[this.memory.belong].memory.enemy[this.name])
            Game.rooms[this.memory.belong].memory.enemy[this.name] = [];
        if (Game.rooms[this.memory.belong].memory.enemy[this.name].length <= 0) {
            /* 领取敌对爬虫 */
            let creeps_ = [];
            for (var creep of hostileCreep) {
                /* 判断一下该爬虫的id是否存在于其他爬虫的分配里了 */
                if (this.isInDefend(creep))
                    continue;
                else {
                    creeps_.push(creep);
                }
            }
            if (creeps_.length > 0) {
                let highestAim = creeps_[0];
                for (var i of creeps_) {
                    if (parts(i, 'ranged_attack')) {
                        highestAim = i;
                        break;
                    }
                }
                Game.rooms[this.memory.belong].memory.enemy[this.name].push(highestAim.id);
                /* 方便识别小队，把周围的爬也放进去 【如果本来不是小队但暂时在周围的，后续爬虫会自动更新】 */
                let nearHCreep = highestAim.pos.findInRange(FIND_HOSTILE_CREEPS, 1, {
                    filter: (creep) => {
                        return !isInArray(Memory.whitesheet, creep.name) && !this.isInDefend(creep);
                    }
                });
                if (nearHCreep.length > 0)
                    for (var n of nearHCreep)
                        Game.rooms[this.memory.belong].memory.enemy[this.name].push(n.id);
            }
        }
        else {
            let en = Game.getObjectById(Game.rooms[this.memory.belong].memory.enemy[this.name][0]);
            if (!en) {
                Game.rooms[this.memory.belong].memory.enemy[this.name].splice(0, 1);
                return;
            }
            let nstC = en;
            // 查找是否是小队爬, 发现不是小队爬就删除
            if (Game.rooms[this.memory.belong].memory.enemy[this.name].length > 1) {
                B: for (var id of Game.rooms[this.memory.belong].memory.enemy[this.name]) {
                    let idCreep = Game.getObjectById(id);
                    if (!idCreep)
                        continue B;
                    if (Game.time % 10 == 0)
                        if (Math.abs(idCreep.pos.x - en.pos.x) >= 2 || Math.abs(idCreep.pos.y - en.pos.y) >= 2) {
                            let index = Game.rooms[this.memory.belong].memory.enemy[this.name].indexOf(id);
                            Game.rooms[this.memory.belong].memory.enemy[this.name].splice(index, 1);
                            continue B;
                        }
                    if (getDistance(this.pos, idCreep.pos) < getDistance(this.pos, nstC.pos))
                        nstC = idCreep;
                }
            }
            if (nstC) {
                // 寻找最近的爬距离最近的rampart,去那里呆着
                var nearstram = nstC.pos.findClosestByRange(FIND_MY_STRUCTURES, {
                    filter: (stru) => {
                        return stru.structureType == 'rampart' && stru.pos.GetStructureList(['extension', 'link', 'observer', 'tower', 'controller', 'extractor']).length <= 0 && (stru.pos.lookFor(LOOK_CREEPS).length <= 0 || stru.pos.lookFor(LOOK_CREEPS)[0] == this) && CheckExcludeRampart(this.room, stru.pos);
                    }
                });
                if (nearstram)
                    this.goTo_defend(nearstram.pos, 0);
                else
                    this.moveTo(nstC.pos);
            }
            else {
                var ramp = this.pos.findClosestByRange(FIND_MY_STRUCTURES, {
                    filter: (stru) => {
                        return stru.structureType == 'rampart' && stru.pos.GetStructureList(['extension', 'link', 'observer', 'tower', 'controller', 'extractor']).length <= 0 && CheckExcludeRampart(this.room, stru.pos);
                    }
                });
                if (this.pos.inRangeTo(ramp, 3) && !this.pos.isEqualTo(ramp)) {
                    this.moveTo(ramp.pos);
                }
            }
        }
        // 仍然没有说明主动防御已经饱和
        if (Game.rooms[this.memory.belong].memory.enemy[this.name].length <= 0) {
            this.say("🔍");
            var closestCreep = this.pos.findClosestByRange(FIND_HOSTILE_CREEPS, {
                filter: (creep) => {
                    return !isInArray(Memory.whitesheet, creep.name);
                }
            });
            if (closestCreep && !this.pos.inRangeTo(closestCreep.pos, 3)) {
                /* 找离虫子最近的rampart */
                var nearstram = closestCreep.pos.findClosestByRange(FIND_MY_STRUCTURES, {
                    filter: (stru) => {
                        return stru.structureType == 'rampart' && stru.pos.GetStructureList(['extension', 'link', 'observer', 'tower', 'controller', 'extractor']).length <= 0 && (stru.pos.lookFor(LOOK_CREEPS).length <= 0 || stru.pos.lookFor(LOOK_CREEPS)[0] == this) && CheckExcludeRampart(this.room, stru.pos);
                    }
                });
                if (nearstram)
                    this.goTo_defend(nearstram.pos, 0);
            }
        }
        if (this.pos.x >= 48 || this.pos.x <= 1 || this.pos.y >= 48 || this.pos.y <= 1) {
            this.moveTo(new RoomPosition(Memory.RoomControlData[this.memory.belong].center[0], Memory.RoomControlData[this.memory.belong].center[1], this.memory.belong));
        }
    }
    // 双人防御
    handle_defend_double() {
        // let s =Game.cpu.getUsed();
        if (this.memory.role == 'defend-douAttack') {
            if (!this.BoostCheck(['move', 'attack', 'tough']))
                return;
        }
        else {
            if (!this.BoostCheck(['move', 'heal', 'tough']))
                return;
        }
        if (!this.memory.double) {
            if (this.memory.role == 'defend-douHeal') {
                /* 由heal来进行组队 */
                if (Game.time % 7 == 0) {
                    var disCreep = this.pos.findClosestByRange(FIND_MY_CREEPS, {
                        filter: (creep) => {
                            return creep.memory.role == 'defend-douAttack' && !creep.memory.double;
                        }
                    });
                    if (disCreep) {
                        this.memory.double = disCreep.name;
                        disCreep.memory.double = this.name;
                        this.memory.captain = false;
                        disCreep.memory.captain = true;
                    }
                }
                if (!this.memory.double) {
                    if (this.hitsMax - this.hits > 600) {
                        this.optTower('heal', this);
                        this.heal(this);
                    }
                    this.goTo(Game.rooms[this.memory.belong].storage.pos, 1);
                }
            }
            return;
        }
        if (this.memory.role == 'defend-douAttack') {
            if (this.hitsMax - this.hits > 1200)
                this.optTower('heal', this);
            if (!Game.creeps[this.memory.double]) {
                delete this.memory.double;
                return;
            }
            if (this.fatigue || Game.creeps[this.memory.double].fatigue)
                return;
            if (Game.creeps[this.memory.double] && !this.pos.isNearTo(Game.creeps[this.memory.double]) && (!isInArray([0, 49], this.pos.x) && !isInArray([0, 49], this.pos.y))) {
                /*只扫描周围目标进行攻击 不操作移动*/
                let creeps = this.SearchHostilecreeps(1);
                if (creeps) {
                    this.optTower('attack', creeps);
                    this.attack(creeps);
                }
                return;
            }
            /* 确保在自己房间 */
            if (this.room.name != this.memory.belong) {
                this.goTo(new RoomPosition(24, 24, this.memory.belong), 23);
            }
            else {
                let flag = this.pos.findClosestByPath(FIND_FLAGS, {
                    filter: (flag) => {
                        return flag.name.indexOf('defend_double') == 0;
                    }
                });
                if (flag) {
                    let creeps = this.SearchHostilecreeps(1);
                    if (creeps) {
                        this.optTower('attack', creeps);
                        this.attack(creeps);
                    }
                    this.goTo(flag.pos, 0);
                    return;
                }
                let creeps = this.pos.findClosestByRange(FIND_HOSTILE_CREEPS, {
                    filter: (creep) => {
                        return !isInArray(Memory.whitesheet, creep.owner.username) && (!isInArray([0, 49], creep.pos.x) && !isInArray([0, 49], creep.pos.y));
                    }
                });
                if (this.hitsMax - this.hits > 1500 && this.Checkaroundhurt(this.pos, 1, (this.hitsMax - this.hits) / 2)) {
                    console.log(this.name, '逃离');
                    this.Flee(creeps.pos, 3);
                    return;
                }
                /*检查是否存在已经针对的目标信息*/
                if (this.room.memory.DefendDouId) {
                    let DouID = Game.getObjectById(this.room.memory.DefendDouId);
                    if (!DouID) {
                        delete this.room.memory.DefendDouId;
                    }
                    if (DouID) {
                        console.log(this.name, '协同追踪', this.room.memory.DefendDouId);
                        if (DouID && !isInArray([0, 49], DouID.pos.x) && !isInArray([0, 49], DouID.pos.y)) {
                            this.room.visual.line(this.pos, DouID.pos, { color: 'red', lineStyle: 'dashed' });
                            if (this.pos.isNearTo(DouID)) {
                                let s_tet = this.attack(DouID);
                                console.log(this.name, '调度塔一起攻击', s_tet);
                                this.optTower('attack', DouID);
                                // switch () {
                                //     case ERR_NOT_IN_RANGE:
                                //         /*检查周围目标信息*/
                                //         this.goTo(DouID.pos, 1)
                                //         break;
                                //     case OK:
                                //         break;
                                // }
                            }
                            else {
                                let atk_creeps = this.SearchHostilecreeps(1);
                                if (atk_creeps) {
                                    console.log('未达到协防目标,攻击周围', atk_creeps.id);
                                    this.attack(atk_creeps);
                                }
                                this.goTo(DouID.pos, 1);
                            }
                            this.room.memory.DefendDouPosition.push(this.pos);
                            return;
                        }
                    }
                }
                if (creeps && !isInArray([0, 49], creeps.pos.x) && !isInArray([0, 49], creeps.pos.y)) {
                    this.room.visual.line(this.pos, creeps.pos, { color: 'red', lineStyle: 'dashed' });
                    let DefendDoulist = this.pos.findInRange(FIND_HOSTILE_CREEPS, 1, {
                        filter: (creep) => {
                            return !isInArray(Memory.whitesheet, creep.owner.username) && creep.id != creeps.id;
                        }
                    });
                    if (DefendDoulist) {
                        this.room.memory.DefendDouPosition.push(this.pos);
                        this.room.memory.DefendDouId = creeps.id;
                    }
                    switch (this.attack(creeps)) {
                        case ERR_NOT_IN_RANGE:
                            this.goTo(creeps.pos, 1);
                            break;
                        case OK:
                            console.log('调度塔一起攻击');
                            this.optTower('attack', creeps);
                            break;
                    }
                }
                if (this.pos.x >= 48 || this.pos.x <= 1 || this.pos.y >= 48 || this.pos.y <= 1) {
                    this.moveTo(new RoomPosition(Memory.RoomControlData[this.memory.belong].center[0], Memory.RoomControlData[this.memory.belong].center[1], this.memory.belong));
                }
            }
        }
        else {
            if (this.hitsMax - this.hits > 600)
                this.optTower('heal', this);
            this.moveTo(Game.creeps[this.memory.double]);
            if (Game.creeps[this.memory.double]) {
                let double_creeps = Game.creeps[this.memory.double];
                if (double_creeps.hitsMax * 0.8 < double_creeps.hits) {
                    let creeps = this.pos.findInRange(FIND_MY_CREEPS, 1, {
                        filter: (creep) => {
                            return Game.creeps[this.memory.double].id != creep.id && creep.id != this.id && creep.hitsMax * 0.8 > creep.hits;
                        }
                    });
                    if (creeps.length > 0) {
                        if (Game.flags['TowerVisualWar']) {
                            this.room.visual.line(this.pos, creeps[0].pos, { color: 'green' });
                        }
                        this.heal(creeps[0]);
                    }
                    else {
                        if (Game.flags['TowerVisualWar']) {
                            this.room.visual.line(this.pos, Game.creeps[this.memory.double].pos, { color: 'green' });
                        }
                        this.heal(Game.creeps[this.memory.double]);
                    }
                }
                else {
                    if (Game.flags['TowerVisualWar']) {
                        this.room.visual.line(this.pos, Game.creeps[this.memory.double].pos, { color: 'green' });
                    }
                    this.heal(Game.creeps[this.memory.double]);
                }
            }
            else
                this.heal(this);
            if (!Game.creeps[this.memory.double]) {
                if (this.ticksToLive < 100) {
                    this.suicide();
                    return;
                }
                delete this.memory.double;
            }
            else {
                if (this.pos.isNearTo(Game.creeps[this.memory.double])) {
                    var caption_hp = Game.creeps[this.memory.double].hits;
                    var this_hp = this.hits;
                    if (this_hp == this.hitsMax && caption_hp == Game.creeps[this.memory.double].hitsMax)
                        this.heal(Game.creeps[this.memory.double]);
                    if (caption_hp < this_hp) {
                        this.heal(Game.creeps[this.memory.double]);
                    }
                    else {
                        this.heal(this);
                    }
                    let otherCreeps = this.pos.findInRange(FIND_MY_CREEPS, 3, { filter: (creep) => { return creep.hits < creep.hitsMax - 300; } });
                    if (otherCreeps[0] && this.hits == this.hitsMax && Game.creeps[this.memory.double].hits == Game.creeps[this.memory.double].hitsMax) {
                        if (otherCreeps[0].pos.isNearTo(this))
                            this.heal(otherCreeps[0]);
                        else
                            this.rangedHeal(otherCreeps[0]);
                    }
                }
                else {
                    this.heal(this);
                    this.moveTo(Game.creeps[this.memory.double]);
                }
            }
        }
        // let e =Game.cpu.getUsed();
        // console.log(this.name,e-s)
    }
    /*踩工地*/
    handle_cconstruction() {
        let missionData = this.memory.MissionData;
        let id = missionData.id;
        let data = missionData.Data;
        if (!missionData)
            return;
        if (this.room.name == this.memory.belong && Game.shard.name == this.memory.shard) {
            if (data.boost) {
                switch (data.bodylevel) {
                    case 'T3':
                        if (!this.BoostCheck(['move', 'heal', 'tough', 'ranged_attack']))
                            return;
                        break;
                }
            }
        }
        if ((this.room.name != data.disRoom || Game.shard.name != data.shard)) {
            if (this.hits < this.hitsMax) {
                switch (data.bodylevel) {
                    case 'T3':
                        this.heal(this);
                        break;
                }
                /*检查坐标信息*/
                if (isInArray([0, 49], this.pos.x) || isInArray([0, 49], this.pos.y)) {
                    this.Flee(this.pos, 2);
                }
                /*检查是否存在敌对目标的信息*/
                return;
            }
            this.arriveTo(new RoomPosition(24, 24, data.disRoom), 23, data.shard, data.shardData ? data.shardData : null);
        }
        else {
            // 对方开安全模式情况下 删除任务
            if (this.room.controller && this.room.controller.safeMode && !this.room.controller.my) {
                if (Game.shard.name == this.memory.shard) {
                    Game.rooms[this.memory.belong].DeleteMission(id);
                }
                return;
            }
            if (Game.flags['cconstruction_flags']) {
                if (!this.pos.inRangeTo(Game.flags['cconstruction_flags'], 1)) {
                    this.goTo(Game.flags['cconstruction_flags'].pos, 0);
                }
            }
            if (this.getActiveBodyparts(HEAL)) {
                this.heal(this);
            }
            switch (data.bodylevel) {
                case 'T3':
                    warDataInit(Game.rooms[data.disRoom]);
                    let creeps = global.warData.enemy[data.disRoom].data;
                    let ranged3Attack = RangeCreep(this.pos, creeps, 3, true); // 三格内的攻击性爬虫
                    if (ranged3Attack.length > 0) {
                        // 防御塔伤害数据
                        let towerData = global.warData.tower[this.room.name].data;
                        let posStr = `${this.pos.x}/${this.pos.y}`;
                        let towerHurt = towerData[posStr] ? towerData[posStr]['attack'] : 0;
                        if (!canSustain(ranged3Attack, this, towerHurt)) {
                            this.say("危");
                            /* 删除记忆 */
                            let closestHurtCreep = RangeClosestCreep(this.pos, ranged3Attack, true);
                            if (closestHurtCreep) {
                                this.Flee(closestHurtCreep.pos, 4);
                                return;
                            }
                        }
                    }
                    var pos_ = this.pos.findClosestByPath(FIND_HOSTILE_CONSTRUCTION_SITES);
                    if (pos_) {
                        if (!this.pos.isEqualTo(pos_)) {
                            this.goTo(pos_.pos, 0);
                        }
                    }
                    else {
                        if (this.getActiveBodyparts(RANGED_ATTACK)) {
                            let creeps = this.pos.findClosestByRange(FIND_HOSTILE_CREEPS, {
                                filter: (creep) => {
                                    return creep.getActiveBodyparts(WORK) && !creep.getActiveBodyparts(ATTACK) && !creep.getActiveBodyparts(RANGED_ATTACK);
                                }
                            });
                            if (creeps) {
                                if (!this.pos.inRangeTo(creeps, 1)) {
                                    this.goTo(creeps.pos, 1);
                                }
                                this.rangedMassAttack();
                                return;
                            }
                        }
                    }
                    break;
                default:
                    var pos_ = this.pos.findClosestByPath(FIND_HOSTILE_CONSTRUCTION_SITES);
                    if (!pos_)
                        return;
                    this.goTo(pos_.pos, 0);
                    break;
            }
        }
    }
    // 攻防一体 已经做一定测试 目前未发现bug
    handle_aio() {
        var _a;
        let missionData = this.memory.MissionData;
        let id = missionData.id;
        let data = missionData.Data;
        if (!missionData)
            return;
        if (this.room.name == this.memory.belong && Game.shard.name == this.memory.shard) {
            if (data.boost) {
                switch (data.bodylevel) {
                    case 'T8':
                        if (!this.BoostCheck(['move', 'heal', 'ranged_attack']))
                            return;
                        break;
                    default:
                        if (!this.BoostCheck(['move', 'ranged_attack', 'heal', 'tough']))
                            return;
                        break;
                }
            }
            let flags_key = `${this.memory.belong}/aio/standby`;
            if (Game.flags[flags_key]) {
                if (Game.flags[flags_key] && !this.pos.inRangeTo(Game.flags[flags_key].pos, 5)) {
                    this.goTo(Game.flags[flags_key].pos, 5);
                }
            }
        }
        if ((this.room.name != data.disRoom || Game.shard.name != data.shard)) {
            if (this.hits < this.hitsMax) {
                this.heal(this);
                /*检查坐标信息*/
                if (isInArray([0, 49], this.pos.x) || isInArray([0, 49], this.pos.y)) {
                    this.Flee(this.pos, 2);
                }
                /*检查是否存在敌对目标的信息*/
                return;
            }
            this.arriveTo(new RoomPosition(24, 24, data.disRoom), 23, data.shard, data.shardData ? data.shardData : null);
        }
        else {
            // 对方开安全模式情况下 删除任务
            if (this.room.controller && this.room.controller.safeMode && !this.room.controller.my) {
                if (Game.shard.name == this.memory.shard) {
                    Game.rooms[this.memory.belong].DeleteMission(id);
                }
                return;
            }
            warDataInit(Game.rooms[data.disRoom]);
            let creeps = global.warData.enemy[data.disRoom].data;
            let flags = global.warData.flag[data.disRoom].data;
            this.heal(this);
            if (!this.memory.targetFlag && ((this.room.controller && !this.room.controller.my) || !this.room.controller)) // 没有目标旗帜Memory的情况下，先查找有没有最近的周围没有攻击爬的旗帜
             {
                if (!this.room.controller && Game.time % 31 == 0) { //要塞房间处理
                    let stronghold = this.room.find(FIND_STRUCTURES, {
                        filter: (stru) => {
                            return stru.structureType == STRUCTURE_INVADER_CORE && stru.level >= 1 && !stru.ticksToDeploy;
                        }
                    });
                    if (stronghold.length <= 0) {
                        if (Game.shard.name == this.memory.shard) {
                            Game.rooms[this.memory.belong].DeleteMission(id);
                        }
                    }
                }
                let flag_attack = pathClosestFlag(this.pos, flags, 'aio', true, 4); // 最近的攻击旗帜
                if (flag_attack) {
                    this.memory.targetFlag = flag_attack.name;
                }
                else {
                    // 没有旗帜，就寻找一个最近的非危险建筑【优先没有rampart的】
                    let safeStructure = pathClosestStructure(this.pos, true, true, true, 4);
                    if (!safeStructure) {
                        // 还没有就寻找ram
                        let ramStructure = pathClosestStructure(this.pos, true, false, true, 4);
                        if (!ramStructure) {
                            let wallStructure = pathClosestStructure(this.pos, false, false, true, 2);
                            if (!wallStructure) ;
                            else {
                                let randomStr = Math.random().toString(36).substr(3);
                                if (!Game.flags[`aio_${randomStr}`])
                                    wallStructure.pos.createFlag(`aio_${randomStr}`);
                                this.memory.targetFlag = `aio_${randomStr}`;
                            }
                        }
                        else {
                            let randomStr = Math.random().toString(36).substr(3);
                            if (!Game.flags[`aio_${randomStr}`])
                                ramStructure.pos.createFlag(`aio_${randomStr}`);
                            this.memory.targetFlag = `aio_${randomStr}`;
                        }
                    }
                    else {
                        let randomStr = Math.random().toString(36).substr(3);
                        if (!Game.flags[`aio_${randomStr}`]) {
                            safeStructure.pos.createFlag(`aio_${randomStr}`);
                            this.memory.targetFlag = `aio_${randomStr}`;
                        }
                    }
                }
                // 遇到不能承受的爬就规避
                let ranged3Attack = RangeCreep(this.pos, creeps, 3, true); // 三格内的攻击性爬虫
                if (ranged3Attack.length > 0) {
                    // 防御塔伤害数据
                    let towerData = global.warData.tower[this.room.name].data;
                    let posStr = `${this.pos.x}/${this.pos.y}`;
                    let towerHurt = towerData[posStr] ? towerData[posStr]['attack'] : 0;
                    if (!canSustain(ranged3Attack, this, towerHurt)) {
                        this.say("危");
                        let closestHurtCreep = RangeClosestCreep(this.pos, ranged3Attack, true);
                        if (closestHurtCreep) {
                            this.Flee(closestHurtCreep.pos, 3);
                        }
                    }
                }
                /*检查是否有对方的爬进行攻击*/
            }
            else {
                if (this.memory.targetFlag) {
                    if (!Game.flags[this.memory.targetFlag]) {
                        delete this.memory.targetFlag;
                    }
                    else {
                        let pos_ = Game.flags[this.memory.targetFlag].pos;
                        if (pos_.roomName != this.room.name) {
                            delete this.memory.targetFlag;
                            return;
                        }
                        let stru = pos_.lookFor(LOOK_STRUCTURES);
                        if (stru.length <= 0 || (stru[0].structureType == 'road' || stru[0].structureType == 'container') && stru.length == 1) {
                            this.heal(this);
                            Game.flags[this.memory.targetFlag].remove();
                            delete this.memory.targetFlag;
                            // 尝试看一下有没有建筑 对墙就不做尝试了
                            let safeStructure = pathClosestStructure(this.pos, true, true, true, 4);
                            if (safeStructure) {
                                let randomStr = Math.random().toString(36).substr(3);
                                if (!Game.flags[`aio_${randomStr}`]) {
                                    safeStructure.pos.createFlag(`aio_${randomStr}`);
                                    this.memory.targetFlag = `aio_${randomStr}`;
                                }
                                return;
                            }
                        }
                        else {
                            // 自动规避
                            let ranged3Attack = RangeCreep(this.pos, creeps, 3, true); // 三格内的攻击性爬虫
                            if (ranged3Attack.length > 0) {
                                // 防御塔伤害数据
                                let towerData = global.warData.tower[this.room.name].data;
                                let posStr = `${this.pos.x}/${this.pos.y}`;
                                let towerHurt = towerData[posStr] ? towerData[posStr]['attack'] : 0;
                                if (!canSustain(ranged3Attack, this, towerHurt)) {
                                    this.say("危");
                                    /* 删除记忆 */
                                    if (!this.pos.isNearTo(Game.flags[this.memory.targetFlag])) {
                                        delete this.memory.targetFlag;
                                    }
                                    this.heal(this);
                                    let closestHurtCreep = RangeClosestCreep(this.pos, ranged3Attack, true);
                                    if (closestHurtCreep) {
                                        this.Flee(closestHurtCreep.pos, 4);
                                    }
                                }
                                else {
                                    if (!this.pos.isNearTo(pos_)) {
                                        this.goTo_aio(pos_, 1);
                                    }
                                }
                            }
                            else {
                                if (!this.pos.isNearTo(pos_)) {
                                    this.goTo_aio(pos_, 1);
                                }
                            }
                            // 根据建筑类型判断攻击方式
                            if (isInArray([STRUCTURE_WALL, STRUCTURE_ROAD, STRUCTURE_CONTAINER], stru[0].structureType)) {
                                this.rangedAttack(stru[0]);
                            }
                            else {
                                if (stru[0].pos.isNearTo(this)) {
                                    this.rangedMassAttack();
                                }
                                else {
                                    this.rangedAttack(stru[0]);
                                }
                            }
                        }
                    }
                }
            }
            let ranged3ramcreep = RangeCreep(this.pos, creeps, 3, false, true);
            // 自动攻击爬虫
            if (ranged3ramcreep.length > 0) {
                if (this.pos.isNearTo(ranged3ramcreep[0])) {
                    this.rangedMassAttack();
                }
                else {
                    this.rangedAttack(ranged3ramcreep[0]);
                }
            }
            // 治疗自己和周围友军
            if (this.hits < this.hitsMax)
                this.heal(this);
            else {
                if (((_a = this.room.memory) === null || _a === void 0 ? void 0 : _a.state) == 'peace') {
                    var allys = this.room.find(FIND_CREEPS, {
                        filter: (creep) => {
                            return (creep.my || isInArray(Memory.whitesheet, creep.owner.username)) && creep.hitsMax - creep.hits > 350;
                        }
                    });
                }
                else {
                    var allys = this.pos.findInRange(FIND_CREEPS, 3, {
                        filter: (creep) => {
                            return (creep.my || isInArray(Memory.whitesheet, creep.owner.username)) && creep.hitsMax - creep.hits > 350;
                        }
                    });
                }
                if (allys.length > 0) {
                    // 寻找最近的爬
                    let ally_ = allys[0];
                    // for (var i of allys) if (getDistance(this.pos, i.pos) < getDistance(ally_.pos, this.pos)) ally_ = i
                    if (this.pos.isNearTo(ally_))
                        this.heal(ally_);
                    else
                        this.rangedHeal(ally_);
                }
                else
                    this.heal(this);
            }
            // 寻找最近的敌人攻击
            let closestCreep = this.pos.findClosestByPath(FIND_HOSTILE_CREEPS, {
                filter: (creep) => {
                    return !isInArray(Memory.whitesheet, creep.owner.username) && !creep.pos.GetStructure('rampart') && (!isInArray([0, 49], creep.pos.x) && !isInArray([0, 49], creep.pos.y)) && (!creep.room.controller ? creep.owner.username != 'Source Keeper' : true);
                }
            });
            if (closestCreep && !this.pos.isNearTo(closestCreep)) {
                this.goTo(closestCreep.pos, 3);
            }
            else {
                /*寻找移动旗帜待命*/
                let withdrawFlag = this.pos.findClosestByPath(FIND_FLAGS, {
                    filter: (flag) => {
                        return flag.name.indexOf('automove') == 0;
                    }
                });
                if (withdrawFlag && !this.pos.inRangeTo(withdrawFlag.pos, 2)) {
                    this.goTo(withdrawFlag.pos, 1);
                }
            }
        }
    }
    // 四人小队 已经测试 多次跨shard未测试
    handle_task_squard() {
        var data = this.memory.MissionData.Data;
        var shard = data.shard; // 目标shard
        var roomName = data.disRoom; // 目标房间名
        var squadID = data.squadID; // 四人小队id
        /* controlledBySquadFrame为true代表不再受任务控制，改为战斗模块控制 */
        if (this.memory.controlledBySquardFrame) {
            /* 说明到达指定房间，并到达合适位置了 */
            /* 添加战争框架控制信息 */
            if (!Memory.squadMemory)
                Memory.squadMemory = {};
            if (!squadID) {
                this.say("找不到squardID!");
                return;
            }
            if (!Memory.squadMemory[squadID]) {
                Memory.squadMemory[squadID] = {
                    creepData: this.memory.squad,
                    sourceRoom: this.memory.belong,
                    presentRoom: this.room.name,
                    disRoom: data.disRoom,
                    ready: false,
                    array: 'free',
                    sourceShard: this.memory.shard,
                    disShard: this.memory.targetShard,
                    squardType: data.flag
                };
            }
            return;
        }
        else {
            /* 任务开始前准备 */
            if (this.room.name == this.memory.belong && this.memory.shard == Game.shard.name) {
                var thisRoom = Game.rooms[this.memory.belong];
                /* boost检查 */
                if (this.getActiveBodyparts('move') > 0) {
                    if (!this.BoostCheck([, 'move'], false))
                        return;
                }
                if (this.getActiveBodyparts('heal') > 0) {
                    if (!this.BoostCheck([, 'heal'], false))
                        return;
                }
                if (this.getActiveBodyparts('work') > 0) {
                    if (!this.BoostCheck([, 'work'], false))
                        return;
                }
                if (this.getActiveBodyparts('attack') > 0) {
                    if (!this.BoostCheck([, 'attack'], false))
                        return;
                }
                if (this.getActiveBodyparts('ranged_attack') > 0) {
                    if (!this.BoostCheck([, 'ranged_attack'], false))
                        return;
                }
                if (this.getActiveBodyparts('tough') > 0) {
                    if (!this.BoostCheck([, 'tough'], false))
                        return;
                }
                /* 组队检查 */
                if (!squadID)
                    return;
                if (!this.memory.MissionData.id)
                    return;
                if (!thisRoom.memory.squadData)
                    Game.rooms[this.memory.belong].memory.squadData = {};
                let MissonSquardData = thisRoom.memory.squadData[squadID];
                if (!MissonSquardData)
                    thisRoom.memory.squadData[squadID] = {};
                /* 编队信息初始化 */
                if (this.memory.creepType == 'heal' && !this.memory.squad) {
                    if (this.memory.role == 'x-aio') {
                        if (MissonSquardData == null || MissonSquardData == undefined)
                            MissonSquardData = {};
                        if (Object.keys(MissonSquardData).length <= 0)
                            MissonSquardData[this.name] = { position: '↙', index: 1, role: this.memory.role, creepType: this.memory.creepType };
                        if (Object.keys(MissonSquardData).length == 1 && !isInArray(Object.keys(MissonSquardData), this.name))
                            MissonSquardData[this.name] = { position: '↖', index: 0, role: this.memory.role, creepType: this.memory.creepType };
                        if (Object.keys(MissonSquardData).length == 2 && !isInArray(Object.keys(MissonSquardData), this.name))
                            MissonSquardData[this.name] = { position: '↘', index: 3, role: this.memory.role, creepType: this.memory.creepType };
                        if (Object.keys(MissonSquardData).length == 3 && !isInArray(Object.keys(MissonSquardData), this.name))
                            MissonSquardData[this.name] = { position: '↗', index: 2, role: this.memory.role, creepType: this.memory.creepType };
                    }
                    else {
                        if (MissonSquardData == null || MissonSquardData == undefined)
                            MissonSquardData = {};
                        if (Object.keys(MissonSquardData).length <= 0)
                            MissonSquardData[this.name] = { position: '↙', index: 1, role: this.memory.role, creepType: this.memory.creepType };
                        if (Object.keys(MissonSquardData).length == 2 && !isInArray(Object.keys(MissonSquardData), this.name))
                            MissonSquardData[this.name] = { position: '↘', index: 3, role: this.memory.role, creepType: this.memory.creepType };
                    }
                }
                else if (this.memory.creepType == 'attack' && !this.memory.squad) {
                    if (MissonSquardData == null || MissonSquardData == undefined)
                        MissonSquardData = {};
                    if (Object.keys(MissonSquardData).length == 1 && !isInArray(Object.keys(MissonSquardData), this.name))
                        MissonSquardData[this.name] = { position: '↖', index: 0, role: this.memory.role, creepType: this.memory.creepType };
                    if (Object.keys(MissonSquardData).length == 3 && !isInArray(Object.keys(MissonSquardData), this.name))
                        MissonSquardData[this.name] = { position: '↗', index: 2, role: this.memory.role, creepType: this.memory.creepType };
                }
                if (Object.keys(thisRoom.memory.squadData[squadID]).length == 4 && !this.memory.squad) {
                    console.log(`[squad] 房间${this.memory.belong}ID为:${squadID}的四人小队数量已经到位!将从房间分发组队数据!`);
                    this.memory.squad = thisRoom.memory.squadData[squadID];
                    return;
                }
                /* 检查是否所有爬虫都赋予记忆了 */
                if (!this.memory.squad)
                    return;
                for (var mem in this.memory.squad) {
                    if (!Game.creeps[mem])
                        return;
                    if (!Game.creeps[mem].memory.squad)
                        return;
                }
                /* 爬虫都被赋予了组队数据了，就删除房间内的原始数据 */
                if (thisRoom.memory.squadData[squadID])
                    delete thisRoom.memory.squadData[squadID];
            }
            /* 在到达任务房间的隔壁房间前，默认攻击附近爬虫 */
            if (this.getActiveBodyparts('ranged_attack')) {
                let enemy = this.pos.findInRange(FIND_HOSTILE_CREEPS, 3, {
                    filter: (creep) => {
                        return !isInArray(Memory.whitesheet, creep.owner.username);
                    }
                });
                if (enemy.length > 0) {
                    for (let enemy_ of enemy) {
                        if (enemy_.pos.isNearTo(this))
                            this.rangedMassAttack();
                    }
                    this.rangedAttack(enemy[0]);
                }
            }
            /* 在到达任务房间的隔壁房间前，默认治疗附近爬虫 */
            if (this.getActiveBodyparts('heal')) {
                var bol = true;
                for (var i in this.memory.squad) {
                    if (Game.creeps[i] && Game.creeps[i].hits < Game.creeps[i].hitsMax && this.pos.isNearTo(Game.creeps[i])) {
                        bol = false;
                        this.heal(Game.creeps[i]);
                    }
                }
                if (bol)
                    this.heal(this);
            }
            /* 线性队列行走规则: 有成员疲劳就停止行走 */
            for (var cc in this.memory.squad) {
                if (Game.creeps[cc] && Game.creeps[cc].fatigue)
                    return;
            }
            /* 编号为 0 1 2 的爬需要遵守的规则 */
            if (this.memory.squad[this.name].index != 3 && (!isInArray([0, 49], this.pos.x) && !isInArray([0, 49], this.pos.y))) {
                var followCreepName = findNextData(this);
                if (followCreepName == null)
                    return;
                var portal = this.pos.findClosestByRange(FIND_STRUCTURES, {
                    filter: (stru) => {
                        return stru.structureType == 'portal';
                    }
                });
                var followCreep = Game.creeps[followCreepName];
                if (!followCreep && portal) {
                    return;
                }
                if (followCreep) {
                    // 跟随爬不靠在一起就等一等
                    if (!this.pos.isNearTo(followCreep)) {
                        return;
                    }
                }
            }
            /* 编号为 1 2 3 的爬需要遵守的规则 */
            if (this.memory.squad[this.name].index != 0) {
                var disCreepName = findFollowData(this);
                var portal = this.pos.findClosestByRange(FIND_STRUCTURES, {
                    filter: (stru) => {
                        return stru.structureType == 'portal';
                    }
                });
                // 跨shard信息更新 可以防止一些可能出现的bug
                if (portal && data.shardData) {
                    this.updateShardAffirm();
                }
                if (disCreepName == null || (!Game.creeps[disCreepName] && !portal))
                    return;
                if (!Game.creeps[disCreepName] && portal) {
                    this.arriveTo(new RoomPosition(24, 24, roomName), 20, shard, data.shardData ? data.shardData : null);
                    return;
                }
                if (Game.shard.name == shard && !Game.creeps[disCreepName])
                    return;
                var disCreep = Game.creeps[disCreepName];
                if (this.room.name == this.memory.belong)
                    this.goTo(disCreep.pos, 0);
                else
                    this.moveTo(disCreep);
                return;
            }
            // 接下来在门口自动组队
            if (this.memory.squad[this.name].index == 0) {
                /* 判断在不在目标房间入口房间 */
                if (Game.flags[`squad_unit_${this.memory.MissionData.id}`]) {
                    // 有集结旗帜的情况下，优先前往目标房间
                    if (this.room.name != Game.flags[`squad_unit_${this.memory.MissionData.id}`].pos.roomName || Game.shard.name != data.shard) {
                        if (this.memory.squad[this.name].index == 0)
                            this.arriveTo(new RoomPosition(24, 24, roomName), 18, shard, data.shardData ? data.shardData : null);
                        return;
                    }
                }
                else {
                    // 没有集结旗帜的情况下，自动判断
                    if (identifyNext(this.room.name, roomName) == false || Game.shard.name != data.shard) {
                        this.say("🔪");
                        if (this.memory.squad[this.name].index == 0)
                            // console.log('四人小队移动',this.name,roomName)
                            this.arriveTo(new RoomPosition(24, 24, roomName), 18, shard, data.shardData ? data.shardData : null);
                        return;
                    }
                }
                this.say('⚔️', true);
                if (!this.memory.arrived) {
                    if (Game.flags[`squad_unit_${this.memory.MissionData.id}`]) {
                        // 有旗帜的情况下，如果到达旗帜附近，就判定arrived为true
                        if (!this.pos.isEqualTo(Game.flags[`squad_unit_${this.memory.MissionData.id}`]))
                            this.goTo(Game.flags[`squad_unit_${this.memory.MissionData.id}`].pos, 0);
                        else
                            this.memory.arrived = true;
                    }
                    else {
                        // 没有旗帜的情况下，到入口前5格组队
                        if (RoomInRange(this.pos, roomName, 5)) {
                            this.memory.arrived = true;
                        }
                        else {
                            this.arriveTo(new RoomPosition(24, 24, roomName), 24, shard, data.shardData ? data.shardData : null);
                        }
                    }
                }
                else {
                    // 能组队就组队 否则就继续走
                    if (identifyGarrison(this))
                        for (var crp in this.memory.squad) {
                            if (Game.creeps[crp])
                                Game.creeps[crp].memory.controlledBySquardFrame = true;
                        }
                    else {
                        this.arriveTo(new RoomPosition(24, 24, roomName), 24, shard, data.shardData ? data.shardData : null);
                    }
                }
            }
        }
    }
    // 紧急支援 已经修改，但未作充分测试 可能有bug
    handle_support() {
        let missionData = this.memory.MissionData;
        missionData.id;
        let data = missionData.Data;
        if (!missionData)
            return;
        var roomName = data.disRoom;
        if (this.room.name == this.memory.belong && data.boost) {
            if (this.memory.role == 'double-attack') {
                if (!this.BoostCheck(['move', 'attack', 'tough']))
                    return;
            }
            else if (this.memory.role == 'double-heal') {
                if (!this.BoostCheck(['move', 'heal', 'ranged_attack', 'tough']))
                    return;
            }
            else if (this.memory.role == 'aio') {
                if (!this.BoostCheck(['move', 'heal', 'ranged_attack', 'tough']))
                    return;
            }
        }
        if (this.memory.role != 'aio' && !this.memory.double) {
            if (this.memory.role == 'double-heal') {
                /* 由heal来进行组队 */
                if (Game.time % 7 == 0) {
                    var disCreep = this.pos.findClosestByRange(FIND_MY_CREEPS, {
                        filter: (creep) => {
                            return creep.memory.role == 'double-attack' && !creep.memory.double;
                        }
                    });
                    if (disCreep) {
                        this.memory.double = disCreep.name;
                        disCreep.memory.double = this.name;
                        this.memory.captain = false;
                        disCreep.memory.captain = true;
                    }
                }
            }
            return;
        }
        if (this.memory.role == 'double-attack') {
            if (!Game.creeps[this.memory.double])
                return;
            if (this.fatigue || Game.creeps[this.memory.double].fatigue)
                return;
            if (Game.creeps[this.memory.double] && !this.pos.isNearTo(Game.creeps[this.memory.double]) && (!isInArray([0, 49], this.pos.x) && !isInArray([0, 49], this.pos.y)))
                return;
            /* 去目标房间 */
            if (this.room.name != roomName || Game.shard.name != data.shard) {
                this.arriveTo(new RoomPosition(24, 24, roomName), 23, data.shard, data.shardData ? data.shardData : null);
            }
            else {
                let creeps = this.pos.findClosestByRange(FIND_HOSTILE_CREEPS, {
                    filter: (creep) => {
                        return !isInArray(Memory.whitesheet, creep.owner.username);
                    }
                });
                if (creeps) {
                    if (this.attack(creeps) == ERR_NOT_IN_RANGE)
                        this.goTo(creeps.pos, 1);
                }
                else {
                    this.goTo(new RoomPosition(24, 24, data.disRoom), 10);
                }
                // 支援旗帜 support_double
                let flag = this.pos.findClosestByPath(FIND_FLAGS, {
                    filter: (flag) => {
                        return flag.name.indexOf('support_double') == 0;
                    }
                });
                if (flag) {
                    let creeps = this.pos.findInRange(FIND_HOSTILE_CREEPS, 1, {
                        filter: (creep) => {
                            return !isInArray(Memory.whitesheet, creep.owner.username);
                        }
                    });
                    if (creeps[0])
                        this.attack(creeps[0]);
                    this.goTo(flag.pos, 0);
                    return;
                }
                // 攻击建筑
                let attack_flag = this.pos.findClosestByPath(FIND_FLAGS, {
                    filter: (flag) => {
                        return flag.name.indexOf('support_structure') == 0;
                    }
                });
                if (attack_flag) {
                    if (attack_flag.pos.lookFor(LOOK_STRUCTURES).length > 0) {
                        if (this.attack(attack_flag.pos.lookFor(LOOK_STRUCTURES)[0]) == ERR_NOT_IN_RANGE)
                            this.goTo(creeps.pos, 1);
                    }
                    else
                        attack_flag.remove();
                }
            }
        }
        if (this.memory.role == 'double-heal') {
            var disCreepName = this.memory.double;
            var portal = this.pos.findClosestByRange(FIND_STRUCTURES, {
                filter: (stru) => {
                    return stru.structureType == 'portal';
                }
            });
            // 跨shard信息更新 可以防止一些可能出现的bug
            if (portal && data.shardData) {
                this.updateShardAffirm();
            }
            if (!Game.creeps[disCreepName] && portal) {
                this.arriveTo(new RoomPosition(25, 25, roomName), 20, data.shard, data.shardData ? data.shardData : null);
                return;
            }
            if (Game.creeps[this.memory.double])
                this.moveTo(Game.creeps[this.memory.double]);
            // 寻找敌人 远程攻击
            let enemy = this.pos.findInRange(FIND_HOSTILE_CREEPS, 3, {
                filter: (creep) => {
                    return !isInArray(Memory.whitesheet, creep.owner.username);
                }
            });
            if (enemy[0])
                this.rangedAttack(enemy[0]);
            // 奶
            if (Game.creeps[this.memory.double]) {
                if (this.hits < this.hitsMax || Game.creeps[this.memory.double].hits < Game.creeps[this.memory.double].hitsMax) {
                    if (this.hits < Game.creeps[this.memory.double].hits)
                        this.heal(this);
                    else {
                        if (this.pos.isNearTo(Game.creeps[this.memory.double]))
                            this.heal(Game.creeps[this.memory.double]);
                        else
                            this.rangedHeal(Game.creeps[this.memory.double]);
                    }
                    return;
                }
            }
            // 默认治疗攻击爬，如果周围有友军，在自身血量满的情况下治疗友军
            let allys = this.pos.findInRange(FIND_CREEPS, 3, {
                filter: (creep) => {
                    return (creep.my || isInArray(Memory.whitesheet, creep.owner.username)) && creep.hitsMax - creep.hits > 350;
                }
            });
            if (allys.length > 0) {
                // 寻找最近的爬
                let ally_ = allys[0];
                for (var i of allys)
                    if (getDistance(this.pos, i.pos) < getDistance(ally_.pos, this.pos))
                        ally_ = i;
                if (this.pos.isNearTo(ally_))
                    this.heal(ally_);
                else
                    this.rangedHeal(ally_);
            }
            else {
                if (Game.creeps[this.memory.double])
                    this.heal(Game.creeps[this.memory.double]);
                else
                    this.heal(this);
            }
        }
        if (this.memory.role == 'saio') {
            if (this.room.name != roomName || Game.shard.name != data.shard) {
                this.heal(this);
                this.arriveTo(new RoomPosition(24, 24, roomName), 23, data.shard, data.shardData ? data.shardData : null);
            }
            else {
                // 寻找敌人 远程攻击
                let enemy = this.pos.findInRange(FIND_HOSTILE_CREEPS, 3, {
                    filter: (creep) => {
                        return !isInArray(Memory.whitesheet, creep.owner.username);
                    }
                });
                let disenemy = null;
                for (var e of enemy) {
                    if (!e.pos.GetStructure('rampart'))
                        disenemy = e;
                }
                if (disenemy) {
                    if (this.pos.isNearTo(disenemy))
                        this.rangedMassAttack();
                    else if (this.pos.inRangeTo(disenemy, 3))
                        this.rangedAttack(disenemy);
                }
                // 治疗自己和周围友军
                if (this.hits < this.hitsMax)
                    this.heal(this);
                else {
                    let allys = this.pos.findInRange(FIND_CREEPS, 3, {
                        filter: (creep) => {
                            return (creep.my || isInArray(Memory.whitesheet, creep.owner.username)) && creep.hitsMax - creep.hits > 350;
                        }
                    });
                    if (allys.length > 0) {
                        // 寻找最近的爬
                        let ally_ = allys[0];
                        for (var i of allys)
                            if (getDistance(this.pos, i.pos) < getDistance(ally_.pos, this.pos))
                                ally_ = i;
                        if (this.pos.isNearTo(ally_))
                            this.heal(ally_);
                        else
                            this.rangedHeal(ally_);
                    }
                    else
                        this.heal(this);
                }
                // 移动旗
                let move_flag = this.pos.findClosestByPath(FIND_FLAGS, {
                    filter: (flag) => {
                        return flag.name.indexOf('support_aio') == 0;
                    }
                });
                if (move_flag) {
                    this.heal(this);
                    this.goTo(move_flag.pos, 1);
                    return;
                }
                // 放风筝 计算自己奶量 敌对爬伤害
                if (enemy.length > 0 && !canSustain(enemy, this)) {
                    // 放风筝 寻找最近的有攻击性的爬 离他远点
                    let closestAttackCreep = this.pos.findClosestByPath(FIND_HOSTILE_CREEPS, {
                        filter: (creep) => {
                            return !isInArray(Memory.whitesheet, creep.owner.username) && (creep.getActiveBodyparts('attack') > 0 || creep.getActiveBodyparts('ranged_attack') > 0);
                        }
                    });
                    if (closestAttackCreep)
                        this.Flee(closestAttackCreep.pos, 3);
                    return;
                }
                // 寻找最近的敌人攻击
                let closestCreep = this.pos.findClosestByPath(FIND_HOSTILE_CREEPS, {
                    filter: (creep) => {
                        return !isInArray(Memory.whitesheet, creep.owner.username) && !creep.pos.GetStructure('rampart');
                    }
                });
                if (closestCreep && !this.pos.isNearTo(closestCreep)) {
                    this.goTo(closestCreep.pos, 3);
                }
            }
        }
    }
    // 双人小队 已测试 目前没有挂载战争信息模块和智能躲避
    handle_double() {
        let missionData = this.memory.MissionData;
        let id = missionData.id;
        let data = missionData.Data;
        if (!missionData)
            return;
        var roomName = data.disRoom;
        if (this.room.name == this.memory.belong) {
            if (this.memory.role == 'double-attack') {
                if (!this.BoostCheck(['move', 'attack', 'tough']))
                    return;
            }
            else if (this.memory.role == 'double-heal') {
                // , 'ranged_attack'
                if (!this.BoostCheck(['move', 'heal', 'tough']))
                    return;
            }
            else if (this.memory.role == 'double-dismantle') {
                if (!this.BoostCheck(['move', 'work', 'tough']))
                    return;
            }
            if (this.hits < this.hitsMax) {
                this.optTower('heal', this);
            }
            let flags_key = `${this.memory.belong}/double/standby`;
            if (Game.flags[flags_key]) {
                if (Game.flags[flags_key] && !this.pos.inRangeTo(Game.flags[flags_key].pos, 5)) {
                    this.goTo(Game.flags[flags_key].pos, 5);
                }
            }
        }
        if (!this.memory.double) {
            if (this.memory.role == 'double-heal') {
                /* 由heal来进行组队 */
                if (Game.time % 7 == 0) {
                    if (data.teamType == 'attack')
                        var disCreep = this.pos.findClosestByRange(FIND_MY_CREEPS, {
                            filter: (creep) => {
                                return creep.memory.role == 'double-attack' && !creep.memory.double;
                            }
                        });
                    else if (data.teamType == 'dismantle')
                        var disCreep = this.pos.findClosestByRange(FIND_MY_CREEPS, {
                            filter: (creep) => {
                                return creep.memory.role == 'double-dismantle' && !creep.memory.double;
                            }
                        });
                    else
                        return;
                    if (disCreep) {
                        this.memory.double = disCreep.name;
                        disCreep.memory.double = this.name;
                        this.memory.captain = false;
                        disCreep.memory.captain = true;
                    }
                }
            }
            return;
        }
        if (this.memory.role == 'double-attack') {
            if (!Game.creeps[this.memory.double])
                return;
            if (this.fatigue || Game.creeps[this.memory.double].fatigue)
                return;
            if (Game.creeps[this.memory.double] && !this.pos.isNearTo(Game.creeps[this.memory.double]) && (!isInArray([0, 49], this.pos.x) && !isInArray([0, 49], this.pos.y)))
                return;
            if (this.room.name != roomName || Game.shard.name != data.shard) {
                this.arriveTo(new RoomPosition(24, 24, roomName), 23, data.shard, data.shardData ? data.shardData : null);
            }
            else {
                // 对方开安全模式情况下 删除任务
                if (this.room.controller && this.room.controller.safeMode) {
                    if (Game.shard.name == this.memory.shard) {
                        Game.rooms[this.memory.belong].DeleteMission(id);
                    }
                    return;
                }
                warDataInit(Game.rooms[data.disRoom]);
                // 没有发现敌人就攻击建筑物
                let attack_flag = this.pos.findClosestByPath(FIND_FLAGS, {
                    filter: (flag) => {
                        return flag.name.indexOf('double_attack') == 0;
                    }
                });
                if (!attack_flag) {
                    /* 攻击离四格内离自己最近的爬 */
                    var enemy = this.pos.findClosestByPath(FIND_HOSTILE_CREEPS, {
                        filter: (creep) => {
                            return !isInArray(Memory.whitesheet, creep.owner.username) && !creep.pos.GetStructure('rampart') && (!isInArray([0, 49], creep.pos.x) && !isInArray([0, 49], creep.pos.y));
                        }
                    });
                    if (enemy && Math.max(Math.abs(this.pos.x - enemy.pos.x), Math.abs(this.pos.y - enemy.pos.y)) <= 4) {
                        this.goTo(enemy.pos, 1);
                        this.attack(enemy);
                        return;
                    }
                }
                if (!attack_flag) {
                    var Attstructure = this.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES, {
                        filter: (stru) => {
                            return isInArray(['nuker', 'spawn', 'terminal', 'extension', 'tower', 'link', 'observer', 'lab', 'powerspawn', 'factory'], stru.structureType) && !stru.pos.GetStructure('rampart');
                        }
                    });
                    if (Attstructure) {
                        let randomStr = Math.random().toString(36).substr(3);
                        if (!Game.flags[`double_attack_${randomStr}`])
                            Attstructure.pos.createFlag(`double_attack_${randomStr}`);
                    }
                }
                if (!attack_flag) {
                    // 还找不到就找重要的被ram覆盖的重要建筑攻击
                    var CoverStructure = this.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES, {
                        filter: (stru) => {
                            return stru.structureType == 'rampart' && stru.pos.GetStructureList(['spawn', 'tower', 'storage', 'terminal']).length > 0;
                        }
                    });
                    if (CoverStructure) {
                        this.say("⚔️", true);
                        if (this.attack(CoverStructure) == ERR_NOT_IN_RANGE)
                            this.goTo(CoverStructure.pos, 1);
                        return;
                    }
                    // 还找不到就直接找最近的wall或者rampart攻击
                    var walls = this.pos.findClosestByPath(FIND_STRUCTURES, {
                        filter: (stru) => {
                            return isInArray([STRUCTURE_RAMPART], stru.structureType);
                        }
                    });
                    if (walls) {
                        this.say("⚔️", true);
                        if (this.attack(walls) == ERR_NOT_IN_RANGE)
                            this.goTo(walls.pos, 1);
                        return;
                    }
                }
                else {
                    // 有旗子就攻击旗子下的建筑
                    let stru = attack_flag.pos.lookFor(LOOK_STRUCTURES);
                    if (stru.length > 0) {
                        if (this.attack(stru[0]) == ERR_NOT_IN_RANGE)
                            this.goTo(stru[0].pos, 1);
                        return;
                    }
                    attack_flag.remove(); // 没有建筑就删除旗帜
                }
            }
        }
        else if (this.memory.role == 'double-dismantle') {
            if (!Game.creeps[this.memory.double])
                return;
            if (this.fatigue || Game.creeps[this.memory.double].fatigue)
                return;
            if (Game.creeps[this.memory.double] && !this.pos.isNearTo(Game.creeps[this.memory.double]) && (!isInArray([0, 49], this.pos.x) && !isInArray([0, 49], this.pos.y))) {
                console.log('运行被终止了');
                return;
            }
            if (this.room.name != roomName || Game.shard.name != data.shard) {
                this.arriveTo(new RoomPosition(24, 24, roomName), 23, data.shard, data.shardData ? data.shardData : null);
            }
            else {
                // 对方开安全模式情况下 删除任务
                if (this.room.controller && this.room.controller.safeMode) {
                    if (Game.shard.name == this.memory.shard) {
                        Game.rooms[this.memory.belong].DeleteMission(id);
                    }
                    return;
                }
                // 开始拆墙
                let attack_flag = this.pos.findClosestByPath(FIND_FLAGS, {
                    filter: (flag) => {
                        return flag.name.indexOf('double_dismantle') == 0;
                    }
                });
                if (!attack_flag) {
                    var Attstructure = this.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES, {
                        filter: (stru) => {
                            return isInArray(['nuker', 'spawn', 'terminal', 'extension', 'tower', 'link', 'observer', 'lab', 'powerspawn', 'factory'], stru.structureType) && !stru.pos.GetStructure('rampart');
                        }
                    });
                    if (Attstructure) {
                        let randomStr = Math.random().toString(36).substr(3);
                        if (!Game.flags[`double_dismantle_${randomStr}`])
                            Attstructure.pos.createFlag(`double_dismantle_${randomStr}`);
                    }
                }
                if (!attack_flag) {
                    // 还找不到就找重要的被ram覆盖的重要建筑攻击
                    var CoverStructure = this.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES, {
                        filter: (stru) => {
                            return stru.structureType == 'rampart' && stru.pos.GetStructureList(['spawn', 'tower', 'storage', 'terminal']).length > 0;
                        }
                    });
                    if (CoverStructure) {
                        this.say("⚔️", true);
                        if (this.dismantle(CoverStructure) == ERR_NOT_IN_RANGE)
                            this.goTo(CoverStructure.pos, 1);
                        return;
                    }
                    // 还找不到就直接找最近的wall或者rampart攻击
                    var walls = this.pos.findClosestByPath(FIND_STRUCTURES, {
                        filter: (stru) => {
                            return isInArray([STRUCTURE_WALL, STRUCTURE_RAMPART], stru.structureType);
                        }
                    });
                    if (walls) {
                        this.say("⚔️", true);
                        if (this.dismantle(walls) == ERR_NOT_IN_RANGE)
                            this.goTo(walls.pos, 1);
                        return;
                    }
                }
                else {
                    // 有旗子就攻击旗子下的建筑
                    if (!this.pos.isNearTo(attack_flag)) {
                        this.goTo(attack_flag.pos, 1, 2000);
                    }
                    this.memory.standed = true;
                    let stru = attack_flag.pos.lookFor(LOOK_STRUCTURES);
                    if (stru.length > 0) {
                        if (this.dismantle(stru[0]) == ERR_NOT_IN_RANGE)
                            this.goTo(stru[0].pos, 1);
                        return;
                    }
                    attack_flag.remove(); // 没有建筑就删除旗帜
                }
            }
        }
        else {
            var disCreepName = this.memory.double;
            var portal = this.pos.findClosestByRange(FIND_STRUCTURES, {
                filter: (stru) => {
                    return stru.structureType == 'portal';
                }
            });
            // 跨shard信息更新 可以防止一些可能出现的bug
            if (portal && data.shardData) {
                this.updateShardAffirm();
            }
            if (!Game.creeps[disCreepName] && portal) {
                this.arriveTo(new RoomPosition(25, 25, roomName), 20, data.shard, data.shardData ? data.shardData : null);
                return;
            }
            if (Game.creeps[this.memory.double])
                this.moveTo(Game.creeps[this.memory.double]);
            // 寻找敌人 远程攻击
            // let enemy = this.pos.findInRange(FIND_HOSTILE_CREEPS, 3, {
            //     filter: (creep) => {
            //         return !isInArray(Memory.whitesheet, creep.owner.username)
            //     }
            // })
            // if (enemy[0]) this.rangedAttack(enemy[0])
            // 奶
            if (Game.creeps[this.memory.double]) {
                if (this.hits < this.hitsMax || Game.creeps[this.memory.double].hits < Game.creeps[this.memory.double].hitsMax) {
                    if (this.hits < Game.creeps[this.memory.double].hits)
                        this.heal(this);
                    else {
                        if (this.pos.isNearTo(Game.creeps[this.memory.double]))
                            this.heal(Game.creeps[this.memory.double]);
                        else
                            this.rangedHeal(Game.creeps[this.memory.double]);
                    }
                    return;
                }
            }
            // 默认治疗攻击爬，如果周围有友军，在自身血量满的情况下治疗友军
            let allys = this.pos.findInRange(FIND_CREEPS, 3, {
                filter: (creep) => {
                    return (creep.my || isInArray(Memory.whitesheet, creep.owner.username)) && creep.hitsMax - creep.hits > 350;
                }
            });
            if (allys.length > 0) {
                // 寻找最近的爬
                let ally_ = allys[0];
                for (var i of allys)
                    if (getDistance(this.pos, i.pos) < getDistance(ally_.pos, this.pos))
                        ally_ = i;
                if (this.pos.isNearTo(ally_))
                    this.heal(ally_);
                else
                    this.rangedHeal(ally_);
            }
            else {
                if (Game.creeps[this.memory.double])
                    this.heal(Game.creeps[this.memory.double]);
                else
                    this.heal(this);
            }
        }
    }
}

class CreepMissonWarExtension extends Creep {
    /*ai哨兵*/
    handle_aisentry() {
        // console.log('AI哨兵')
        let missionData = this.memory.MissionData;
        missionData.id;
        let data = missionData.Data;
        if (!missionData)
            return;
        var roomName = data.disRoom;
        if (this.room.name == this.memory.belong) {
            switch (missionData.Data.bodylevel) {
                case 'T3':
                    // console.log('操作强化')
                    if (!this.BoostCheck(['move', 'heal', 'tough']))
                        return;
                    break;
            }
        }
        if (this.hits < this.hitsMax && this.room.name != roomName) {
            /*跳跃到了隔壁房间自我恢复血量*/
            this.heal(this);
            return;
        }
        if (this.room.name != roomName || Game.shard.name != data.shard) {
            this.arriveTo(new RoomPosition(24, 24, roomName), 23, data.shard, data.shardData ? data.shardData : null);
        }
        else {
            /*搜索边界,根据自己当前的坐标位置来判定具体的边界判定*/
            let Export_id = 0;
            if (this.pos.y >= 49) { //下
                Export_id = 1;
                this.goTo(new RoomPosition(this.pos.x, 48, roomName), 0);
            }
            else if (this.pos.x >= 49) { //右边
                Export_id = 2;
                this.goTo(new RoomPosition(48, this.pos.x, roomName), 0);
            }
            else if (this.pos.y < 1) { //上
                Export_id = 3;
                this.goTo(new RoomPosition(this.pos.x, 1, roomName), 0);
            }
            else if (this.pos.x < 1) { //左边
                Export_id = 4;
                this.goTo(new RoomPosition(1, this.pos.x, roomName), 0);
            }
            /*保持自己在边界 如果被攻击则通过边界移动 */
            if (this.hits < this.hitsMax) {
                /*跳跃到了隔壁房间自我恢复血量*/
                this.heal(this);
            }
            /*获取三格内的单位攻击力*/
            warDataInit(Game.rooms[data.disRoom]);
            let creeps = global.warData.enemy[data.disRoom].data;
            // console.log(JSON.stringify(global.warData.tower[data.disRoom].data))
            global.warData.flag[data.disRoom].data;
            let ranged3Attack = RangeCreep(this.pos, creeps, 3, true); // 三格内的攻击性爬虫
            if (ranged3Attack.length > 0) {
                // 防御塔伤害数据
                let towerData = global.warData.tower[this.room.name].data;
                let posStr = `${this.pos.x}/${this.pos.y}`;
                let towerHurt = towerData[posStr] ? towerData[posStr]['attack'] : 0;
                if (!canSustain(ranged3Attack, this, towerHurt)) {
                    this.say("危");
                    /*操作撤退*/
                    switch (Export_id) {
                        case 1:
                            this.pos.y++;
                            break;
                        case 2:
                            this.pos.x++;
                            break;
                        case 3:
                            this.pos.y--;
                            break;
                        case 4:
                            this.pos.x--;
                            break;
                    }
                    this.goTo(this.pos, 0);
                }
            }
        }
    }
}

// 定义好挂载顺序
const plugins$4 = [
    CreepMoveExtension,
    CreepFunctionExtension,
    CreepMissonBaseExtension,
    CreepMissonTransportExtension,
    CreepMissonActionExtension,
    CreepMissonMineExtension,
    CreepMissonWarExtension$1,
    CreepMissonWarExtension,
];
/**
* 依次挂载所有的拓展
*/
var mountCreep = () => plugins$4.forEach(plugin => assignPrototype(Creep, plugin));

/* 位置原型拓展   --方法  --寻找 */
class PositionFunctionFindExtension extends RoomPosition {
    /* 获取指定范围内，指定列表类型建筑 范围 模式 0 代表无筛选，1代表hit受损的 2代表hit最小 */
    getRangedStructure(sr, range, mode) {
        let resultstructure;
        switch (mode) {
            case 0: {
                // 无筛选
                resultstructure = this.findInRange(FIND_STRUCTURES, range, {
                    filter: (structure) => {
                        return filter_structure(structure, sr);
                    }
                });
                return resultstructure;
            }
            case 1: {
                // 筛选hit
                resultstructure = this.findInRange(FIND_STRUCTURES, range, {
                    filter: (structure) => {
                        return filter_structure(structure, sr) && structure.hits < structure.hitsMax;
                    }
                });
                return resultstructure;
            }
            case 2: {
                resultstructure = this.findInRange(FIND_STRUCTURES, range, {
                    filter: (structure) => {
                        return filter_structure(structure, sr) && structure.hits < structure.hitsMax;
                    }
                });
                var s_l = LeastHit(resultstructure, 2);
                return s_l;
            }
            default: {
                return undefined;
            }
        }
    }
    /* 获取距离最近的指定列表里类型建筑 0 代表无筛选，1代表hit受损 */
    getClosestStructure(sr, mode) {
        let resultstructure;
        switch (mode) {
            case 0: {
                // 无筛选
                resultstructure = this.findClosestByRange(FIND_STRUCTURES, {
                    filter: (structure) => {
                        return filter_structure(structure, sr);
                    }
                });
                return resultstructure;
            }
            case 1: {
                // 筛选hit
                resultstructure = this.findClosestByRange(FIND_STRUCTURES, {
                    filter: (structure) => {
                        return filter_structure(structure, sr) && structure.hits < structure.hitsMax;
                    }
                });
                return resultstructure;
            }
            default: {
                return undefined;
            }
        }
    }
    /* 获取最近的store能量有空的spawn或扩展 */
    getClosestStore() {
        return this.findClosestByPath(FIND_STRUCTURES, {
            filter: (structure) => {
                return filter_structure(structure, [STRUCTURE_EXTENSION, STRUCTURE_SPAWN, STRUCTURE_LAB]) && structure.store.getFreeCapacity(RESOURCE_ENERGY) > 0;
            }
        });
    }
    /* 获取资源矿点周围能开link的地方 */
    getSourceLinkVoid() {
        var result = [];
        var source_void = this.getSourceVoid();
        for (var x of source_void) {
            var link_void = x.getSourceVoid();
            if (link_void)
                for (var y of link_void) {
                    if (!isInArray(result, y))
                        result.push(y);
                }
        }
        var result2 = [];
        for (var i of result) {
            if (i.lookFor(LOOK_STRUCTURES).length == 0 && !i.isNearTo(this)) {
                result2.push(i);
            }
        }
        if (result2)
            return result2;
        //return result 
    }
    /* 获取矿点周围的开采空位 */
    getSourceVoid() {
        var result = [];
        var terrain = new Room.Terrain(this.roomName);
        var xs = [this.x - 1, this.x, this.x + 1];
        var ys = [this.y - 1, this.y, this.y + 1];
        xs.forEach(x => ys.forEach(y => {
            if (terrain.get(x, y) != TERRAIN_MASK_WALL) {
                result.push(new RoomPosition(x, y, this.roomName));
            }
        }));
        return result;
    }
    /* 获取该位置上指定类型建筑 */
    GetStructure(stru) {
        var lis = this.lookFor(LOOK_STRUCTURES);
        if (lis.length <= 0)
            return null;
        for (var i of lis) {
            if (i.structureType == stru)
                return i;
        }
        return null;
    }
    /* 获取该位置上指定类型建筑列表 */
    GetStructureList(stru) {
        var lis = this.lookFor(LOOK_STRUCTURES);
        if (lis.length <= 0)
            return [];
        var result = [];
        for (var i of lis) {
            if (isInArray(stru, i.structureType))
                result.push(i);
        }
        return result;
    }
    /* 获取该位置上有store的ruin */
    GetRuin() {
        var lis = this.lookFor(LOOK_RUINS);
        if (lis.length <= 0)
            return null;
        for (var i of lis) {
            if (i.store && Object.keys(i.store).length > 0)
                return i;
        }
        return null;
    }
    /* 寻找两个点之间的路线 */
    FindPath(target, range, roadstate) {
        /* 全局路线存储 */
        if (!global.routeCache)
            global.routeCache = {};
        /* 路线查找 */
        const result = PathFinder.search(this, { pos: target, range: range }, {
            plainCost: 2,
            swampCost: 10,
            maxOps: 8000,
            roomCallback: roomName => {
                // 在全局绕过房间列表的房间 false
                if (Memory.bypassRooms && Memory.bypassRooms.includes(roomName))
                    return false;
                const room = Game.rooms[roomName];
                // 没有视野的房间只观察地形
                if (!room)
                    return;
                // 有视野的房间
                let costs = new PathFinder.CostMatrix;
                // 将道路的cost设置为1，无法行走的建筑设置为255
                room.find(FIND_STRUCTURES).forEach(struct => {
                    if (!roadstate) {
                        if (struct.structureType === STRUCTURE_ROAD) {
                            costs.set(struct.pos.x, struct.pos.y, 1);
                        }
                    }
                    else if (struct.structureType !== STRUCTURE_CONTAINER &&
                        (struct.structureType !== STRUCTURE_RAMPART || (!struct.my)))
                        costs.set(struct.pos.x, struct.pos.y, 0xff);
                });
                room.find(FIND_MY_CONSTRUCTION_SITES).forEach(cons => {
                    if (cons.structureType != 'road' && cons.structureType != 'rampart' && cons.structureType != 'container')
                        costs.set(cons.pos.x, cons.pos.y, 255);
                });
                return costs;
            }
        });
        // 寻路异常返回null
        if (result.path.length <= 0)
            return null;
        // 寻路结果压缩
        return result.path;
    }
    /* 获取该位置n格内的敌对爬虫 */
    FindRangeCreep(num) {
        let creep_ = this.findInRange(FIND_CREEPS, num, {
            filter: (creep) => {
                return !isInArray(Memory.whitesheet, creep.owner.username);
            }
        });
        if (creep_.length > 0)
            return creep_;
        return [];
    }
    /* 防御塔数据叠加 */
    AddTowerRangeData(target, tempData) {
        let xR = Math.abs(this.x - target.pos.x);
        let yR = Math.abs(this.y - target.pos.y);
        let distance = Math.max(xR, yR);
        let attackNum;
        let repairNum;
        let healNum;
        if (distance <= 5) {
            attackNum = 600;
            repairNum = 800;
            healNum = 400;
        }
        else if (distance >= 20) {
            attackNum = 150;
            repairNum = 200;
            healNum = 100;
        }
        else {
            /* 根据距离计算 */
            attackNum = 600 - (distance - 5) * 30;
            repairNum = 800 - (distance - 5) * 40;
            healNum = 400 - (distance - 5) * 20;
        }
        tempData.attack += attackNum;
        tempData.heal += healNum;
        tempData.repair += repairNum;
    }
}

/* 位置原型拓展   --方法  --移动 */
class PositionFunctionMoveExtension extends RoomPosition {
    /* 获取当前位置目标方向的pos对象 */
    directionToPos(direction) {
        let targetX = this.x;
        let targetY = this.y;
        if (direction !== LEFT && direction !== RIGHT) {
            if (direction > LEFT || direction < RIGHT)
                targetY--;
            else
                targetY++;
        }
        if (direction !== TOP && direction !== BOTTOM) {
            if (direction < BOTTOM)
                targetX++;
            else
                targetX--;
        }
        if (targetX < 0 || targetY > 49 || targetX > 49 || targetY < 0)
            return undefined;
        else
            return new RoomPosition(targetX, targetY, this.roomName);
    }
}

// 定义好挂载顺序
const plugins$3 = [
    PositionFunctionFindExtension,
    PositionFunctionMoveExtension,
];
/**
* 依次挂载所有的拓展
*/
var mountPosition = () => plugins$3.forEach(plugin => assignPrototype(RoomPosition, plugin));

/* 房间原型拓展   --内核  --房间初始化 */
class RoomCoreInitExtension extends Room {
    /**
     * 房间初始化主函数
     */
    RoomInit() {
        var cpu_test = false;
        if (Memory.Systemswitch.ShowtestroomInit) {
            cpu_test = true;
        }
        let cpu_list = [];
        if (cpu_test) {
            cpu_list.push(Game.cpu.getUsed());
        }
        this.RoomMemoryInit();
        if (cpu_test) {
            cpu_list.push(Game.cpu.getUsed());
        }
        this.RoomStructureInit();
        if (cpu_test) {
            cpu_list.push(Game.cpu.getUsed());
        }
        this.RoomSpawnListInit();
        if (cpu_test) {
            cpu_list.push(Game.cpu.getUsed());
        }
        /*建筑初始化已废弃*/
        // this.RoomGlobalStructure()
        this.RoomGlobalDynamicconfig();
        if (cpu_test) {
            cpu_list.push(Game.cpu.getUsed());
            console.log(this.name, 'MemoryInit' + (cpu_list[1] - cpu_list[0]).toFixed(3), 'StructureInit' + (cpu_list[2] - cpu_list[1]).toFixed(3), 'SpawnListInit' + (cpu_list[3] - cpu_list[2]).toFixed(3), 'GlobalDynamicconfig' + (cpu_list[4] - cpu_list[3]).toFixed(3), '总计' + (cpu_list[4] - cpu_list[0]).toFixed(3));
        }
    }
    /**
     * 所有RoomMemory的1级key都需要在这里注册
     */
    RoomMemoryInit() {
        if (!global.Stru[this.name]) {
            global.Stru[this.name] = {};
            if (!this.memory.StructureIdData)
                this.memory.StructureIdData = {};
            if (!this.memory.RoomLabBind)
                this.memory.RoomLabBind = {};
            if (!this.memory.SpawnConfig)
                this.memory.SpawnConfig = {};
            if (!this.memory.UpgradespawnConfig)
                this.memory.UpgradespawnConfig = {};
            if (!this.memory.originLevel)
                this.memory.originLevel = 0;
            if (!this.memory.SpawnList)
                this.memory.SpawnList = [];
            if (!this.memory.state)
                this.memory.state = 'peace';
            if (!this.memory.CoolDownDic)
                this.memory.CoolDownDic = {};
            if (!this.memory.Misson)
                this.memory.Misson = {};
            if (!this.memory.Misson['Structure'])
                this.memory.Misson['Structure'] = [];
            if (!this.memory.Misson['Room'])
                this.memory.Misson['Room'] = [];
            if (!this.memory.Misson['Creep'])
                this.memory.Misson['Creep'] = [];
            if (!this.memory.Misson['PowerCreep'])
                this.memory.Misson['PowerCreep'] = [];
            // if (!global.HostileData[this.name]) global.HostileData[this.name] = {}
            if (!this.memory.TerminalData)
                this.memory.TerminalData = { 'energy': { num: 50000, fill: true } };
            if (!this.memory.market)
                this.memory.market = { 'deal': [], 'order': [] };
            if (!global.ResourceLimit[this.name])
                global.ResourceLimit[this.name] = {};
            if (!this.memory.ComDispatchData)
                this.memory.ComDispatchData = {};
            if (!this.memory.DefendDouPosition)
                this.memory.DefendDouPosition = [];
            if (!this.memory.switch)
                this.memory.switch = {};
            if (!this.memory.enemy)
                this.memory.enemy = {};
            if (!this.memory.productData)
                this.memory.productData = { level: 0, state: 'sleep', baseList: {}, balanceData: {}, unzip: {} };
            if (!this.memory.DynamicConfig)
                this.memory.DynamicConfig = {};
            if (!this.memory.DynamicConfig.Dynamicupgrade)
                this.memory.DynamicConfig.Dynamicupgrade = false;
            if (!global.Repairlist[this.name])
                global.Repairlist[this.name] = [];
            if (!this.memory.MarketPrice) {
                this.memory.MarketPrice = { Dynamicprice: true, order_list: [], buy: { low: 0, high: 0 }, sell: { low: 0, high: 0 } };
            }
            if (!global.controllerData[this.name]) {
                global.controllerData[this.name] = [];
            }
            if (!this.memory.CoolDownDic)
                this.memory.CoolDownDic = {};
            if (!this.memory.Visualdisplay)
                this.memory.Visualdisplay = false;
            if (!this.memory.Labautomatic)
                this.memory.Labautomatic = { 'automaticData': [], 'automaticState': false };
            if (!this.memory.ExcludeRampart) {
                this.memory.ExcludeRampart = [];
            }
            if (!this.memory.Enemydistribution) {
                this.memory.Enemydistribution = {};
            }
            if (!this.memory.AutoBasicmarket) {
                this.memory.AutoBasicmarket = {};
            }
        }
        global.HostileCreeps[this.name] = [];
        global.HostileGroup[this.name] = [];
        global.getStructure[this.name] = {};
        global.getStructureData[this.name] = {};
        global.RoleMissionNum[this.name] = {};
        global.getMission[this.name] = {};
        delete this.memory.DefendDouId; /*每个Tick都进行重置操作*/
        this.memory.DefendDouPosition = [];
    }
    /**
     * 定时刷新房间内的建筑，将建筑id储存起来  【已测试】 <能用就行，不想改了QAQ>
     */
    RoomStructureInit() {
        let tickratio = 6;
        if ((Game.time - global.Gtime[this.name]) % tickratio) {
            return;
        }
        let level = this.controller.level;
        let StructureData = this.memory.StructureIdData;
        /* Spawn建筑记忆更新-8级之后此部分不会被重复触发 */
        if (!StructureData.spawn)
            StructureData.spawn = [];
        if (StructureData.spawn.length < 3) {
            if (level <= 6 && StructureData.spawn.length < 1) {
                let ASpawn = this.find(FIND_MY_SPAWNS);
                for (let sp of ASpawn) {
                    StructureData.spawn.push(sp.id);
                }
            }
            else if ((level == 7 && StructureData.spawn.length < 2) || (level >= 8 && StructureData.spawn.length < 3)) {
                if ((Game.time - global.Gtime[this.name]) % (tickratio * 2) == 0) {
                    let ASpawn = this.find(FIND_MY_SPAWNS);
                    for (let sp of ASpawn) {
                        if (!isInArray(StructureData.spawn, sp.id))
                            StructureData.spawn.push(sp.id);
                    }
                }
            }
        }
        /* 中心点依赖建筑 - 正常情况下8级不应该发生触发*/
        if (!this.memory.StructureIdData.NtowerID && Memory.RoomControlData[this.name].center.length == 2) {
            let centerlist = Memory.RoomControlData[this.name].center;
            /* 近塔记忆更新 (用于维护道路和container的塔) */
            if (!this.memory.StructureIdData.NtowerID && this.controller.level >= 3) {
                let position = new RoomPosition(centerlist[0], centerlist[1], this.name);
                var NTower = position.getClosestStructure([STRUCTURE_TOWER], 0);
                if (NTower && NTower.my)
                    if (getDistance(NTower.pos, position) < 7)
                        this.memory.StructureIdData.NtowerID = NTower.id;
            }
        }
        /* 资源矿记忆更新-不进行重复刷新*/
        if (!StructureData.mineralID) {
            let Mineral_ = this.find(FIND_MINERALS);
            if (Mineral_.length == 1)
                this.memory.StructureIdData.mineralID = Mineral_[0].id;
        }
        /* 能量矿记忆更新-不进行重复刷新*/
        if (!StructureData.source)
            StructureData.source = [];
        if (StructureData.source.length <= 0) {
            let allSource = this.find(FIND_SOURCES);
            let sourceIDs = [];
            allSource.forEach(sou => sourceIDs.push(sou.id));
            StructureData.source = sourceIDs;
        }
        /* 升级Link记忆更新 -不进行重复刷新*/
        if (!StructureData.source_links)
            StructureData.source_links = [];
        if (level >= 5 && !StructureData.upgrade_link) {
            if ((Game.time - global.Gtime[this.name]) % (tickratio * 4) == 0) {
                let upgrade_link = this.controller.pos.getRangedStructure([STRUCTURE_LINK], 3, 0);
                if (upgrade_link.length >= 1)
                    for (let ul of upgrade_link) {
                        if (!isInArray(StructureData.source_links, ul.id)) {
                            StructureData.upgrade_link = ul.id;
                            break;
                        }
                    }
            }
        }
        if (!StructureData.comsume_link) {
            StructureData.comsume_link = [];
        }
        /* 矿点link记忆更新 */
        if (level >= 5) {
            if (level == 5 || level == 6) {
                if (StructureData.source_links.length <= 0) {
                    let temp_link_list = [];
                    for (let sID of StructureData.source) {
                        let source_ = Game.getObjectById(sID);
                        let nearlink = source_.pos.getRangedStructure(['link'], 2, 0);
                        for (let l of nearlink) {
                            if (StructureData.upgrade_link && l.id == StructureData.upgrade_link)
                                continue;
                            temp_link_list.push(l.id);
                        }
                    }
                    StructureData.source_links = temp_link_list;
                }
            }
            if (level == 7) {
                if (StructureData.source_links.length < StructureData.source.length) {
                    let temp_link_list = [];
                    for (let sID of StructureData.source) {
                        let source_ = Game.getObjectById(sID);
                        let nearlink = source_.pos.getRangedStructure(['link'], 2, 0);
                        for (let l of nearlink) {
                            if (StructureData.upgrade_link && l.id == StructureData.upgrade_link)
                                continue;
                            temp_link_list.push(l.id);
                        }
                    }
                    StructureData.source_links = temp_link_list;
                }
            }
        }
        /* 仓库记忆更新 */
        if (level >= 4 && !this.memory.StructureIdData.storageID) {
            if (this.storage)
                this.memory.StructureIdData.storageID = this.storage.id;
        }
        /* 通过仓库抓取中央link */
        if (level >= 5 && !StructureData.center_link && this.storage) {
            let storage_ = this.storage;
            if (storage_) {
                let center_links = storage_.pos.getRangedStructure(['link'], 2, 0);
                if (center_links.length >= 1)
                    StructureData.center_link = center_links[0].id;
            }
        }
        /* 防御塔记忆更新 */
        if (this.controller.level >= 3 && (Game.time - global.Gtime[this.name]) % tickratio * 25 == 0) {
            if (!this.memory.StructureIdData.AtowerID)
                this.memory.StructureIdData.AtowerID = [];
            if (this.memory.StructureIdData.AtowerID.length < 6) {
                this.memory.StructureIdData.AtowerID;
                var ATowers = this.getStructure(STRUCTURE_TOWER);
                if (ATowers.length > this.memory.StructureIdData.AtowerID.length) {
                    for (var t of ATowers)
                        if (t.my && !isInArray(this.memory.StructureIdData.AtowerID, t.id)) {
                            var AtowerID = this.memory.StructureIdData.AtowerID;
                            AtowerID.push(t.id);
                        }
                }
            }
        }
        /* 终端识别  -不进行重复刷新*/
        if (!this.memory.StructureIdData.terminalID && level >= 6) {
            if (this.terminal)
                this.memory.StructureIdData.terminalID = this.terminal.id;
        }
        /* 提取器识别 */
        if (!this.memory.StructureIdData.extractID && this.controller.level >= 5) {
            var extract = this.getStructure(STRUCTURE_EXTRACTOR);
            if (extract.length == 1)
                this.memory.StructureIdData.extractID = extract[0].id;
        }
        /* 实验室识别 */
        if ((Game.time - global.Gtime[this.name]) % tickratio * 34 == 0) {
            if (!this.memory.StructureIdData.labs)
                this.memory.StructureIdData.labs = [];
            if (this.memory.StructureIdData.labs.length < 10) {
                var ALabs = this.getStructure(STRUCTURE_LAB);
                if (ALabs.length >= 1) {
                    for (var llab of ALabs) {
                        if (llab.my && !isInArray(this.memory.StructureIdData.labs, llab.id)) {
                            var labs = this.memory.StructureIdData.labs;
                            labs.push(llab.id);
                        }
                    }
                }
            }
            /* 删除无用lab */
            if (this.memory.StructureIdData.labs) {
                for (let labID of this.memory.StructureIdData.labs) {
                    let theLab = Game.getObjectById(labID);
                    if (!theLab) {
                        let index = this.memory.StructureIdData.labs.indexOf(labID);
                        this.memory.StructureIdData.labs.splice(index, 1);
                    }
                }
            }
            /* 实验室合成数据 需要手动挂载，如果没有实验室合成数据，无法执行合成任务 */
            /* 里面包含自动合成相关的原料lab和产出lab数据 */
            if (!this.memory.StructureIdData.labInspect) {
                this.memory.StructureIdData.labInspect = {};
            }
        }
        if ((Game.time - global.Gtime[this.name]) % (tickratio * 10) == 0) {
            /* 观察器识别 */
            if (!this.memory.StructureIdData.ObserverID && this.controller.level >= 8) {
                var observer_ = this.getStructure(STRUCTURE_OBSERVER);
                if (observer_.length > 0) {
                    this.memory.StructureIdData.ObserverID = observer_[0].id;
                }
            }
            /* PowerSpawn识别 */
            if (!this.memory.StructureIdData.PowerSpawnID && this.controller.level >= 8) {
                var powerSpawn = this.getStructure(STRUCTURE_POWER_SPAWN);
                if (powerSpawn.length > 0)
                    this.memory.StructureIdData.PowerSpawnID = powerSpawn[0].id;
            }
            /* 核弹识别 */
            if (!this.memory.StructureIdData.NukerID && this.controller.level >= 8) {
                var nuke_ = this.getStructure(STRUCTURE_NUKER);
                if (nuke_.length > 0) {
                    this.memory.StructureIdData.NukerID = nuke_[0].id;
                }
            }
            /* 工厂识别 */
            if (!this.memory.StructureIdData.FactoryId && this.controller.level >= 8) {
                var factory_ = this.getStructure(STRUCTURE_FACTORY);
                if (factory_.length > 0) {
                    this.memory.StructureIdData.FactoryId = factory_[0].id;
                }
            }
        }
        // harvestData 数据更新
        if (!this.memory.harvestData) {
            this.memory.harvestData = {};
            for (let source_ of this.memory.StructureIdData.source) {
                this.memory.harvestData[source_] = {};
            }
        }
        let carry_num = 0;
        if ((Game.time - global.Gtime[this.name]) % (tickratio * 5) == 0) {
            for (let id in this.memory.harvestData) {
                if (!this.memory.harvestData[id].containerID) {
                    let source = Game.getObjectById(id);
                    let containers = source.pos.findInRange(FIND_STRUCTURES, 1, { filter: (stru) => { return stru.structureType == 'container'; } });
                    if (containers.length > 0) {
                        this.memory.harvestData[id].containerID = containers[0].id;
                        carry_num++;
                    }
                }
                else {
                    carry_num++;
                }
                if (level >= 5 && !this.memory.harvestData[id].linkID) {
                    let source = Game.getObjectById(id);
                    if (source) {
                        let links = source.pos.findInRange(FIND_STRUCTURES, 2, { filter: (stru) => { return stru.structureType == 'link'; } });
                        if (links.length > 0) {
                            this.memory.harvestData[id].linkID = links[0].id;
                            carry_num--;
                        }
                    }
                }
                else if (this.memory.harvestData[id].linkID) {
                    carry_num--;
                }
            }
        }
        this.memory.SpawnConfig.carry.num = carry_num;
    }
    /**
     * 房间孵化队列初始化
     */
    RoomSpawnListInit() {
        if (!global.CreepBodyData)
            global.CreepBodyData = {};
        if (!global.CreepBodyData[this.name])
            global.CreepBodyData[this.name] = {};
        if (!global.CreepNumData)
            global.CreepNumData = {};
        if (!global.CreepNumData[this.name])
            global.CreepNumData[this.name] = {};
    }
    /**
     * 房间全局建筑初始化
     */
    RoomGlobalStructure() {
        // 目前只支持 storage terminal factory powerspawn
        // if (this.memory.StructureIdData.NtowerID) {
        //     global.Stru[this.name]['Ntower'] = Game.getObjectById(this.memory.StructureIdData.NtowerID) as StructureTower
        //     if (!global.Stru[this.name]['Ntower']) {
        //         delete this.memory.StructureIdData.NtowerID
        //     }
        // }
        // if (this.memory.StructureIdData.AtowerID && this.memory.StructureIdData.AtowerID.length > 0) {
        //     var otlist = global.Stru[this.name]['Atower'] = [] as StructureTower[]
        //     for (var ti of this.memory.StructureIdData.AtowerID) {
        //         var ot = Game.getObjectById(ti) as StructureTower
        //         if (!ot) {
        //             var index = this.memory.StructureIdData.AtowerID.indexOf(ti)
        //             this.memory.StructureIdData.AtowerID.splice(index, 1)
        //             continue
        //         }
        //         otlist.push(ot)
        //     }
        // }
    }
    /**
     * 房间自适应动态配置
     */
    RoomGlobalDynamicconfig() {
        if ((Game.time - global.Gtime[this.name]) % 53) {
            return;
        }
        let level = this.controller.level;
        if (this.controller.level >= 4) {
            let transport_num = this.memory.SpawnConfig.transport.num;
            if (this.memory.state == 'peace') {
                /*调整物流人员的数量*/
                transport_num = 1;
            }
            else if (this.memory.state == 'war') {
                transport_num = 2;
            }
            if (this.memory.DynamicConfig.Dynamictransport) {
                transport_num += this.memory.DynamicConfig.Dynamictransport;
            }
            this.NumSpawn('transport', transport_num);
        }
        else {
            this.NumSpawn('transport', 0);
        }
        /*针对单矿房间进行定式操作*/
        if (Object.keys(this.memory.harvestData).length <= 1 && level > 3) {
            this.NumSpawn('harvest', 1);
        }
        if (!this.memory.DynamicConfig.Dynamicupgrade)
            return;
        if (this.memory.DynamicConfig.Dynamicupgrade && level < 8) {
            let room_energy = 0;
            if (!this.storage) {
                return;
            }
            room_energy = this.storage.store.getUsedCapacity(RESOURCE_ENERGY);
            if (this.terminal) {
                room_energy += this.terminal.store.getUsedCapacity(RESOURCE_ENERGY);
                room_energy -= this.memory.TerminalData['energy'].num;
            }
            let creep_num = Math.ceil(room_energy / 100000);
            let source_num = Object.keys(this.memory.harvestData).length; //统计房间能量源
            let isInWar = (this.memory.state === 'war'); //若房间有战争行为则暂停升级
            for (const mission of this.memory.Misson.Creep) {
                if (mission.name === "外矿开采") {
                    if (mission.Data.state === 2) {
                        source_num += 0.5 * (mission.CreepBind["out-harvest"].num);
                    }
                }
                else if (isInWar || isInArray(['紧急支援', '紧急援建', '紧急升级', '紧急墙体', '攻防一体', '黄球拆迁', '红球防御', '蓝球防御', '双人防御', '双人小队', '四人小队'], mission.name)) {
                    isInWar = true;
                    break;
                }
            }
            if (source_num < 2.45)
                creep_num -= 1;
            if (this.MissionNum('Creep', '墙体维护') > 0)
                creep_num -= 1; //若房间在刷墙则减少升级爬
            creep_num = creep_num > 5 ? 5 : creep_num;
            creep_num = creep_num < 1 ? 1 : creep_num;
            if (room_energy < 50000 || isInWar)
                creep_num = 0;
            if (this.memory.SpawnConfig.upgrade.num != creep_num) {
                console.log(this.name, 'upgrade动态调整', creep_num);
            }
            this.memory.SpawnConfig.upgrade.num = creep_num;
        }
        else {
            if (!this.memory.economy && !Memory.Systemswitch.SystemEconomy) {
                if (this.MissionNum('Creep', '急速冲级') > 0) {
                    this.memory.SpawnConfig.upgrade.num = 0;
                }
                else {
                    if (level >= 8) {
                        this.memory.DynamicConfig.Dynamicupgrade = false;
                        this.memory.SpawnConfig.upgrade.num = 1;
                    }
                }
            }
        }
    }
}

var frameExtension = {
    /* 绕过房间api */
    bypass: {
        /* 添加要绕过的房间 */
        add(roomNames) {
            if (!Memory.bypassRooms)
                Memory.bypassRooms = [];
            // 确保新增的房间名不会重复
            Memory.bypassRooms = _.uniq([...Memory.bypassRooms, roomNames]);
            return `[bypass]已添加绕过房间 \n ${this.show()}`;
        },
        show() {
            if (!Memory.bypassRooms || Memory.bypassRooms.length <= 0)
                return '[bypass]当前无绕过房间';
            return `[bypass]当前绕过房间列表：${Memory.bypassRooms.join(' ')}`;
        },
        clean() {
            Memory.bypassRooms = [];
            return `[bypass]已清空绕过房间列表，当前列表：${Memory.bypassRooms.join(' ')}`;
        },
        remove(roomNames) {
            if (!Memory.bypassRooms)
                Memory.bypassRooms = [];
            if (roomNames.length <= 0)
                delete Memory.bypassRooms;
            else
                Memory.bypassRooms = _.difference(Memory.bypassRooms, [roomNames]);
            return `[bypass]已移除绕过房间${roomNames}`;
        }
    },
    /* 白名单api */
    whitelist: {
        add(username) {
            if (!Memory.whitesheet)
                Memory.whitesheet = [];
            Memory.whitesheet = _.uniq([...Memory.whitesheet, username]);
            return `[whitesheet]已添加用户${username}进白名单！\n${this.show()}`;
        },
        show() {
            if (!Memory.whitesheet || Memory.whitesheet.length <= 0)
                return "[whitesheet]当前白名单为空！";
            return `[whitesheet]白名单列表：${Memory.whitesheet.join(' ')}`;
        },
        clean() {
            Memory.whitesheet = [];
            return '[whitesheet]当前白名单已清空';
        },
        remove(username) {
            // if (! (username in Memory.whitesheet)) return `[whitesheet]白名单里没有玩家“${username}”`
            if (!Memory.whitesheet)
                Memory.whitesheet = [];
            if (Memory.whitesheet.length <= 0)
                delete Memory.whitesheet;
            else
                Memory.whitesheet = _.difference(Memory.whitesheet, [username]);
            return `[whitesheet]已移除${username}出白名单`;
        }
    },
    rampart: {
        add(roomName, x, y) {
            let thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[rampart] 不存在房间${roomName}`;
            if (!thisRoom.memory.ExcludeRampart)
                return `[rampart] 获取错误${roomName}`;
            for (let pos of thisRoom.memory.ExcludeRampart) {
                let x_y = unzipXandY(pos);
                if (x == x_y[0] && y == x_y[1])
                    return `[rampart] 重复的rampart${roomName}`;
            }
            let pos_ = `${x}/${y}`;
            thisRoom.memory.ExcludeRampart.push(pos_);
            return `[rampart] rampart ${x}/${y} 添加成功`;
        },
        remove(roomName, x, y) {
            let thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[rampart] 不存在房间${roomName}`;
            if (!thisRoom.memory.ExcludeRampart)
                return `[rampart] 获取错误${roomName}`;
            for (let pos of thisRoom.memory.ExcludeRampart) {
                let x_y = unzipXandY(pos);
                if (x == x_y[0] && y == x_y[1]) {
                    var index = thisRoom.memory.ExcludeRampart.indexOf(pos);
                    thisRoom.memory.ExcludeRampart.splice(index, 1);
                    return `[rampart] rampart ${x}/${y} 移除成功`;
                }
            }
            return `[rampart] rampart ${x}/${y} 移除失败`;
        },
    },
    frame: {
        // 添加控制某房间 [添加了房间才会运行代码]
        add(roomName, plan, x, y) {
            let thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[frame] 不存在房间${roomName}`;
            Memory.RoomControlData[roomName] = { arrange: plan, center: [x, y] };
            return `[frame] 房间${roomName}加入房间控制列表，布局${plan}，中心点[${x}, ${y}]`;
        },
        // 移除本代码对某房间的控制
        remove(roomName) {
            delete Memory.RoomControlData[roomName];
            return `[frame] 删除房间${roomName}出房间控制列表`;
        },
        // 删除某房间的建筑
        del(roomName, x, y, mold) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[frame] 未找到房间${roomName}, 请确认房间!`;
            var thisPosition = new RoomPosition(x, y, roomName);
            if (thisPosition.GetStructure(mold)) {
                myRoom.unbindMemory(mold, x, y);
                return `[frame] 房间${roomName}已经执行delStructure命令!`;
            }
            else {
                let cons = thisPosition.lookFor(LOOK_CONSTRUCTION_SITES);
                if (cons.length > 0 && cons[0].structureType == mold) {
                    myRoom.unbindMemory(mold, x, y);
                    return `[frame] 房间${roomName}已经执行delStructure命令!`;
                }
            }
            return `[frame] 房间${roomName}未找到相应建筑!`;
        },
        // 删除某房间的建筑
        delType(roomName, mold, my) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[frame] 未找到房间${roomName}, 请确认房间!`;
            if (!mold)
                return `[frame] 未定义类型!`;
            var clostStructure = myRoom.find(FIND_HOSTILE_STRUCTURES, {
                filter: (struc) => {
                    return struc.structureType == mold;
                }
            });
            console.log(clostStructure.length);
            for (let _data of clostStructure) {
                _data.destroy();
            }
            return `[frame] 房间${roomName}已清理类型!`;
        },
        // 查询任务
        task(roomName) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[frame] 未找到房间${roomName}, 请确认房间!`;
            let result = `[frame] 房间${roomName}任务数据如下:\n`;
            for (var rangeName in myRoom.memory.Misson) {
                if (Object.keys(myRoom.memory.Misson[rangeName]).length <= 0) {
                    result += `不存在${rangeName}类任务\n`;
                }
                else {
                    result += `------------[${rangeName}]-------------\n`;
                    for (var i of myRoom.memory.Misson[rangeName]) {
                        result += `${i.name} | 超时:${i.delayTick}, ID:${i.id}, `;
                        if (i.Data) {
                            if (i.Data.disRoom)
                                result += `目标房间:${i.Data.disRoom}, `;
                            if (i.Data.rType)
                                result += `rType:${i.Data.rType}, `;
                            if (i.Data.num)
                                result += `num:${i.Data.num}, `;
                        }
                        result += `\n`;
                    }
                }
            }
            return result;
        },
        // 经济模式 （不再升级）
        economy(roomName) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[frame] 未找到房间${roomName}, 请确认房间!`;
            myRoom.memory.economy = !myRoom.memory.economy;
            if (!myRoom.memory.economy) {
                myRoom.memory.SpawnConfig['upgrade'].num = 1;
            }
            return `[frame] 房间${roomName}的economy选项改为${myRoom.memory.economy}`;
        },
        allEconomy() {
            Memory.Systemswitch.SystemEconomy = !Memory.Systemswitch.SystemEconomy;
            if (!Memory.Systemswitch.SystemEconomy) {
                return `[frame] 关闭全局经济模式(自动烧帕瓦)`;
            }
            return `[frame] 启用全局经济模式(自动烧帕瓦)`;
        },
        allUpgrade() {
            Memory.Systemswitch.SystemUpgrade = !Memory.Systemswitch.SystemUpgrade;
            if (!Memory.Systemswitch.SystemUpgrade) {
                return `[frame] 关闭全局GCL模式(强制Upgrade)`;
            }
            return `[frame] 启用全局GCL模式(强制Upgrade)`;
        },
        speedup(roomName, enable) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[frame] 未找到房间${roomName}, 请确认房间!`;
            if (myRoom.controller.level > 6 && !myRoom.memory.switch.speedstate)
                return `[frame] controller等级过高无法开启`;
            if (enable !== undefined) {
                myRoom.memory.switch.speedstate = enable;
            }
            else {
                myRoom.memory.switch.speedstate = !myRoom.memory.switch.speedstate;
            }
            if (!myRoom.memory.switch.speedstate) {
                myRoom.NumSpawn('initial_speed', 0);
                return `[frame]  房间${roomName}新房快速初始化关闭`;
            }
            myRoom.NumSpawn('initial_speed', RoleLevelData['initial_speed'][myRoom.controller.level].num);
            return `[frame]  房间${roomName}新房快速初始化开启`;
        },
        mineral(roomName) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[frame] 未找到房间${roomName}, 请确认房间!`;
            myRoom.memory.switch.stopmineral = !myRoom.memory.switch.stopmineral;
            if (!myRoom.memory.switch.stopmineral)
                return `[frame] 房间${roomName}开启原矿开采关闭原矿开采`;
            return `[frame] 房间${roomName}关闭原矿开采`;
        }
    },
    spawn: {
        num(roomName, role, num) {
            let thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[spawn] 不存在房间${roomName}`;
            let roleConfig = thisRoom.memory.SpawnConfig[role];
            if (roleConfig) {
                roleConfig.num = num;
                return `[spawn] 房间${roomName}的${role}数量信息修改为${num}`;
            }
            return `[spawn] 房间${roomName}的${role}数量信息修改失败`;
        },
        // 修改某任务爬虫绑定数据的num
        Mnum(roomName, id, role, num) {
            let thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[spawn] 不存在房间${roomName}`;
            let misson = thisRoom.GainMission(id);
            if (misson && misson.CreepBind[role]) {
                misson.CreepBind[role].num = num;
                return `[spawn] 任务${id}的${role}数量信息修改为${num}`;
            }
            return `[spawn] 任务${id}的${role}数量信息修改失败`;
        },
        // 只对任务爬虫的定时孵化有效
        restart(roomName, id) {
            let thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[spawn] 不存在房间${roomName}`;
            let misson = thisRoom.GainMission(id);
            if (misson) {
                delete misson.Data.intervalTime;
                return `[spawn] 任务${misson.name}<id:${id}>孵化信息已经初始化!`;
            }
            return `[spawn] 找不到id为${id}的任务!`;
        },
        altConfig(roomName, role, num) {
            let thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[spawn] 不存在房间${roomName}`;
            let level = thisRoom.controller.level;
            if (num > 2 || num < 1)
                return `[spawn] 没有更多的配置信息`;
            if (!RoleLevelData[role])
                return `[spawn] ${role} 角色等级配置不存在`;
            if (!RoleLevelData[role][level])
                return `[spawn] ${role} 角色等级配置不存在`;
            if (!RoleLevelData[role][level].upbodypart)
                return `[spawn] ${role} 没有角色配置`;
            thisRoom.memory.UpgradespawnConfig[role] = num;
            return `[spawn] 房间${roomName} 角色 ${role} 变更成功`;
        },
        extraTransport(roomName, num = null) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[repair] 不存在房间${roomName}`;
            thisRoom.memory.DynamicConfig.Dynamictransport = num;
            if (num) {
                return `[spawn] 房间${roomName}启用额外transport,数量${num}!`;
            }
            return `[spawn] 房间${roomName}关闭额外transport!`;
        }
    },
    link: {
        comsume(roomName, id) {
            let thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[link] 不存在房间${roomName}`;
            if (isInArray(thisRoom.memory.StructureIdData.source_links, id))
                return `[link] id错误, 不能为source_link`;
            if (id == thisRoom.memory.StructureIdData.center_link || id == thisRoom.memory.StructureIdData.upgrade_link)
                return `[link] id错误，不能为center_link/upgrade_link`;
            if (!isInArray(thisRoom.memory.StructureIdData.comsume_link, id))
                thisRoom.memory.StructureIdData.comsume_link.push(id);
            return Colorful$1(`[link] 房间${roomName} id为${id}的link已加入comsume_link列表中`, 'green', true);
        }
    },
    debug: {
        ResourceDispatch(roomName, rType, num, mtype, buy = false) {
            let dispatchTask = {
                sourceRoom: roomName,
                rType: rType,
                num: num,
                delayTick: 300,
                conditionTick: 20,
                buy: buy,
                mtype: mtype
            };
            Memory.ResourceDispatchData.push(dispatchTask);
            return `[debug] 资源调度任务发布, 房间${roomName}, 资源类型${rType}, 数量${num}, 支持购买:${buy}, 默认超时300T`;
        },
        ResourceBuy(roomName, rType, num, range, max = 35) {
            let thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[link] 不存在房间${roomName}`;
            let task = thisRoom.public_Buy(rType, num, range, max);
            if (task && thisRoom.AddMission(task))
                return Colorful$1(`[debug] 资源购买任务发布, 房间${roomName}, 资源类型${rType}, 数量${num}, 价格范围${range}, 最高价格${max}`, 'blue');
            return Colorful$1(`[debug] 房间${roomName}资源购买任务发布失败!`, 'yellow');
        }
    },
    dispatch: {
        show(roomName) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[dispatch] 未找到房间${roomName}, 请确认房间!`;
            let result = `[dispatch] 房间${roomName}的ResourceLimit信息如下:\n`;
            let data = global.ResourceLimit[roomName];
            if (Object.keys(data).length <= 0)
                return `[dispatch] 房间${roomName}没有ResourceLimit信息!`;
            for (var i of Object.keys(data))
                result += `[${i}] : ${data[i]}\n`;
            return result;
        }
    },
    /*帕瓦的供应设置模块*/
    powerSupply: {
        /*添加帕瓦供应的房间列表*/
        add(roomNames) {
            if (!Memory.PowerSupply)
                Memory.PowerSupply = [];
            var myRoom = Game.rooms[roomNames];
            if (!myRoom)
                return `[powersupply] 未找到房间${roomNames}, 请确认房间!`;
            // 确保新增的房间名不会重复
            Memory.PowerSupply = _.uniq([...Memory.PowerSupply, roomNames]);
            return `[powersupply]已添加供应房间 \n ${this.show()}`;
        },
        show() {
            if (!Memory.PowerSupply || Memory.PowerSupply.length <= 0)
                return '[powersupply]当前power供应房间';
            return `[powersupply]当前power供应房间列表: ${Memory.PowerSupply.join(' ')}`;
        },
        clean() {
            Memory.PowerSupply = [];
            return `[powersupply]已清空供应房间列表，当前列表: ${Memory.PowerSupply.join(' ')}`;
        },
        remove(roomNames) {
            if (!Memory.PowerSupply)
                Memory.PowerSupply = [];
            if (roomNames.length <= 0)
                delete Memory.PowerSupply;
            else
                Memory.PowerSupply = _.difference(Memory.PowerSupply, [roomNames]);
            return `[powersupply]已移除供应房间${roomNames}`;
        }
    }
};

/**
 * 存放非任务类型角色相关的函数
*/
// 采矿工
function harvest_(creep_) {
    var _a, _b;
    if (!Game.rooms[creep_.memory.belong])
        return;
    creep_.workstate('energy');
    let harvestData = Game.rooms[creep_.memory.belong].memory.harvestData;
    if (!harvestData)
        return;
    // let data = null;
    // if (creep_.memory.targetID) {
    //     data = harvestData[creep_.memory.targetID]
    //     if (!data) return
    // }
    if (creep_.memory.working) {
        let data = harvestData[creep_.memory.targetID];
        if (!data)
            return;
        // 优先寻找link
        if (data.linkID) {
            if (data.containerID && ((_a = creep_.room.controller) === null || _a === void 0 ? void 0 : _a.level) >= 7) {
                let container = Game.getObjectById(data.containerID);
                if (container)
                    frameExtension.frame.del(creep_.room.name, container.pos.x, container.pos.y, STRUCTURE_CONTAINER);
                delete data.containerID;
            }
            let link = Game.getObjectById(data.linkID);
            if (!link)
                delete data.linkID;
            else {
                if (link.hits < link.hitsMax) {
                    creep_.repair(link);
                    return;
                }
                if (creep_.pos.isNearTo(link)) {
                    if (link.store.getFreeCapacity('energy') > 0) {
                        creep_.transfer(link, 'energy');
                        return;
                    }
                }
                else {
                    creep_.goTo(link.pos, 1, 100);
                    return;
                }
            }
        }
        else if (data.containerID) {
            let container = Game.getObjectById(data.containerID);
            if (!container)
                delete data.containerID;
            else {
                if (container.hits < container.hitsMax) {
                    creep_.repair(container);
                    return;
                }
                if (creep_.pos.isEqualTo(container)) {
                    creep_.transfer(container, 'energy');
                    return;
                }
                else {
                    creep_.goTo(container.pos, 0, 100);
                    return;
                }
            }
        }
        else {
            /* 最后寻找附近的建筑工地 -补全container或link*/
            let cons = creep_.pos.findInRange(FIND_MY_CONSTRUCTION_SITES, 3);
            if (cons.length > 0) {
                creep_.build(cons[0]);
                return;
            }
            if (((_b = creep_.room.controller) === null || _b === void 0 ? void 0 : _b.level) <= 4) {
                let containers = creep_.pos.findInRange(FIND_STRUCTURES, 1, { filter: (stru) => { return stru.structureType == 'container'; } });
                if (containers.length <= 0) {
                    creep_.pos.createConstructionSite('container');
                    return;
                }
            }
        }
    }
    else {
        // 如果不具备挖矿功能了，就自杀
        if (creep_.hits < creep_.hitsMax) {
            if (creep_.getActiveBodyparts('work') <= 0) {
                creep_.suicide();
            }
        }
        // 绑定矿点
        if (!creep_.memory.targetID) {
            for (var i in harvestData) {
                var data_ = harvestData[i];
                if (data_.carry == creep_.name) {
                    creep_.memory.targetID = i;
                    break;
                }
                if (!data_.harvest || !Game.creeps[data_.harvest]) {
                    creep_.memory.targetID = i;
                    data_.harvest = creep_.name;
                    break;
                }
            }
            return;
        }
        /* 寻找target附近的container */
        let source = Game.getObjectById(creep_.memory.targetID);
        if (!source)
            return;
        if (source.energy > 0) {
            if (creep_.harvest(source) == ERR_NOT_IN_RANGE) {
                creep_.goTo(source.pos, 1, 1000);
                return;
            }
        }
        else {
            if (Game.time % 2)
                return;
            let data = harvestData[creep_.memory.targetID];
            if (!data)
                return;
            if (!data.containerID || !data.linkID)
                return;
            let container = Game.getObjectById(data.containerID);
            if (!container)
                return;
            let container_energy = container.store.getUsedCapacity(RESOURCE_ENERGY);
            if (container_energy < 1) {
                if (source.energy < 1 && source.ticksToRegeneration > 0) {
                    /*进行空置操作*/
                    creep_.memory.Rerunt = Number(Game.time) + Number(source.ticksToRegeneration);
                }
                return; /*容器没有能量终止*/
            }
            let link = Game.getObjectById(data.linkID);
            if (!link)
                return;
            let link_energy = link.store.getFreeCapacity(RESOURCE_ENERGY);
            if (link_energy < 1)
                return; /*link已满终止*/
            if (creep_.withdraw(container, RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {
                creep_.moveTo(container);
            }
        }
    }
}
// 搬运工
function carry_(creep_) {
    if (!Game.rooms[creep_.memory.belong])
        return;
    creep_.workstate('energy');
    if (!creep_.memory.containerID) {
        var harvestData = Game.rooms[creep_.memory.belong].memory.harvestData;
        if (!harvestData)
            return;
        if (Object.keys(harvestData).length == 0)
            return;
        else if (Object.keys(harvestData).length > 1) {
            for (var i in Game.rooms[creep_.memory.belong].memory.harvestData) {
                var data_ = Game.rooms[creep_.memory.belong].memory.harvestData[i];
                if (data_.linkID)
                    continue;
                if (!data_.containerID)
                    continue;
                if (data_.carry == creep_.name) {
                    creep_.memory.containerID = data_.containerID;
                    break;
                }
                if ((!data_.carry || !Game.creeps[data_.carry]) && data_.containerID) {
                    creep_.memory.containerID = data_.containerID;
                    data_.carry = creep_.name;
                    break;
                }
            }
            return;
        }
        else {
            var harvestData_ = harvestData[Object.keys(harvestData)[0]];
            if (harvestData_.containerID) {
                let container = Game.getObjectById(harvestData_.containerID);
                if (!container)
                    delete harvestData_.containerID;
                else {
                    creep_.memory.containerID = harvestData_.containerID;
                }
            }
            else
                creep_.say("oh No!");
            return;
        }
    }
    if (creep_.memory.working) {
        if (creep_.room.controller.level < 7) {
            var target_c = creep_.pos.findClosestByRange(FIND_STRUCTURES, {
                filter: (stru) => {
                    return isInArray(['tower', 'spawn', 'extension'], stru.structureType) && stru.store.getFreeCapacity('energy') > 0;
                }
            });
            if (target_c) {
                creep_.transfer_(target_c, 'energy');
                return;
            }
        }
        let target = null;
        if (Game.rooms[creep_.memory.belong].storage) // 优先仓库
         {
            target = Game.rooms[creep_.memory.belong].storage;
        }
        if (!target) // 其次虫卵
         {
            target = creep_.pos.getClosestStore();
        }
        if (!target) // 再其次防御塔
         {
            target = creep_.pos.findClosestByRange(FIND_STRUCTURES, {
                filter: (stru) => {
                    return stru.structureType == 'tower' && stru.store.getFreeCapacity('energy') > creep_.store.getUsedCapacity('energy');
                }
            });
        }
        if (!target)
            return;
        creep_.transfer_(target, 'energy');
    }
    else {
        let container = Game.getObjectById(creep_.memory.containerID);
        if (!container) {
            /* 删除房间相关的记忆 */
            for (var hdata in Game.rooms[creep_.memory.belong].memory.harvestData) {
                if (Game.rooms[creep_.memory.belong].memory.harvestData[hdata].containerID && Game.rooms[creep_.memory.belong].memory.harvestData[hdata].containerID == creep_.memory.containerID) {
                    delete Game.rooms[creep_.memory.belong].memory.harvestData[hdata].containerID;
                }
            }
            /* 删除爬虫相关记忆 */
            delete creep_.memory.containerID;
            return;
        }
        if (!creep_.pos.isNearTo(container))
            creep_.goTo(container.pos, 1);
        else {
            if (container.store.getUsedCapacity('energy') > creep_.store.getFreeCapacity())
                creep_.withdraw(container, 'energy');
        }
    }
}
// 升级工
function upgrade_(creep_) {
    var _a, _b;
    if (!Game.rooms[creep_.memory.belong])
        return;
    creep_.workstate('energy', 0.5);
    if (creep_.room.memory.state == 'peace' && creep_.hits < creep_.hitsMax) {
        creep_.optTower('heal', creep_);
    }
    if (creep_.memory.working) {
        creep_.upgrade_(300);
        if (creep_.memory.targetID && creep_.store.getFreeCapacity() > creep_.store.getCapacity() * 0.5) {
            let target = Game.getObjectById(creep_.memory.targetID);
            if (target)
                creep_.withdraw_(target, 'energy');
        }
    }
    else {
        if (((_a = creep_.room.controller) === null || _a === void 0 ? void 0 : _a.level) < 6 && creep_.room.memory.switch.speedstate) {
            var find_tombstones = creep_.pos.findClosestByRange(FIND_TOMBSTONES, {
                filter: (structure) => {
                    return structure.store.getUsedCapacity('energy') > 0;
                }
            });
            if (find_tombstones) {
                if (creep_.withdraw(find_tombstones, RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {
                    creep_.moveTo(find_tombstones);
                }
                return;
            }
        }
        if (((_b = creep_.room.controller) === null || _b === void 0 ? void 0 : _b.level) < 8) {
            if (Game.flags[`${creep_.memory.belong}/ruin`]) {
                if (!creep_.pos.isNearTo(Game.flags[`${creep_.memory.belong}/ruin`]))
                    creep_.goTo(Game.flags[`${creep_.memory.belong}/ruin`].pos, 1);
                else {
                    let ruin = Game.flags[`${creep_.memory.belong}/ruin`].pos.lookFor(LOOK_RUINS);
                    let swi = false;
                    for (var i of ruin) {
                        if (i.store.getUsedCapacity('energy') > 0) {
                            creep_.withdraw(i, 'energy');
                            swi = true;
                            return;
                        }
                    }
                    if (!swi)
                        Game.flags[`${creep_.memory.belong}/ruin`].remove();
                }
                return;
            }
        }
        if (!creep_.memory.targetID) {
            let target = null;
            if (creep_.room.controller.level < 8 && creep_.room.terminal && !Game.rooms[creep_.memory.belong].memory.StructureIdData.upgrade_link) {
                target = creep_.room.terminal;
            }
            else {
                if (Game.rooms[creep_.memory.belong].memory.StructureIdData.upgrade_link) // 优先Link
                 {
                    target = Game.getObjectById(Game.rooms[creep_.memory.belong].memory.StructureIdData.upgrade_link);
                    if (!target)
                        delete Game.rooms[creep_.memory.belong].memory.StructureIdData.upgrade_link;
                }
                else if (Game.rooms[creep_.memory.belong].storage) // 优先仓库
                 {
                    target = Game.rooms[creep_.memory.belong].storage;
                }
                if (!target) // 其次container
                 {
                    target = creep_.pos.findClosestByRange(FIND_STRUCTURES, {
                        filter: (stru) => {
                            return stru.structureType == 'container' && stru.store.getUsedCapacity('energy') > creep_.store.getFreeCapacity();
                        }
                    });
                }
            }
            if (!target) {
                return;
            }
            else {
                creep_.memory.targetID = target.id;
            }
        }
        else {
            let target = Game.getObjectById(creep_.memory.targetID);
            if (target)
                creep_.withdraw_(target, 'energy');
        }
    }
}
// 建筑工
function build_(creep) {
    var thisRoom = Game.rooms[creep.memory.belong];
    if (!thisRoom)
        return;
    if (!creep.memory.standed)
        creep.memory.standed = false;
    creep.workstate('energy');
    if (creep.memory.working) {
        if (thisRoom.controller.level < 8) {
            var target = creep.pos.findClosestByRange(FIND_STRUCTURES, {
                filter: (stru) => {
                    return isInArray(['tower', 'spawn'], stru.structureType) && stru.store.getFreeCapacity('energy') > 0;
                }
            });
            if (target) {
                let _number = getDistance(target.pos, creep.pos);
                if (_number < 7) {
                    creep.transfer_(target, 'energy');
                    return;
                }
            }
        }
        var construction = creep.pos.findClosestByRange(FIND_MY_CONSTRUCTION_SITES);
        if (construction) {
            creep.build_(construction);
        }
        else {
            if (creep.room.controller.level < 3) {
                /* 没有建筑物则考虑道路维护 */
                var roads = creep.pos.findClosestByRange(FIND_STRUCTURES, {
                    filter: (structure) => {
                        return structure.structureType == 'road' && structure.hits < structure.hitsMax;
                    }
                });
                if (roads) {
                    // creep.say("🛠️", true)
                    if (creep.repair(roads) == ERR_NOT_IN_RANGE) {
                        creep.goTo(roads.pos, 1);
                    }
                    if (getDistance(creep.pos, roads.pos) <= 3)
                        creep.memory.standed = false;
                }
            }
            else {
                if (global.Repairlist[thisRoom.name].length > 0) {
                    let Repairdata = Game.getObjectById(global.Repairlist[thisRoom.name][0]);
                    if (!Repairdata) {
                        global.Repairlist[thisRoom.name].shift();
                        return;
                    }
                    if (Repairdata.hits >= Repairdata.hitsMax) {
                        global.Repairlist[thisRoom.name].shift();
                        return;
                    }
                    if (creep.repair(Repairdata) == ERR_NOT_IN_RANGE) {
                        creep.goTo(Repairdata.pos, 2);
                    }
                }
            }
        }
    }
    else {
        creep.memory.standed = false;
        if (Game.flags[`${creep.memory.belong}/withdraw`]) {
            let tank_ = Game.flags[`${creep.memory.belong}/withdraw`].pos.GetStructureList(['storage', 'terminal', 'container', 'tower']);
            if (tank_.length > 0) {
                creep.withdraw_(tank_[0], 'energy');
                return;
            }
        }
        if (Game.flags[`${creep.memory.belong}/ruin`]) {
            if (!creep.pos.isNearTo(Game.flags[`${creep.memory.belong}/ruin`]))
                creep.goTo(Game.flags[`${creep.memory.belong}/ruin`].pos, 1);
            else {
                let ruin = Game.flags[`${creep.memory.belong}/ruin`].pos.lookFor(LOOK_RUINS);
                let swi = false;
                for (var i of ruin) {
                    if (i.store.getUsedCapacity('energy') > 0) {
                        creep.withdraw(i, 'energy');
                        swi = true;
                        return;
                    }
                }
                if (!swi)
                    Game.flags[`${creep.memory.belong}/ruin`].remove();
            }
            return;
        }
        /* 如果有storage就去storage里找，没有就自己采集 */
        if (creep.room.storage) {
            if (creep.room.storage.store.getUsedCapacity('energy') >= creep.store.getCapacity()) {
                creep.withdraw_(creep.room.storage, 'energy');
                return;
            }
        }
        if (creep.room.terminal) {
            if (creep.room.terminal.store.getUsedCapacity('energy') >= creep.store.getCapacity()) {
                creep.withdraw_(creep.room.terminal, 'energy');
                return;
            }
        }
        var container = creep.pos.findClosestByRange(FIND_STRUCTURES, { filter: (stru) => { return stru.structureType == 'container' && stru.store.getUsedCapacity('energy') > creep.store.getCapacity(); } });
        if (container) {
            if (!creep.pos.isNearTo(container)) {
                creep.goTo(container.pos, 1);
            }
            else {
                creep.withdraw(container, 'energy');
            }
        }
        else {
            /*进行资源采集*/
            const target = creep.pos.findClosestByRange(FIND_SOURCES);
            if (creep.harvest(target) == ERR_NOT_IN_RANGE) {
                creep.goTo(target.pos, 1);
            }
        }
    }
}
/*新房起步专用*/
function initial_speed_(creep) {
    var thisRoom = Game.rooms[creep.memory.belong];
    if (!thisRoom)
        return;
    if (!creep.memory.standed)
        creep.memory.standed = false;
    creep.workstate('energy');
    if (creep.memory.working) {
        /*检查是否有需要填充的单位*/
        if (thisRoom.controller.level <= 2) {
            var target = creep.pos.findClosestByRange(FIND_STRUCTURES, {
                filter: (stru) => {
                    return isInArray(['spawn', 'extension'], stru.structureType) && stru.store.getFreeCapacity('energy') > 0;
                }
            });
            if (target) {
                creep.transfer_(target, 'energy');
                return;
            }
        }
        else {
            if (thisRoom.controller.level <= 4) {
                var target = creep.pos.findClosestByRange(FIND_STRUCTURES, {
                    filter: (stru) => {
                        return isInArray(['tower', 'spawn'], stru.structureType) && stru.store.getFreeCapacity('energy') > 0;
                    }
                });
                if (target) {
                    let _number = getDistance(target.pos, creep.pos);
                    if (_number < 7) {
                        creep.transfer_(target, 'energy');
                        return;
                    }
                }
            }
        }
        /*检查是否有工地*/
        var construction = creep.pos.findClosestByRange(FIND_MY_CONSTRUCTION_SITES);
        if (construction) {
            creep.build_(construction);
        }
        else {
            if (!creep.pos.inRangeTo(creep.room.controller, 2)) {
                creep.goTo(creep.room.controller.pos, 2);
            }
            else {
                creep.upgrade_();
            }
            // if (creep.room.controller) {
            //     if (creep.upgradeController(creep.room.controller) == ERR_NOT_IN_RANGE) {
            //         // this.goTo(this.room.controller.pos, 3)
            //         creep.memory.standed = false
            //     }
            //     else creep.memory.standed = true
            // }
            // 
        }
    }
    else {
        /*搜索掉落的资源*/
        var find_dropped_resources = creep.pos.findClosestByRange(FIND_DROPPED_RESOURCES, {
            filter: (res) => {
                return res.amount > 100 && res.resourceType == 'energy';
            }
        });
        if (find_dropped_resources) {
            if (!creep.pos.isNearTo(find_dropped_resources))
                creep.goTo(find_dropped_resources.pos, 1);
            else
                creep.pickup(find_dropped_resources);
            return;
        }
        /*搜索墓碑*/
        var find_tombstones = creep.pos.findClosestByRange(FIND_TOMBSTONES, {
            filter: (structure) => {
                return structure.store.getUsedCapacity('energy') > 0;
            }
        });
        if (find_tombstones) {
            if (creep.withdraw(find_tombstones, RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {
                creep.moveTo(find_tombstones);
            }
            return;
        }
        /*搜索地上的废墟*/
        var find_ruins = creep.pos.findClosestByRange(FIND_RUINS, {
            filter: (structure) => {
                return structure.store.getUsedCapacity('energy') > 0;
            }
        });
        if (find_ruins) {
            if (creep.withdraw(find_ruins, RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {
                creep.moveTo(find_ruins);
            }
            return;
        }
        if (creep.room.storage) {
            if (creep.room.storage.store.getUsedCapacity('energy') > 1000) {
                if (creep.withdraw(creep.room.storage, RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {
                    creep.moveTo(creep.room.storage);
                }
                return;
            }
        }
        /*进行采集*/
        var find_sources = creep.pos.findClosestByRange(FIND_SOURCES, {
            filter: (structure) => {
                return structure.energy > 0;
            }
        });
        if (find_sources) {
            creep.harvest_(find_sources);
            return;
        }
    }
}

/* 爬虫信息列表 */
const RoleData = {
    'harvest': { num: 0, ability: [1, 1, 2, 0, 0, 0, 0, 0], adaption: true, level: 3, mark: "⛏️", must: false, init: true, fun: harvest_ },
    'carry': { num: 0, ability: [0, 3, 3, 0, 0, 0, 0, 0], level: 4, mark: "🚜", init: true, must: false, adaption: true, fun: carry_ },
    'upgrade': { num: 0, ability: [1, 1, 2, 0, 0, 0, 0, 0], level: 10, mark: "🚬", init: true, fun: upgrade_ },
    'build': { num: 0, ability: [1, 1, 2, 0, 0, 0, 0, 0], level: 10, mark: "🔨", init: true, fun: build_, must: true },
    'manage': { num: 0, ability: [0, 1, 1, 0, 0, 0, 0, 0], level: 1, mark: "🗃️", init: true, must: true, adaption: true },
    'transport': { num: 0, ability: [0, 2, 2, 0, 0, 0, 0, 0], level: 2, mark: "📦", init: true, must: true, adaption: true },
    'initial_speed': { num: 0, ability: [1, 1, 2, 0, 0, 0, 0, 0], level: 5, mark: "⛏️", must: false, init: true, adaption: true, fun: initial_speed_ },
    'repair': { num: 0, ability: [1, 1, 1, 0, 0, 0, 0, 0], level: 8, mark: "🧱", must: true },
    'cclaim': { num: 0, ability: [0, 0, 5, 0, 0, 0, 1, 0], level: 10, mark: "🐱" },
    'cupgrade': { num: 0, ability: [2, 5, 7, 0, 0, 0, 0, 0], level: 11, mark: "🐱" },
    'dismantle': { num: 0, ability: [25, 0, 25, 0, 0, 0, 0, 0], level: 11, mark: "⚡" },
    'rush': { num: 0, ability: [10, 2, 5, 0, 0, 0, 0, 0], level: 6, mark: "🚬", must: true },
    'truck': { num: 0, ability: [0, 10, 10, 0, 0, 0, 0, 0], level: 9, mark: "✈️" },
    'truckshard': { num: 0, ability: [0, 5, 5, 0, 0, 0, 0, 0], level: 9, mark: "✈️" },
    'gleaner': { num: 0, ability: [0, 5, 5, 0, 0, 0, 0, 0], level: 9, mark: "✈️" },
    'steal': { num: 0, ability: [0, 5, 5, 0, 0, 0, 0, 0], level: 9, mark: "✈️" },
    'claim': { num: 0, ability: [0, 0, 5, 0, 0, 0, 1, 0], level: 10, mark: "🟣" },
    'Ebuild': { num: 0, ability: [1, 1, 2, 0, 0, 0, 0, 0], level: 13, mark: "🛠️" },
    'Eupgrade': { num: 0, ability: [1, 1, 2, 0, 0, 0, 0, 0], level: 13, mark: "🚬" },
    'double-attack': { num: 0, ability: [0, 0, 10, 28, 0, 0, 0, 12], level: 10, mark: "⚔️", must: true },
    'double-heal': { num: 0, ability: [0, 0, 10, 0, 2, 27, 0, 11], level: 10, mark: "🩹", must: true },
    'double-dismantle': { num: 0, ability: [28, 0, 10, 0, 0, 0, 0, 12], level: 10, mark: "⚒️", must: true },
    'claim-attack': { num: 0, ability: [0, 0, 15, 0, 0, 0, 15, 0], level: 10, mark: "🟣" },
    'architect': { num: 0, ability: [15, 10, 10, 0, 0, 10, 0, 5], level: 10, mark: "🚒" },
    'upgrade-work': { num: 0, ability: [5, 20, 10, 0, 0, 10, 0, 5], level: 10, mark: "🔨" },
    'repair-work': { num: 0, ability: [1, 1, 1, 0, 0, 0, 0, 0], level: 8, mark: "🧱", must: true },
    'scout': { num: 0, ability: [0, 0, 1, 0, 0, 0, 0, 0], level: 15, mark: '✏️' },
    'aio': { num: 0, ability: [0, 0, 25, 0, 13, 12, 0, 0], level: 10, mark: "⚡" },
    'saio': { num: 0, ability: [0, 0, 25, 0, 10, 15, 0, 0], level: 10, mark: "⚡" },
    'mineral': { num: 0, ability: [15, 15, 15, 0, 0, 0, 0, 0], level: 11, mark: "🪓" },
    /*本房间拆迁队*/
    'r-dismantle': { num: 0, ability: [10, 0, 5, 0, 0, 0, 0, 0], level: 11, mark: "⚡" },
    'r-carry': { num: 0, ability: [0, 10, 5, 0, 0, 0, 0, 0], level: 10, mark: "📦" },
    /* 外矿 */
    'out-claim': { num: 0, ability: [0, 0, 2, 0, 0, 0, 2, 0], level: 11, mark: "🟣" },
    'out-harvest': { num: 0, ability: [4, 2, 4, 0, 0, 0, 0, 0], level: 12, mark: "⛏️" },
    'out-car': { num: 0, ability: [1, 5, 6, 0, 0, 0, 0, 0], level: 13, mark: "🚜" },
    'out-carry': { num: 0, ability: [0, 5, 5, 0, 0, 0, 0, 0], level: 13, mark: "🚜" },
    'out-defend': { num: 0, ability: [0, 0, 5, 5, 0, 5, 0, 0], level: 10, mark: "🧹" },
    'out-attack': { num: 0, ability: [0, 0, 25, 19, 0, 6, 0, 0], level: 10, mark: "⚔️" },
    /* 帕瓦 */
    'power-attack': { num: 0, ability: [0, 0, 25, 20, 0, 0, 0, 5], level: 10, mark: "🍎" },
    'power-heal': { num: 0, ability: [0, 0, 25, 0, 0, 25, 0, 0], level: 10, mark: "🍏" },
    'power-carry': { num: 0, ability: [0, 32, 16, 0, 0, 0, 0, 0], level: 10, mark: "📦" },
    /* 沉积物 */
    'deposit': { num: 0, ability: [15, 10, 25, 0, 0, 0, 0, 0], level: 11, mark: "⚙️" },
    'deposit-harvest': { num: 0, ability: [20, 10, 20, 0, 0, 0, 0, 0], level: 11, mark: "⚙️" },
    'deposit-transfer': { num: 0, ability: [0, 25, 25, 0, 0, 0, 0, 0], level: 11, mark: "⚙️" },
    /* 主动防御 */
    'defend-attack': { num: 0, ability: [0, 0, 10, 40, 0, 0, 0, 0], level: 8, mark: "🔴", must: true },
    'defend-range': { num: 0, ability: [0, 0, 10, 0, 40, 0, 0, 0], level: 8, mark: "🔵", must: true },
    'defend-douAttack': { num: 0, ability: [0, 0, 10, 25, 0, 0, 0, 15], level: 7, mark: "🔴", must: true },
    'defend-douHeal': { num: 0, ability: [0, 0, 10, 0, 0, 30, 0, 10], level: 7, mark: "🟢", must: true },
    /* 四人小队 */
    'x-dismantle': { num: 0, ability: [28, 0, 10, 0, 0, 0, 0, 12], level: 9, mark: "🟨", must: true, mem: { creepType: 'attack' } },
    'x-heal': { num: 0, ability: [0, 0, 10, 0, 2, 26, 0, 12], level: 9, mark: "🟩", must: true, mem: { creepType: 'heal' } },
    'x-attack': { num: 0, ability: [0, 0, 10, 28, 0, 0, 0, 12], level: 9, mark: "🟥", must: true, mem: { creepType: 'attack' } },
    'x-range': { num: 0, ability: [0, 0, 10, 0, 24, 4, 0, 12], level: 9, mark: "🟦", must: true, mem: { creepType: 'attack' } },
    'x-aio': { num: 0, ability: [0, 0, 10, 0, 10, 20, 0, 10], level: 9, mark: "🌈", must: true, mem: { creepType: 'heal' } },
    /*Ai战争*/
    'Ai-sentry': { num: 0, ability: [0, 0, 10, 0, 0, 20, 0, 20], level: 9, mark: "🚨", must: true, mem: { creepType: 'sentry' } },
    'c-construction-site': { num: 0, ability: [0, 0, 1, 0, 0, 0, 0, 0], level: 9, mark: "🥾", must: true },
};
/* 爬虫部件随房间等级变化的动态列表 */
const RoleLevelData = {
    'harvest': {
        1: { bodypart: [2, 1, 1, 0, 0, 0, 0, 0], num: 2 },
        2: { bodypart: [3, 1, 1, 0, 0, 0, 0, 0], num: 2 },
        3: { bodypart: [5, 1, 3, 0, 0, 0, 0, 0], num: 2 },
        4: { bodypart: [6, 1, 3, 0, 0, 0, 0, 0], num: 2 },
        5: { bodypart: [7, 2, 4, 0, 0, 0, 0, 0], num: 2 },
        6: { bodypart: [10, 2, 3, 0, 0, 0, 0, 0], num: 2 },
        7: { bodypart: [10, 2, 3, 0, 0, 0, 0, 0], num: 2 },
        8: { bodypart: [10, 2, 3, 0, 0, 0, 0, 0], num: 2, upbodypart: [20, 4, 6, 0, 0, 0, 0, 0] },
    },
    'initial_speed': {
        1: { bodypart: [1, 1, 2, 0, 0, 0, 0, 0], num: 2 },
        2: { bodypart: [3, 2, 3, 0, 0, 0, 0, 0], num: 6 },
        3: { bodypart: [4, 4, 4, 0, 0, 0, 0, 0], num: 6 },
        4: { bodypart: [5, 5, 10, 0, 0, 0, 0, 0], num: 6 },
        5: { bodypart: [10, 6, 10, 0, 0, 0, 0, 0], num: 5 },
        6: { bodypart: [10, 6, 10, 0, 0, 0, 0, 0], num: 0 },
        7: { bodypart: [10, 6, 10, 0, 0, 0, 0, 0], num: 0 },
        8: { bodypart: [10, 6, 10, 0, 0, 0, 0, 0], num: 0 },
    },
    'carry': {
        1: { bodypart: [0, 2, 2, 0, 0, 0, 0, 0], num: 2 },
        2: { bodypart: [0, 3, 3, 0, 0, 0, 0, 0], num: 2 },
        3: { bodypart: [0, 4, 4, 0, 0, 0, 0, 0], num: 2 },
        4: { bodypart: [0, 8, 8, 0, 0, 0, 0, 0], num: 2 },
        5: { bodypart: [0, 10, 10, 0, 0, 0, 0, 0], num: 2 },
        6: { bodypart: [0, 15, 15, 0, 0, 0, 0, 0], num: 1 },
        7: { bodypart: [0, 10, 10, 0, 0, 0, 0, 0], num: 0 },
        8: { bodypart: [0, 10, 10, 0, 0, 0, 0, 0], num: 0 },
    },
    'upgrade': {
        1: { bodypart: [1, 1, 2, 0, 0, 0, 0, 0], num: 3 },
        2: { bodypart: [2, 2, 4, 0, 0, 0, 0, 0], num: 3 },
        3: { bodypart: [3, 3, 6, 0, 0, 0, 0, 0], num: 3 },
        4: { bodypart: [4, 4, 8, 0, 0, 0, 0, 0], num: 2 },
        5: { bodypart: [6, 6, 12, 0, 0, 0, 0, 0], num: 2, upbodypart: [5, 10, 15, 0, 0, 0, 0, 0] },
        6: { bodypart: [7, 7, 14, 0, 0, 0, 0, 0], num: 1, upbodypart: [7, 7, 14, 0, 0, 0, 0, 0] },
        7: { bodypart: [10, 2, 3, 0, 0, 0, 0, 0], num: 1, upbodypart: [10, 2, 3, 0, 0, 0, 0, 0] },
        8: { bodypart: [15, 1, 4, 0, 0, 0, 0, 0], num: 1, upbodypart: [10, 2, 3, 0, 0, 0, 0, 0] },
    },
    'build': {
        1: { bodypart: [1, 1, 2, 0, 0, 0, 0, 0], num: 0 },
        2: { bodypart: [2, 2, 4, 0, 0, 0, 0, 0], num: 0 },
        3: { bodypart: [3, 3, 6, 0, 0, 0, 0, 0], num: 0 },
        4: { bodypart: [4, 4, 8, 0, 0, 0, 0, 0], num: 1 },
        5: { bodypart: [4, 10, 7, 0, 0, 0, 0, 0], num: 0 },
        6: { bodypart: [5, 5, 10, 0, 0, 0, 0, 0], num: 0 },
        7: { bodypart: [10, 10, 10, 0, 0, 0, 0, 0], num: 0 },
        8: { bodypart: [15, 15, 15, 0, 0, 0, 0, 0], num: 0 },
    },
    'transport': {
        1: { bodypart: [0, 1, 1, 0, 0, 0, 0, 0], num: 0 },
        2: { bodypart: [0, 1, 1, 0, 0, 0, 0, 0], num: 0 },
        3: { bodypart: [0, 2, 2, 0, 0, 0, 0, 0], num: 0 },
        4: { bodypart: [0, 5, 5, 0, 0, 0, 0, 0], num: 1 },
        5: { bodypart: [0, 10, 10, 0, 0, 0, 0, 0], num: 1, upbodypart: [0, 10, 5, 0, 0, 0, 0, 0] },
        6: { bodypart: [0, 15, 15, 0, 0, 0, 0, 0], num: 1, upbodypart: [0, 15, 8, 0, 0, 0, 0, 0] },
        7: { bodypart: [0, 24, 24, 0, 0, 0, 0, 0], num: 1, upbodypart: [0, 24, 12, 0, 0, 0, 0, 0] },
        8: { bodypart: [0, 24, 24, 0, 0, 0, 0, 0], num: 1, upbodypart: [0, 24, 12, 0, 0, 0, 0, 0] },
    },
    'gleaner': {
        1: { bodypart: [0, 1, 1, 0, 0, 0, 0, 0], num: 0 },
        2: { bodypart: [0, 1, 1, 0, 0, 0, 0, 0], num: 0 },
        3: { bodypart: [0, 2, 2, 0, 0, 0, 0, 0], num: 0 },
        4: { bodypart: [0, 5, 5, 0, 0, 0, 0, 0], num: 0 },
        5: { bodypart: [0, 15, 15, 0, 0, 0, 0, 0], num: 0 },
        6: { bodypart: [0, 20, 20, 0, 0, 0, 0, 0], num: 0 },
        7: { bodypart: [0, 24, 24, 0, 0, 0, 0, 0], num: 0 },
        8: { bodypart: [0, 24, 24, 0, 0, 0, 0, 0], num: 0 },
    },
    'steal': {
        1: { bodypart: [0, 1, 1, 0, 0, 0, 0, 0], num: 0 },
        2: { bodypart: [0, 1, 1, 0, 0, 0, 0, 0], num: 0 },
        3: { bodypart: [0, 2, 2, 0, 0, 0, 0, 0], num: 0 },
        4: { bodypart: [0, 5, 5, 0, 0, 0, 0, 0], num: 0 },
        5: { bodypart: [0, 8, 8, 0, 0, 0, 0, 0], num: 0 },
        6: { bodypart: [0, 10, 10, 0, 0, 0, 0, 0], num: 0 },
        7: { bodypart: [0, 15, 15, 0, 0, 0, 0, 0], num: 0 },
        8: { bodypart: [0, 20, 20, 0, 0, 0, 0, 0], num: 0 },
    },
    'manage': {
        1: { bodypart: [0, 1, 1, 0, 0, 0, 0, 0], num: 0 },
        2: { bodypart: [0, 1, 1, 0, 0, 0, 0, 0], num: 0 },
        3: { bodypart: [0, 2, 2, 0, 0, 0, 0, 0], num: 0 },
        4: { bodypart: [0, 2, 2, 0, 0, 0, 0, 0], num: 1 },
        5: { bodypart: [0, 10, 5, 0, 0, 0, 0, 0], num: 1 },
        6: { bodypart: [0, 30, 15, 0, 0, 0, 0, 0], num: 1 },
        7: { bodypart: [0, 32, 16, 0, 0, 0, 0, 0], num: 1 },
        8: { bodypart: [0, 32, 16, 0, 0, 0, 0, 0], num: 1 },
    },
    'repair': {
        1: { bodypart: [1, 1, 2, 0, 0, 0, 0, 0], num: 0 },
        2: { bodypart: [1, 1, 2, 0, 0, 0, 0, 0], num: 0 },
        3: { bodypart: [2, 2, 4, 0, 0, 0, 0, 0], num: 0 },
        4: { bodypart: [2, 2, 4, 0, 0, 0, 0, 0], num: 0 },
        5: { bodypart: [5, 5, 5, 0, 0, 0, 0, 0], num: 0 },
        6: { bodypart: [8, 8, 8, 0, 0, 0, 0, 0], num: 0 },
        7: { bodypart: [10, 10, 10, 0, 0, 0, 0, 0], num: 0, upbodypart: [10, 20, 15, 0, 0, 0, 0, 0] },
        8: { bodypart: [15, 18, 17, 0, 0, 0, 0, 0], num: 0, upbodypart: [10, 20, 15, 0, 0, 0, 0, 0] },
    },
    'dismantle': {
        1: { bodypart: [1, 0, 1, 0, 0, 0, 0, 0], num: 0 },
        2: { bodypart: [2, 0, 2, 0, 0, 0, 0, 0], num: 0 },
        3: { bodypart: [3, 0, 3, 0, 0, 0, 0, 0], num: 0 },
        4: { bodypart: [3, 0, 3, 0, 0, 0, 0, 0], num: 0 },
        5: { bodypart: [6, 0, 6, 0, 0, 0, 0, 0], num: 0 },
        6: { bodypart: [10, 0, 10, 0, 0, 0, 0, 0], num: 0 },
        7: { bodypart: [20, 0, 20, 0, 0, 0, 0, 0], num: 0 },
        8: { bodypart: [25, 0, 25, 0, 0, 0, 0, 0], num: 0 },
    },
    'rush': {
        6: { bodypart: [17, 1, 9, 0, 0, 0, 0, 0], num: 0 },
        7: { bodypart: [39, 1, 10, 0, 0, 0, 0, 0], num: 0 },
    },
    'truck': {
        1: { bodypart: [0, 1, 1, 0, 0, 0, 0, 0], num: 0 },
        2: { bodypart: [0, 3, 3, 0, 0, 0, 0, 0], num: 0 },
        3: { bodypart: [0, 4, 4, 0, 0, 0, 0, 0], num: 0 },
        4: { bodypart: [0, 8, 8, 0, 0, 0, 0, 0], num: 0 },
        5: { bodypart: [0, 10, 10, 0, 0, 0, 0, 0], num: 0 },
        6: { bodypart: [0, 10, 10, 0, 0, 0, 0, 0], num: 0 },
        7: { bodypart: [0, 20, 20, 0, 0, 0, 0, 0], num: 0 },
        8: { bodypart: [0, 25, 25, 0, 0, 0, 0, 0], num: 0 },
    },
    'Ebuild': {
        1: { bodypart: [1, 1, 2, 0, 0, 0, 0, 0], num: 0 },
        2: { bodypart: [1, 1, 2, 0, 0, 0, 0, 0], num: 0 },
        3: { bodypart: [2, 2, 4, 0, 0, 0, 0, 0], num: 0 },
        4: { bodypart: [2, 2, 4, 0, 0, 0, 0, 0], num: 0 },
        5: { bodypart: [4, 4, 8, 0, 0, 0, 0, 0], num: 0 },
        6: { bodypart: [7, 7, 14, 0, 0, 0, 0, 0], num: 0 },
        7: { bodypart: [10, 10, 20, 0, 0, 0, 0, 0], num: 0 },
        8: { bodypart: [15, 15, 15, 0, 0, 0, 0, 0], num: 0 },
    },
    'Eupgrade': {
        1: { bodypart: [1, 1, 2, 0, 0, 0, 0, 0], num: 0 },
        2: { bodypart: [1, 1, 2, 0, 0, 0, 0, 0], num: 0 },
        3: { bodypart: [2, 2, 4, 0, 0, 0, 0, 0], num: 0 },
        4: { bodypart: [2, 2, 4, 0, 0, 0, 0, 0], num: 0 },
        5: { bodypart: [4, 4, 8, 0, 0, 0, 0, 0], num: 0 },
        6: { bodypart: [7, 7, 14, 0, 0, 0, 0, 0], num: 0 },
        7: { bodypart: [10, 10, 20, 0, 0, 0, 0, 0], num: 0 },
        8: { bodypart: [15, 15, 15, 0, 0, 0, 0, 0], num: 0 },
    },
    "out-harvest": {
        1: { bodypart: [1, 1, 1, 0, 0, 0, 0, 0], num: 0 },
        2: { bodypart: [1, 1, 1, 0, 0, 0, 0, 0], num: 0 },
        3: { bodypart: [1, 1, 1, 0, 0, 0, 0, 0], num: 0 },
        4: { bodypart: [2, 1, 1, 0, 0, 0, 0, 0], num: 0 },
        5: { bodypart: [5, 1, 3, 0, 0, 0, 0, 0], num: 0 },
        6: { bodypart: [6, 2, 3, 0, 0, 0, 0, 0], num: 0 },
        7: { bodypart: [8, 2, 4, 0, 0, 0, 0, 0], num: 0 },
        8: { bodypart: [10, 2, 5, 0, 0, 0, 0, 0], num: 0 },
    },
    "out-car": {
        1: { bodypart: [1, 1, 2, 0, 0, 0, 0, 0], num: 0 },
        2: { bodypart: [1, 2, 2, 0, 0, 0, 0, 0], num: 0 },
        3: { bodypart: [1, 2, 3, 0, 0, 0, 0, 0], num: 0 },
        4: { bodypart: [1, 7, 4, 0, 0, 0, 0, 0], num: 0 },
        5: { bodypart: [1, 21, 11, 0, 0, 0, 0, 0], num: 0 },
        6: { bodypart: [1, 21, 11, 0, 0, 0, 0, 0], num: 0 },
        7: { bodypart: [2, 26, 14, 0, 0, 0, 0, 0], num: 0 },
        8: { bodypart: [2, 30, 16, 0, 0, 0, 0, 0], num: 0 },
    },
    "out-carry": {
        1: { bodypart: [0, 2, 2, 0, 0, 0, 0, 0], num: 0 },
        2: { bodypart: [0, 3, 3, 0, 0, 0, 0, 0], num: 0 },
        3: { bodypart: [0, 4, 4, 0, 0, 0, 0, 0], num: 0 },
        4: { bodypart: [0, 8, 4, 0, 0, 0, 0, 0], num: 0 },
        5: { bodypart: [0, 20, 10, 0, 0, 0, 0, 0], num: 0 },
        6: { bodypart: [0, 20, 10, 0, 0, 0, 0, 0], num: 0 },
        7: { bodypart: [0, 26, 13, 0, 0, 0, 0, 0], num: 0 },
        8: { bodypart: [0, 30, 15, 0, 0, 0, 0, 0], num: 0 },
    },
    "out-defend": {
        1: { bodypart: [0, 0, 1, 0, 0, 1, 0, 0], num: 0 },
        2: { bodypart: [0, 0, 1, 0, 0, 1, 0, 0], num: 0 },
        3: { bodypart: [0, 0, 1, 0, 0, 1, 0, 0], num: 0 },
        4: { bodypart: [0, 0, 3, 0, 2, 2, 0, 0], num: 0 },
        5: { bodypart: [0, 0, 6, 0, 3, 3, 0, 0], num: 0 },
        6: { bodypart: [0, 0, 8, 0, 4, 4, 0, 0], num: 0 },
        7: { bodypart: [0, 0, 16, 0, 8, 8, 0, 0], num: 0 },
        8: { bodypart: [0, 0, 25, 5, 10, 10, 0, 0], num: 0 },
    },
    'r-dismantle': {
        1: { bodypart: [1, 0, 1, 0, 0, 0, 0, 0], num: 0 },
        2: { bodypart: [2, 0, 2, 0, 0, 0, 0, 0], num: 0 },
        3: { bodypart: [3, 0, 3, 0, 0, 0, 0, 0], num: 0 },
        4: { bodypart: [3, 0, 3, 0, 0, 0, 0, 0], num: 0 },
        5: { bodypart: [6, 0, 6, 0, 0, 0, 0, 0], num: 0 },
        6: { bodypart: [10, 0, 10, 0, 0, 0, 0, 0], num: 0 },
        7: { bodypart: [20, 0, 10, 0, 0, 0, 0, 0], num: 0 },
        8: { bodypart: [30, 0, 15, 0, 0, 0, 0, 0], num: 0 },
    },
    'r-carry': {
        1: { bodypart: [0, 1, 1, 0, 0, 0, 0, 0], num: 0 },
        2: { bodypart: [0, 1, 1, 0, 0, 0, 0, 0], num: 0 },
        3: { bodypart: [0, 2, 2, 0, 0, 0, 0, 0], num: 0 },
        4: { bodypart: [0, 5, 5, 0, 0, 0, 0, 0], num: 0 },
        5: { bodypart: [0, 10, 10, 0, 0, 0, 0, 0], num: 0 },
        6: { bodypart: [0, 16, 8, 0, 0, 0, 0, 0], num: 0 },
        7: { bodypart: [0, 30, 15, 0, 0, 0, 0, 0], num: 0 },
        8: { bodypart: [0, 32, 16, 0, 0, 0, 0, 0], num: 0 },
    },
};

/**
 * *************** 此文件代码无需理解,只需会用即可 ***************
 */
/* 房间原型拓展   --内核  --房间孵化 */
class RoomCoreSpawnExtension extends Room {
    /* 孵化总函数 */
    SpawnMain() {
        this.SpawnConfigInit(); /*初始化常驻爬的配置*/
        this.SpawnConfigModify(); /*处理常驻爬的部件信息*/
        if ((Game.time - global.Gtime[this.name]) % 6)
            return;
        this.SpawnManager(); /*检测常驻爬的孵化进程*/
        this.Economy(); /**/
    }
    /* 爬虫孵化配置初始化 */
    SpawnConfigInit() {
        if (!this.memory.SpawnConfig)
            this.memory.SpawnConfig = {};
        /* 初始化 */
        for (let role in RoleData) {
            if (RoleData[role].init && !this.memory.SpawnConfig[role]) {
                this.memory.SpawnConfig[role] = {
                    num: 0,
                    must: RoleData[role].must,
                    adaption: RoleData[role].adaption,
                };
                if (RoleData[role].level) {
                    this.memory.SpawnConfig[role].level = RoleData[role].level;
                }
            }
        }
    }
    /* 爬虫孵化配置二次加工 【随房间控制等级的变化而变化】 */
    SpawnConfigModify() {
        /* 身体部件信息二次加工 */
        for (let role in RoleLevelData) {
            if (RoleLevelData[role][this.controller.level]) {
                global.CreepBodyData[this.name][role] = RoleLevelData[role][this.controller.level].bodypart;
                let up_spawnConfig = this.memory.UpgradespawnConfig[role];
                if (up_spawnConfig) {
                    /*调整体型加工工具*/
                    if (RoleLevelData[role][this.controller.level].upbodypart && up_spawnConfig > 1) {
                        global.CreepBodyData[this.name][role] = RoleLevelData[role][this.controller.level].upbodypart;
                    }
                }
            }
        }
        /* 数量信息二次加工 */
        if (this.controller.level != this.memory.originLevel) {
            for (let role in this.memory.SpawnConfig) {
                var role_ = this.memory.SpawnConfig[role];
                if (!role_.manual && RoleLevelData[role] && RoleLevelData[role][this.controller.level]) {
                    role_.num = RoleLevelData[role][this.controller.level].num;
                }
                /*对于快速起步的操作*/
                if (role_ && !this.memory.switch.speedstate && isInArray(['initial_speed'], role)) {
                    role_.num = 0;
                }
            }
        }
    }
    /* 常驻爬虫孵化管理器-常驻爬的补充模块 (任务爬虫是另外一个孵化函数) */
    SpawnManager() {
        for (let role in this.memory.SpawnConfig) {
            var role_ = this.memory.SpawnConfig[role];
            // 战争状态下爬虫停止生产
            if (this.memory.state == 'war' && this.controller.level >= 6) {
                if (!role_.must)
                    continue;
            }
            /* 固定 补员型 */
            let roleNum = global.CreepNumData[this.name][role];
            if (roleNum === undefined)
                roleNum = 0;
            if (roleNum == 0 && role_.misson) // 任务类型的就删了
             {
                delete this.memory.SpawnConfig[role];
                continue;
            }
            // if (this.memory.SpawnConfig[role]) {
            //     if (this.memory.SpawnConfig[role].num < 1) {
            //         continue;
            //     }
            // }
            if (this.memory.SpawnConfig[role] && (!roleNum || roleNum < this.memory.SpawnConfig[role].num)) {
                /* 计算SpawnList里相关role的个数 */
                let num_ = this.SpawnListRoleNum(role);
                if (num_ + roleNum < this.memory.SpawnConfig[role].num) {
                    /* 开始添加一个孵化任务进孵化队列 */
                    // console.log(this.name, role, roleNum, this.memory.SpawnConfig[role].num)
                    if (global.CreepBodyData[this.name][role])
                        this.AddSpawnList(role, global.CreepBodyData[this.name][role], role_.level ? role_.level : 10, RoleData[role].mem);
                    else
                        this.AddSpawnList(role, RoleData[role].ability, role_.level ? role_.level : 10, RoleData[role].mem);
                }
            }
        }
    }
    /* 孵化函数 */
    SpawnExecution() {
        // 没有孵化任务就return
        if (!this.memory.SpawnList || this.memory.SpawnList.length <= 0)
            return;
        let allEnergy = this.energyAvailable;
        if (allEnergy < 300) {
            return;
        }
        // 如果没有spawn就return
        if (!this.memory.StructureIdData.spawn || this.memory.StructureIdData.spawn.length <= 0)
            return;
        for (let thisSpawn of this.find(FIND_MY_SPAWNS)) {
            // let thisSpawn = Game.getObjectById(sID as Id<StructureSpawn>) as StructureSpawn
            // if (!thisSpawn) {
            //     /* 没有该spawn说明spawn已经被摧毁或者被拆除了，删除structureData里的数据 */
            //     // var spawnMemoryList = this.memory.StructureIdData.spawn as string[]
            //     // var index = spawnMemoryList.indexOf(sID)
            //     // spawnMemoryList.splice(index, 1)
            //     continue
            // }
            // 正在孵化就跳过该spawn
            if (thisSpawn.spawning)
                continue;
            var spawnlist = this.memory.SpawnList;
            /*基于当前能量确定最小孵化值-不低于300以免出现体型过小的单位*/
            let roleName = spawnlist[0].role;
            let mem = spawnlist[0].memory;
            let bd = spawnlist[0].body;
            let body = GenerateAbility(bd[0], bd[1], bd[2], bd[3], bd[4], bd[5], bd[6], bd[7], roleName);
            // 如果global有该爬虫的部件信息，优先用global的数据 global.SpecialBodyData  次优先级
            if (global.SpecialBodyData[this.name][roleName]) {
                body = global.SpecialBodyData[this.name][roleName];
            }
            if (mem && mem.msb && mem.taskRB) // 任务爬虫特殊体型处于最高优先级
             {
                if (global.MSB[mem.taskRB] && global.MSB[mem.taskRB][roleName])
                    body = global.MSB[mem.taskRB][roleName];
            }
            /* 对爬虫数据进行自适应 */
            let allEnergyCapacity = this.energyCapacityAvailable;
            if (allEnergyCapacity < CalculateEnergy(body))
                adaption_body(body, allEnergyCapacity);
            /* 对具备自适应属性的爬虫进行自适应 */
            let adaption = false;
            if (this.memory.SpawnConfig[roleName] && this.memory.SpawnConfig[roleName].adaption && allEnergy < CalculateEnergy(body)) {
                if (!global.CreepNumData[this.name][roleName] || this.controller.level < 8) {
                    adaption_body(body, allEnergy);
                    adaption = true;
                }
            }
            // console.log(this.name, roleName, adaption, body, this.memory.SpawnConfig[roleName].adaption, allEnergy, CalculateEnergy(body))
            // 名称整理
            let mark = RoleData[roleName].mark ? RoleData[roleName].mark : "#";
            let timestr = Game.time.toString().substr(Game.time.toString().length - 4);
            let randomStr = Math.random().toString(36).substr(3);
            // 记忆整理
            let bodyData = {};
            for (var b of body) {
                if (!bodyData[b])
                    bodyData[b] = {};
            }
            var thisMem = {
                role: roleName,
                belong: this.name,
                shard: Game.shard.name,
                boostData: bodyData,
                working: false,
                adaption: false,
                dontPullMe: false,
            };
            if (adaption)
                thisMem.adaption = true; // 代表该爬虫是被自适应过孵化的，如果能量充足应该重新孵化
            // 额外记忆添加
            if (mem) {
                for (var i in mem) {
                    thisMem[i] = mem[i];
                }
            }
            let name = null;
            switch (thisSpawn.owner.username) {
                case "superbitch":
                case "ExtraDim":
                    var int32 = Math.pow(2, 32);
                    var randomId = () => _.padLeft(Math.ceil(Math.random() * int32).toString(16).toLocaleUpperCase(), 8, "0");
                    var processName = function () {
                        return `${mark}x` + randomId();
                    };
                    name = processName();
                    break;
                case "somygame":
                    var int32 = Math.pow(2, 32);
                    var randomId = () => _.padLeft(Math.ceil(Math.random() * int32).toString(16).toLocaleUpperCase(), 8, "0");
                    var processName = function () {
                        return `${thisSpawn.room.name}_${Game.shard.name}_` + randomId();
                    };
                    name = processName();
                    break;
                case "Morningtea":
                    var int32 = Math.pow(2, 32);
                    timestr = (Game.time + body.length * 3 + (body.includes(CLAIM) ? 599 : 1499)).toString().substr(-4);
                    var randomId = () => _.padLeft(Math.ceil(Math.random() * int32).toString(16).toLocaleUpperCase(), 6, "0");
                    var processName = function () {
                        return randomId() + `/` + timestr;
                    };
                    name = processName();
                    break;
                case "CalvinG":
                    var processName = function () {
                        return `${mark}-` + `${thisSpawn.room.name}-` + `${Game.time}`;
                    };
                    name = processName();
                    break;
                case "shenli":
                    name = CreepNameManager.registerName(this);
                    break;
                default:
                    name = `【${mark}】${randomStr}|${timestr}`;
                    break;
            }
            let result = thisSpawn.spawnCreep(body, name, { memory: thisMem });
            if (result == OK) {
                // console.log("即将删除：",spawnlist[0].role,",spawnID:",thisSpawn.id)
                spawnlist.splice(0, 1); // 孵化成功，删除该孵化数据
                if (global.SpecialBodyData[this.name][roleName])
                    delete global.SpecialBodyData[this.name][roleName]; // 删除特殊体型数据
            }
            return;
        }
        /* 说明所有spawn都繁忙或当前能量不适合孵化该creep */
        return;
    }
    /* 【功能函数】添加孵化任务 */
    AddSpawnList(role, body, level, mem) {
        let spawnMisson = { role: role, body: body, level: level };
        if (mem)
            spawnMisson.memory = mem;
        this.memory.SpawnList.push(spawnMisson);
        // 根据优先级排序
        this.memory.SpawnList.sort(compare$1('level'));
    }
    /* 【功能函数】查看孵化队列角色数目 */
    SpawnListRoleNum(role) {
        if (!this.memory.SpawnList)
            return 0;
        let num_ = 0;
        for (var obj of this.memory.SpawnList)
            if (obj.role == role)
                num_ += 1;
        return num_;
    }
    /* 【功能函数】数量孵化 */
    NumSpawn(role, num, level) {
        if (!this.memory.SpawnConfig[role])
            this.memory.SpawnConfig[role] = { num: num, level: level };
        if (this.memory.SpawnConfig[role].misson) {
            console.log("任务角色！不能进行数量孵化！角色为", role);
            return false;
        }
        this.memory.SpawnConfig[role].num = num;
        if (level)
            this.memory.SpawnConfig[role].level = level;
        if (!this.memory.SpawnConfig[role].level) {
            let level_ = RoleData[role].level ? RoleData[role].level : 10;
            this.memory.SpawnConfig[role].level = level_;
        }
        return true;
    }
    /* 【功能函数】单次孵化 */
    SingleSpawn(role, level, mem) {
        let body_ = RoleData[role].ability;
        if (global.CreepBodyData[this.name][role])
            body_ = global.CreepBodyData[this.name][role];
        let level_ = level ? level : 10;
        this.AddSpawnList(role, body_, level_, mem);
        return true;
    }
    /* 经济模式特殊处理 */
    Economy() {
        if (this.controller.level == 8 && (this.memory.economy || Memory.Systemswitch.SystemEconomy || Memory.Systemswitch.SystemUpgrade)) {
            if (this.controller.ticksToDowngrade < 180000 || Memory.Systemswitch.SystemUpgrade)
                this.memory.SpawnConfig['upgrade'].num = 1;
            else
                this.memory.SpawnConfig['upgrade'].num = 0;
        }
        else {
            if (this.controller.level == 8 && this.memory.SpawnConfig['upgrade'].num == 0)
                this.memory.SpawnConfig['upgrade'].num = 1;
        }
    }
}

/* 房间原型拓展   --方法  --寻找 */
class RoomFunctionFindExtension extends Room {
    /* 获取指定structureType的建筑列表 */
    getStructure(sc) {
        // global.getStructure[this.name]
        if (Object.keys(global.getStructure[this.name]).length < 1) {
            let find_list = this.find(FIND_MY_STRUCTURES);
            for (let structure of find_list) {
                // let structure = find_list[i];
                // if (!isInArray([STRUCTURE_RAMPART], structure.structureType)) {
                if (!global.getStructure[this.name][structure.structureType])
                    global.getStructure[this.name][structure.structureType] = [];
                global.getStructure[this.name][structure.structureType].push(structure);
                // }
            }
        }
        return global.getStructure[this.name][sc] ? global.getStructure[this.name][sc] : [];
    }
    getStructureData(sc, key, id) {
        if (!global.getStructureData[this.name][key]) {
            global.getStructureData[this.name][key] = [];
            let _getStructure = this.getStructure(sc);
            for (let Structure of _getStructure) {
                if (isInArray(id, Structure.id)) {
                    global.getStructureData[this.name][key].push(Structure);
                }
            }
        }
        return global.getStructureData[this.name][key] ? global.getStructureData[this.name][key] : [];
    }
    // /* 任务lab绑定数据生成便捷函数 */
    // public Bind_Lab(rTypes: ResourceConstant[]): MissonLabBind | null {
    //     var result: MissonLabBind = {}
    //     var tempList = []
    //     LoopA:
    //     for (var i of rTypes) {
    //         /* 计算是否已经存在相关lab */
    //         for (var occ_lab_id in this.memory.RoomLabBind) {
    //             if (this.memory.RoomLabBind[occ_lab_id].rType == i && !this.memory.RoomLabBind[occ_lab_id].occ) {
    //                 result[occ_lab_id] = i
    //                 continue LoopA
    //             }
    //         }
    //         LoopB:
    //         for (var all_lab_id of this.memory.StructureIdData.labs) {
    //             var occ_lab = Object.keys(this.memory.RoomLabBind)
    //             if (!isInArray(occ_lab, all_lab_id) && !isInArray(tempList, all_lab_id)) {
    //                 var thisLab = Game.getObjectById(all_lab_id) as StructureLab
    //                 if (!thisLab) {
    //                     var index = this.memory.StructureIdData.labs.indexOf(all_lab_id)
    //                     this.memory.StructureIdData.labs.splice(index, 1)
    //                     continue LoopB
    //                 }
    //                 if (thisLab.store) {
    //                     if (Object.keys(thisLab.store).length <= 1) {
    //                         result[all_lab_id] = i
    //                         tempList.push(all_lab_id)
    //                         continue LoopA
    //                     }
    //                     else if (Object.keys(thisLab.store).length == 1) {
    //                         if (thisLab.store['energy'] > 0) {
    //                             result[all_lab_id] = i
    //                             tempList.push(all_lab_id)
    //                             continue LoopA
    //                         }
    //                         continue LoopB
    //                     }
    //                     else if (Object.keys(thisLab.store).length > 1)
    //                         continue LoopB
    //                 }
    //             }
    //         }
    //         return null
    //     }
    //     return result
    // }
    /* -----------------------lab优化区----------------------------(测试中) */
    /* 任务过程中，实时更新占用lab 例如有lab被占用了或者其他情况  */
    Update_Lab() {
        for (let index in this.memory.Misson) {
            LoopB: for (let missObj of this.memory.Misson[index]) {
                if (!missObj.LabMessage)
                    continue LoopB;
                if (!missObj.LabBind)
                    missObj.LabBind = {};
                /*检查任务是否处于挂起状态*/
                if (missObj.Data.hangstate)
                    continue;
                // 检测lab状态
                LoopC: for (let rType in missObj.LabMessage) {
                    let state = this.Check_Occupy(missObj, rType);
                    if (state == 'normal')
                        continue LoopC;
                    else if (state == 'unbind') {
                        let id = this.Allot_Occupy(missObj, rType);
                        if (!id) {
                            // if ((Game.time - global.Gtime[this.name]) % 5 == 0) {
                            //     console.log(`房间${this.name}的lab分配存在问题,找不到合适的lab!材料为:${rType}`);
                            //     return
                            // }
                            return;
                        } // 说明没lab了直接截止整个函数
                        if (_.isArray(id)) {
                            for (var str_ of id) {
                                missObj.LabBind[str_] = rType;
                            }
                            for (let str of id) {
                                if (!this.memory.RoomLabBind[str]) {
                                    this.memory.RoomLabBind[str] = { missonID: [missObj.id], rType: rType, occ: isInArray(['com', 'raw'], missObj.LabMessage[rType]) ? true : false, type: missObj.LabMessage[rType] };
                                }
                                else {
                                    if (this.memory.RoomLabBind[str].rType == rType) {
                                        if (!isInArray(this.memory.RoomLabBind[str].missonID, missObj.id))
                                            this.memory.RoomLabBind[str].missonID.push(missObj.id);
                                        this.memory.RoomLabBind[str].type = missObj.LabMessage[rType];
                                        this.memory.RoomLabBind[str].occ = false;
                                    }
                                    else {
                                        /* 被强制占用的 */
                                        this.memory.RoomLabBind[str] = { missonID: [missObj.id], rType: rType, occ: isInArray(['com', 'raw'], missObj.LabMessage[rType]) ? true : false, type: missObj.LabMessage[rType] };
                                    }
                                }
                            }
                            continue LoopC;
                        }
                        missObj.LabBind[id] = rType;
                        if (!this.memory.RoomLabBind[id]) {
                            this.memory.RoomLabBind[id] = { missonID: [missObj.id], rType: rType, occ: isInArray(['com', 'raw'], missObj.LabMessage[rType]) ? true : false, type: missObj.LabMessage[rType] };
                        }
                        else {
                            if (this.memory.RoomLabBind[id].rType == rType) {
                                if (!isInArray(this.memory.RoomLabBind[id].missonID, missObj.id))
                                    this.memory.RoomLabBind[id].missonID.push(missObj.id);
                                this.memory.RoomLabBind[id].type = missObj.LabMessage[rType];
                                this.memory.RoomLabBind[id].occ = false;
                            }
                            else {
                                /* 被强制占用的 */
                                this.memory.RoomLabBind[id] = { missonID: [missObj.id], rType: rType, occ: isInArray(['com', 'raw'], missObj.LabMessage[rType]) ? true : false, type: missObj.LabMessage[rType] };
                            }
                        }
                    }
                    else
                        continue LoopC;
                }
            }
        }
    }
    /**
     * 判断任务所需的某种资源类型强化的lab占用数据是否正常 只有返回normal才代表正常
     * 简单来说，这个函数可以确定任意任务对象任意资源的lab绑定情况，分别为 正常 | lab遭到破坏 | 无绑定信息 | 被其他高优先级占用 | 需要占用
     * @param miss 任务对象
     * @param rType 资源类型
     * @returns 该类型lab绑定数据
     */
    Check_Occupy(miss, rType) {
        if (!miss.LabBind)
            return 'unbind';
        if (miss.LabMessage && miss.LabMessage[rType] == 'com') {
            // com类型判断有没有空闲的lab 有的话就占用lab
            for (let lab of this.memory.StructureIdData.labs) {
                if (!isInArray(Object.keys(this.memory.RoomLabBind), lab))
                    return 'unbind';
            }
        }
        for (let i in miss.LabBind) {
            if (miss.LabBind[i] == rType) {
                let lab_ = Game.getObjectById(i);
                if (!lab_) {
                    delete this.memory.RoomLabBind[i];
                    // 删除 structureIdData中的无效lab
                    for (let z of this.memory.StructureIdData.labs) {
                        if (z == i) {
                            let index = this.memory.StructureIdData.labs.indexOf(z);
                            this.memory.StructureIdData.labs.splice(index, 1);
                        }
                    }
                    delete miss.LabBind[i];
                    return 'damage'; // 代表绑定的lab损坏
                }
                if (this.memory.RoomLabBind[i] && miss.LabBind[i] == this.memory.RoomLabBind[i].rType) {
                    if (this.memory.RoomLabBind[i].type == miss.LabMessage[rType])
                        return 'normal'; // 正常运转
                    else {
                        if (this.memory.RoomLabBind[i].type == 'boost') {
                            return 'normal'; // 正常运转
                        }
                        console.log(miss.name, i, ` this.memory.RoomLabBind[i].type: ${this.memory.RoomLabBind[i].type} == miss.LabMessage[rType] : ${miss.LabMessage[rType]}`);
                        return 'unbind';
                    }
                }
                else {
                    if (!this.memory.RoomLabBind[i]) {
                        console.log(`error, 不存在this.memory.RoomLabBind[${i}]`);
                        delete miss.LabBind[i];
                        return 'unbind';
                    }
                    if (!miss.LabMessage)
                        return 'lost';
                    let thisType = miss.LabMessage[rType];
                    if (!thisType)
                        return 'lost'; // LabMessage中没这个信息 以被占用处理
                    let levelMap = {
                        'boost': 2,
                        'unboost': 2,
                        'raw': 3,
                        'com': 1
                    };
                    let thisLevel = levelMap[thisType] ? levelMap[thisType] : 0; // 任务对象的占用等级
                    let otherLevel = levelMap[this.memory.RoomLabBind[i].type] ? levelMap[this.memory.RoomLabBind[i].type] : 3;
                    if (thisLevel > otherLevel) {
                        return "occupy"; // 需要占用那个lab
                    }
                    // 自动删除
                    delete miss.LabBind[i];
                    /* 删除任务在RoomLabBind[i].MissionID中的任务id */
                    for (let mID of this.memory.RoomLabBind[i].missonID) {
                        if (mID == miss.id) {
                            let index = this.memory.RoomLabBind[i].missonID.indexOf(mID);
                            this.memory.RoomLabBind[i].missonID.splice(index, 1);
                        }
                    }
                    return 'lost'; // 被其他高优先级绑定占用了，需要重定向
                }
            }
        }
        // console.log(rType)
        return 'unbind'; // 代表未绑定
    }
    /**
     * 分配lab 返回的是分配lab的数据，如果分配成功返回MissonLabBind对象 如果分配失败返回null
     * 简单来说，这是一个按照优先级自动给所需资源分配lab的函数，如果lab不够用，可能会占用，需要额外判断是否被占用了
     * @param miss 任务对象
     * @param rType 资源类型
     * @returns lab绑定信息 | null
     */
    Allot_Occupy(miss, rType) {
        if (!miss.LabMessage)
            return null; // 没有lab信息，分配失败
        if (!miss.LabMessage[rType])
            return null;
        let result = null; // 结果
        let rawLabList = []; // 底物lab列表
        if (this.memory.StructureIdData.labInspect.raw1) // 合成用的底物lab1
         {
            let raw1Lab = Game.getObjectById(this.memory.StructureIdData.labInspect.raw1);
            if (!raw1Lab)
                delete this.memory.StructureIdData.labInspect.raw1;
            else
                rawLabList.push(this.memory.StructureIdData.labInspect.raw1);
        }
        if (this.memory.StructureIdData.labInspect.raw2) // 合成用的底物lab2
         {
            let raw2Lab = Game.getObjectById(this.memory.StructureIdData.labInspect.raw2);
            if (!raw2Lab)
                delete this.memory.StructureIdData.labInspect.raw2;
            else
                rawLabList.push(this.memory.StructureIdData.labInspect.raw2);
        }
        /* 先判断一下是否已经有相关的lab占用了,当然，这只有LabMessage[i]为boost时才可用 */
        if (miss.LabMessage[rType] == 'boost') {
            for (let occ_lab_id in this.memory.RoomLabBind) {
                if (this.memory.RoomLabBind[occ_lab_id].rType == rType && !this.memory.RoomLabBind[occ_lab_id].occ) // !occ代表允许多任务占用该lab
                 {
                    result = occ_lab_id;
                    return result;
                }
            }
        }
        /* boost unboost的lab */
        if (isInArray(['boost', 'unboost'], miss.LabMessage[rType]) && this.memory.StructureIdData.labs) {
            /* 寻找未占用的lab */
            LoopB: for (let lab_id of this.memory.StructureIdData.labs) {
                let bind_labs = Object.keys(this.memory.RoomLabBind);
                if (!isInArray(bind_labs, lab_id) && !isInArray(rawLabList, lab_id)) {
                    let thisLab = Game.getObjectById(lab_id);
                    if (!thisLab) // lab损坏
                     {
                        var index = this.memory.StructureIdData.labs.indexOf(lab_id);
                        this.memory.StructureIdData.labs.splice(index, 1);
                        continue LoopB;
                    }
                    if (thisLab.mineralType) {
                        if (thisLab.mineralType == rType) // 相同资源的未占用lab
                         {
                            result = lab_id;
                            return result;
                        }
                        else
                            continue LoopB;
                    }
                    else // 空lab
                     {
                        result = lab_id;
                        return result;
                    }
                }
            }
        }
        /* 到这一步不是lab被占光了就是合成底物的lab 寻找能占的lab */
        if (miss.LabMessage[rType] == 'raw') {
            LoopRaw: for (let rawID of rawLabList) {
                let thisLab = Game.getObjectById(rawID);
                if (!thisLab)
                    continue LoopRaw;
                // 先检查是否被占用了，如果被占用，就夺回
                if (this.memory.RoomLabBind[rawID] && this.memory.RoomLabBind[rawID].type && this.memory.RoomLabBind[rawID].type != 'raw') {
                    result = rawID;
                    return result;
                }
                if (!this.memory.RoomLabBind[rawID] && (!thisLab.mineralType || thisLab.mineralType == rType)) {
                    return rawID;
                }
            }
        }
        else if (miss.LabMessage[rType] == 'com') {
            let strList = [];
            LoopB: for (let lab_id of this.memory.StructureIdData.labs) {
                // 如果roomLabBind[lab_id].missonID中已经存在该任务, 直接push
                if (this.memory.RoomLabBind[lab_id] && isInArray(this.memory.RoomLabBind[lab_id].missonID, miss.id) && this.memory.RoomLabBind[lab_id].rType == rType) {
                    strList.push(lab_id);
                    continue;
                }
                let bind_labs = Object.keys(this.memory.RoomLabBind);
                if (!isInArray(bind_labs, lab_id) && !isInArray(rawLabList, lab_id)) {
                    let thisLab = Game.getObjectById(lab_id);
                    if (!thisLab) // lab损坏
                     {
                        var index = this.memory.StructureIdData.labs.indexOf(lab_id);
                        this.memory.StructureIdData.labs.splice(index, 1);
                        continue LoopB;
                    }
                    if (thisLab.mineralType) {
                        if (thisLab.mineralType == rType) // 相同资源的未占用lab
                         {
                            strList.push(lab_id);
                        }
                        else
                            continue LoopB;
                    }
                    else // 空lab
                     {
                        strList.push(lab_id);
                    }
                }
            }
            return strList.length > 0 ? strList : null;
        }
        else if (miss.LabMessage[rType] == 'boost') {
            // 寻找性质为com的lab
            for (let occ_lab_id in this.memory.RoomLabBind) {
                // 只要lab存在，且其ID注册为com 就强制占用
                if (this.memory.RoomLabBind[occ_lab_id].type && this.memory.RoomLabBind[occ_lab_id].type == 'com' && Game.getObjectById(occ_lab_id)) {
                    return occ_lab_id;
                }
            }
        }
        return result;
    }
    /* -----------------------lab优化区----------------------------(测试中) */
    /* 获取指定列表中类型的hit最小的建筑 (比值) 返回值： Structure | undefined */
    getListHitsleast(sc, mode, hitsMax) {
        // let s_l = this.find(FIND_STRUCTURES, {
        //     filter: (structure) => {
        //         return filter_structure(structure, sc) && structure.hits < structure.hitsMax
        //     }
        // })
        let s_l = this.find(FIND_STRUCTURES);
        let s_list = [];
        for (let structure of s_l) {
            if (!isInArray(sc, structure.structureType))
                continue;
            if (!structure.hits)
                continue;
            if (structure.hits >= structure.hitsMax)
                continue;
            if (hitsMax && structure.hits > hitsMax) {
                continue;
            }
            if (this.memory.state == 'war') {
                if (!CheckExcludeRampart(this, structure.pos)) {
                    continue;
                }
            }
            s_list.push(structure);
        }
        if (s_list.length > 0) {
            s_list.sort(compare('hits'));
            return s_list[0];
        }
        return null;
        // let least_ = LeastHit(s_l, mode,)
        // return least_
    }
    /* 获取指定类型的建筑 */
    getTypeStructure(sr) {
        var resultstructure = this.find(FIND_STRUCTURES, {
            filter: (structure) => {
                return filter_structure(structure, sr);
            }
        });
        return resultstructure;
    }
    /* 房间建筑执行任务 */
    structureMission(strus) {
        var AllStructures = this.getTypeStructure(strus);
        for (var stru of AllStructures) {
            if (stru.ManageMission)
                stru.ManageMission();
        }
    }
    /**
    * 建筑任务初始化 目前包含terminal factory link
    */
    StructureMission() {
        if (Game.cpu.bucket < 1000 && Memory.StopPixel)
            return;
        let structures = [];
        var IdData = this.memory.StructureIdData;
        /*终端信息*/
        if (Game.cpu.bucket > 1500 || !Memory.StopPixel) {
            let terminal = this.terminal;
            if (terminal) {
                structures.push(terminal);
            }
        }
        /*工厂信息*/
        if (IdData.FactoryId && (Game.cpu.bucket > 2000 || !Memory.StopPixel)) {
            let factory = Game.getObjectById(IdData.FactoryId);
            if (factory) {
                structures.push(factory);
            }
            else
                delete IdData.FactoryId;
        }
        /*Link信息*/
        // for (let _link of this.getStructure(STRUCTURE_LINK) as StructureLink[]) {
        //     structures.push(_link)
        // }
        if (IdData.center_link) {
            let center_link = Game.getObjectById(IdData.center_link);
            if (!center_link) {
                delete IdData.center_link;
            }
            else
                structures.push(center_link);
        }
        if (IdData.source_links && IdData.source_links.length > 0) {
            for (var s of IdData.source_links) {
                let sl = Game.getObjectById(s);
                if (!sl) {
                    var index = IdData.source_links.indexOf(s);
                    IdData.source_links.splice(index, 1);
                }
                else
                    structures.push(sl);
            }
        }
        if (IdData.comsume_link && IdData.comsume_link.length > 0) {
            for (var s of IdData.comsume_link) {
                let sl = Game.getObjectById(s);
                if (!sl) {
                    var index = IdData.comsume_link.indexOf(s);
                    IdData.comsume_link.splice(index, 1);
                }
                else
                    structures.push(sl);
            }
        }
        if (structures.length > 0) {
            for (var obj of structures) {
                if (obj.ManageMission) {
                    obj.ManageMission();
                }
            }
        }
    }
    /* 获取全局建筑对象变量 由于该对象每tick都不一样，所以需要每tick都获取 */
    GlobalStructure() {
        // 目前只支持 storage terminal factory powerspawn 
        if (!global.Stru)
            global.Stru = {};
        if (!global.Stru[this.name])
            global.Stru[this.name] = {};
        // Game.rooms[this.memory.belong].GetStructData('factory')
        // if (this.memory.StructureIdData.NtowerID) {
        //     global.Stru[this.name]['Ntower'] = Game.getObjectById(this.memory.StructureIdData.NtowerID) as StructureTower
        //     if (!global.Stru[this.name]['Ntower']) {
        //         delete this.memory.StructureIdData.NtowerID
        //     }
        // }
        // if (this.memory.StructureIdData.AtowerID && this.memory.StructureIdData.AtowerID.length > 0) {
        //     var otlist = global.Stru[this.name]['Atower'] = [] as StructureTower[]
        //     for (var ti of this.memory.StructureIdData.OtowerID) {
        //         var ot = Game.getObjectById(ti) as StructureTower
        //         if (!ot) {
        //             var index = this.memory.StructureIdData.OtowerID.indexOf(ti)
        //             this.memory.StructureIdData.OtowerID.splice(index, 1)
        //             continue
        //         }
        //         otlist.push(ot)
        //     }
        // }
    }
    /* 等级信息更新 */
    LevelMessageUpdate() {
        if (this.controller.level > this.memory.originLevel)
            this.memory.originLevel = this.controller.level;
    }
}
/* 按照列表中某个属性进行排序 配合sort使用 */
function compare(property) {
    return function (a, b) {
        var value1 = a[property];
        var value2 = b[property];
        return value1 - value2;
    };
}

/* 图标 */
/* dev布局信息 */
const devPlanConstant = [
    /* 2级规划 */
    { x: -1, y: 3, structureType: 'extension', level: 2 },
    { x: -2, y: 3, structureType: 'extension', level: 2 },
    { x: -3, y: 3, structureType: 'extension', level: 2 },
    { x: -2, y: 4, structureType: 'extension', level: 2 },
    { x: -3, y: 4, structureType: 'extension', level: 2 },
    /* 3级规划 */
    { x: -4, y: 3, structureType: 'extension', level: 3 },
    { x: -4, y: 2, structureType: 'extension', level: 3 },
    { x: -3, y: 1, structureType: 'extension', level: 3 },
    { x: -3, y: 2, structureType: 'extension', level: 3 },
    { x: -3, y: -1, structureType: 'extension', level: 3 },
    { x: -2, y: 2, structureType: 'tower', level: 3 },
    { x: 0, y: 3, structureType: 'road', level: 4 },
    { x: 1, y: 1, structureType: 'road', level: 4 },
    { x: -1, y: 4, structureType: 'road', level: 4 },
    { x: -2, y: 5, structureType: 'road', level: 4 },
    { x: -3, y: 5, structureType: 'road', level: 4 },
    { x: -4, y: 4, structureType: 'road', level: 4 },
    { x: -5, y: 3, structureType: 'road', level: 4 },
    { x: -5, y: 2, structureType: 'road', level: 4 },
    { x: -4, y: 1, structureType: 'road', level: 4 },
    { x: -1, y: 2, structureType: 'road', level: 4 },
    { x: 1, y: 2, structureType: 'road', level: 4 },
    { x: -1, y: 1, structureType: 'road', level: 4 },
    { x: -2, y: 1, structureType: 'road', level: 4 },
    { x: -3, y: 0, structureType: 'road', level: 4 },
    { x: -2, y: -1, structureType: 'road', level: 4 },
    { x: -1, y: -2, structureType: 'road', level: 4 },
    { x: -1, y: -1, structureType: 'road', level: 4 },
    { x: 0, y: -3, structureType: 'road', level: 4 },
    { x: 1, y: -2, structureType: 'road', level: 4 },
    { x: 1, y: -1, structureType: 'road', level: 4 },
    { x: 2, y: -1, structureType: 'road', level: 4 },
    { x: 3, y: 0, structureType: 'road', level: 4 },
    { x: 2, y: 1, structureType: 'road', level: 4 },
    /* 4级规划 */
    { x: -2, y: -3, structureType: 'extension', level: 4 },
    { x: -2, y: -4, structureType: 'extension', level: 4 },
    { x: -3, y: -2, structureType: 'extension', level: 4 },
    { x: -3, y: -3, structureType: 'extension', level: 4 },
    { x: -3, y: -4, structureType: 'extension', level: 4 },
    { x: -4, y: 0, structureType: 'extension', level: 4 },
    { x: -4, y: -2, structureType: 'extension', level: 4 },
    { x: -4, y: -3, structureType: 'extension', level: 4 },
    { x: -5, y: 0, structureType: 'extension', level: 4 },
    { x: -5, y: -1, structureType: 'extension', level: 4 },
    { x: 0, y: 0, structureType: 'storage', level: 4 },
    { x: -4, y: -1, structureType: 'road', level: 4 },
    { x: -5, y: -2, structureType: 'road', level: 4 },
    { x: -5, y: -3, structureType: 'road', level: 4 },
    { x: -4, y: -4, structureType: 'road', level: 4 },
    { x: -3, y: -5, structureType: 'road', level: 4 },
    { x: -2, y: -5, structureType: 'road', level: 4 },
    { x: -1, y: -4, structureType: 'road', level: 4 },
    /* 5级规划 */
    { x: -5, y: 1, structureType: 'extension', level: 5 },
    { x: 1, y: -3, structureType: 'extension', level: 5 },
    { x: 2, y: -3, structureType: 'extension', level: 5 },
    { x: 2, y: -4, structureType: 'extension', level: 5 },
    { x: 3, y: -3, structureType: 'extension', level: 5 },
    { x: 3, y: -4, structureType: 'extension', level: 5 },
    { x: 3, y: -2, structureType: 'extension', level: 5 },
    { x: 3, y: -1, structureType: 'extension', level: 5 },
    { x: 4, y: -2, structureType: 'extension', level: 5 },
    { x: 4, y: -3, structureType: 'extension', level: 5 },
    { x: 1, y: 0, structureType: 'link', level: 5 },
    { x: -2, y: -2, structureType: 'tower', level: 5 },
    { x: 1, y: -4, structureType: 'road', level: 5 },
    { x: 2, y: -5, structureType: 'road', level: 5 },
    { x: 3, y: -5, structureType: 'road', level: 5 },
    { x: 4, y: -4, structureType: 'road', level: 5 },
    { x: 5, y: -3, structureType: 'road', level: 5 },
    { x: 5, y: -2, structureType: 'road', level: 5 },
    { x: 4, y: -1, structureType: 'road', level: 5 },
    // 6级规划
    { x: 1, y: 4, structureType: 'road', level: 6 },
    { x: 2, y: 3, structureType: 'road', level: 6 },
    { x: 3, y: 2, structureType: 'road', level: 6 },
    { x: 4, y: 1, structureType: 'road', level: 6 },
    { x: 5, y: 1, structureType: 'road', level: 6 },
    { x: 6, y: 0, structureType: 'road', level: 6 },
    { x: 6, y: -1, structureType: 'road', level: 6 },
    { x: 3, y: 3, structureType: 'road', level: 6 },
    { x: 4, y: 4, structureType: 'road', level: 6 },
    { x: 5, y: 5, structureType: 'road', level: 6 },
    { x: 4, y: 6, structureType: 'road', level: 6 },
    { x: 3, y: 6, structureType: 'road', level: 6 },
    { x: 2, y: 6, structureType: 'road', level: 6 },
    { x: 1, y: 5, structureType: 'road', level: 6 },
    { x: 6, y: 4, structureType: 'road', level: 6 },
    { x: 6, y: 3, structureType: 'road', level: 6 },
    { x: 6, y: 2, structureType: 'road', level: 6 },
    { x: 2, y: 2, structureType: 'terminal', level: 6 },
    { x: -1, y: -3, structureType: 'extension', level: 6 },
    { x: -1, y: -5, structureType: 'extension', level: 6 },
    { x: 1, y: -5, structureType: 'extension', level: 6 },
    { x: 0, y: -4, structureType: 'extension', level: 6 },
    { x: 4, y: 0, structureType: 'extension', level: 6 },
    { x: 5, y: 0, structureType: 'extension', level: 6 },
    { x: 5, y: -1, structureType: 'extension', level: 6 },
    { x: 0, y: -5, structureType: 'extension', level: 6 },
    { x: -5, y: 4, structureType: 'extension', level: 6 },
    { x: -4, y: 5, structureType: 'extension', level: 6 },
    { x: 2, y: 4, structureType: 'lab', level: 6 },
    { x: 3, y: 4, structureType: 'lab', level: 6 },
    { x: 3, y: 5, structureType: 'lab', level: 6 },
    /* 7级规划 */
    { x: 4, y: 2, structureType: 'lab', level: 7 },
    { x: 4, y: 3, structureType: 'lab', level: 7 },
    { x: 5, y: 3, structureType: 'lab', level: 7 },
    { x: 2, y: -2, structureType: 'tower', level: 7 },
    { x: 0, y: -2, structureType: 'spawn', level: 7 },
    { x: -3, y: 6, structureType: 'extension', level: 7 },
    { x: -2, y: 6, structureType: 'extension', level: 7 },
    { x: 0, y: 4, structureType: 'extension', level: 7 },
    { x: -1, y: 5, structureType: 'extension', level: 7 },
    { x: 0, y: 5, structureType: 'extension', level: 7 },
    { x: 1, y: 6, structureType: 'extension', level: 7 },
    { x: -6, y: 2, structureType: 'extension', level: 7 },
    { x: -6, y: 3, structureType: 'extension', level: 7 },
    { x: -4, y: -5, structureType: 'extension', level: 7 },
    { x: -5, y: -4, structureType: 'extension', level: 7 },
    { x: -1, y: 6, structureType: 'road', level: 7 },
    { x: 0, y: 6, structureType: 'road', level: 7 },
    { x: -6, y: 1, structureType: 'road', level: 7 },
    { x: -6, y: 0, structureType: 'road', level: 7 },
    { x: -6, y: -1, structureType: 'road', level: 7 },
    { x: 1, y: 3, structureType: 'factory', level: 7 },
    /* 8级规划 */
    { x: 0, y: -6, structureType: 'road', level: 8 },
    { x: 1, y: -6, structureType: 'road', level: 8 },
    { x: -1, y: -6, structureType: 'road', level: 8 },
    { x: 5, y: -4, structureType: 'extension', level: 8 },
    { x: -3, y: -6, structureType: 'extension', level: 8 },
    { x: 4, y: -5, structureType: 'extension', level: 8 },
    { x: -2, y: -6, structureType: 'extension', level: 8 },
    { x: -6, y: -2, structureType: 'extension', level: 8 },
    { x: -6, y: -3, structureType: 'extension', level: 8 },
    { x: 6, y: -2, structureType: 'extension', level: 8 },
    { x: 6, y: -3, structureType: 'extension', level: 8 },
    { x: 2, y: -6, structureType: 'extension', level: 8 },
    { x: 3, y: -6, structureType: 'extension', level: 8 },
    { x: 3, y: 1, structureType: STRUCTURE_NUKER, level: 8 },
    { x: 6, y: 1, structureType: STRUCTURE_OBSERVER, level: 8 },
    { x: -2, y: 0, structureType: STRUCTURE_SPAWN, level: 8 },
    { x: 2, y: 0, structureType: STRUCTURE_POWER_SPAWN, level: 8 },
    { x: 0, y: 1, structureType: STRUCTURE_TOWER, level: 8 },
    { x: 0, y: -1, structureType: STRUCTURE_TOWER, level: 8 },
    { x: -1, y: 0, structureType: STRUCTURE_TOWER, level: 8 },
    { x: 2, y: 5, structureType: 'lab', level: 8 },
    { x: 4, y: 5, structureType: 'lab', level: 8 },
    { x: 5, y: 2, structureType: 'lab', level: 8 },
    { x: 5, y: 4, structureType: 'lab', level: 8 },
];
/* hoho布局信息 */
const hohoPlanConstant = [
    { x: -4, y: -3, structureType: 'extension', level: 2 },
    { x: -3, y: -4, structureType: 'extension', level: 2 },
    { x: -5, y: -4, structureType: 'extension', level: 2 },
    { x: -5, y: -3, structureType: 'extension', level: 2 },
    { x: -5, y: -2, structureType: 'extension', level: 2 },
    { x: -4, y: -5, structureType: 'extension', level: 3 },
    { x: -3, y: -5, structureType: 'extension', level: 3 },
    { x: -2, y: -5, structureType: 'extension', level: 3 },
    { x: -1, y: -4, structureType: 'extension', level: 3 },
    { x: -1, y: -3, structureType: 'extension', level: 3 },
    { x: -2, y: -1, structureType: 'tower', level: 3 },
    { x: -1, y: -2, structureType: 'road', level: 3 },
    { x: -1, y: -1, structureType: 'road', level: 3 },
    { x: -2, y: -2, structureType: 'road', level: 3 },
    { x: -3, y: -3, structureType: 'road', level: 3 },
    { x: -2, y: -4, structureType: 'road', level: 3 },
    { x: -4, y: -2, structureType: 'road', level: 3 },
    { x: -4, y: -4, structureType: 'road', level: 3 },
    { x: -3, y: -1, structureType: 'extension', level: 4 },
    { x: -4, y: -1, structureType: 'extension', level: 4 },
    { x: 1, y: -4, structureType: 'extension', level: 4 },
    { x: 1, y: -3, structureType: 'extension', level: 4 },
    { x: 3, y: -4, structureType: 'extension', level: 4 },
    { x: 4, y: -3, structureType: 'extension', level: 4 },
    { x: 2, y: -5, structureType: 'extension', level: 4 },
    { x: 3, y: -5, structureType: 'extension', level: 4 },
    { x: 4, y: -5, structureType: 'extension', level: 4 },
    { x: 5, y: -4, structureType: 'extension', level: 4 },
    { x: 0, y: -1, structureType: 'storage', level: 4 },
    { x: 0, y: -3, structureType: 'road', level: 4 },
    { x: 1, y: -2, structureType: 'road', level: 4 },
    { x: 2, y: -2, structureType: 'road', level: 4 },
    { x: 3, y: -3, structureType: 'road', level: 4 },
    { x: 2, y: -4, structureType: 'road', level: 4 },
    { x: 4, y: -4, structureType: 'road', level: 4 },
    { x: 5, y: -3, structureType: 'extension', level: 5 },
    { x: 5, y: -2, structureType: 'extension', level: 5 },
    { x: 4, y: -1, structureType: 'extension', level: 5 },
    { x: 3, y: -1, structureType: 'extension', level: 5 },
    { x: -3, y: 1, structureType: 'extension', level: 5 },
    { x: -4, y: 1, structureType: 'extension', level: 5 },
    { x: -3, y: 2, structureType: 'extension', level: 5 },
    { x: -4, y: 3, structureType: 'extension', level: 5 },
    { x: -3, y: 4, structureType: 'extension', level: 5 },
    { x: -2, y: 3, structureType: 'extension', level: 5 },
    { x: 0, y: -2, structureType: 'tower', level: 5 },
    { x: -1, y: 0, structureType: 'link', level: 5 },
    { x: -2, y: 0, structureType: 'road', level: 5 },
    { x: -1, y: 1, structureType: 'road', level: 5 },
    { x: -1, y: 2, structureType: 'road', level: 5 },
    { x: -2, y: 2, structureType: 'road', level: 5 },
    { x: -3, y: 3, structureType: 'road', level: 5 },
    { x: -4, y: 2, structureType: 'road', level: 5 },
    { x: 0, y: 0, structureType: 'road', level: 5 },
    { x: -5, y: 2, structureType: 'extension', level: 6 },
    { x: -5, y: 3, structureType: 'extension', level: 6 },
    { x: -5, y: 4, structureType: 'extension', level: 6 },
    { x: -4, y: 5, structureType: 'extension', level: 6 },
    { x: -3, y: 5, structureType: 'extension', level: 6 },
    { x: -2, y: 5, structureType: 'extension', level: 6 },
    { x: -1, y: 3, structureType: 'extension', level: 6 },
    { x: -1, y: 4, structureType: 'extension', level: 6 },
    { x: 3, y: 1, structureType: 'extension', level: 6 },
    { x: 4, y: 1, structureType: 'extension', level: 6 },
    { x: 1, y: 0, structureType: 'terminal', level: 6 },
    { x: 4, y: 3, structureType: 'lab', level: 6 },
    { x: 3, y: 4, structureType: 'lab', level: 6 },
    { x: 2, y: 3, structureType: 'lab', level: 6 },
    { x: 1, y: -1, structureType: 'road', level: 6 },
    { x: 2, y: 0, structureType: 'road', level: 6 },
    { x: 1, y: 1, structureType: 'road', level: 6 },
    { x: 1, y: 2, structureType: 'road', level: 6 },
    { x: 0, y: 3, structureType: 'road', level: 6 },
    { x: 3, y: 0, structureType: 'road', level: 6 },
    { x: 2, y: 2, structureType: 'road', level: 6 },
    { x: 3, y: 3, structureType: 'road', level: 6 },
    { x: 5, y: 1, structureType: 'extension', level: 7 },
    { x: 5, y: -1, structureType: 'extension', level: 7 },
    { x: 5, y: -5, structureType: 'extension', level: 7 },
    { x: 1, y: -5, structureType: 'extension', level: 7 },
    { x: -5, y: -5, structureType: 'extension', level: 7 },
    { x: -5, y: -1, structureType: 'extension', level: 7 },
    { x: -5, y: 1, structureType: 'extension', level: 7 },
    { x: -1, y: 5, structureType: 'extension', level: 7 },
    { x: -1, y: -5, structureType: 'extension', level: 7 },
    { x: 1, y: 3, structureType: 'extension', level: 7 },
    { x: -2, y: -3, structureType: 'spawn', level: 7 },
    { x: 0, y: 1, structureType: 'factory', level: 7 },
    { x: 3, y: 2, structureType: 'lab', level: 7 },
    { x: 2, y: 4, structureType: 'lab', level: 7 },
    { x: 3, y: 5, structureType: 'lab', level: 7 },
    { x: 2, y: -1, structureType: 'tower', level: 7 },
    { x: 4, y: 4, structureType: 'road', level: 7 },
    { x: -4, y: 4, structureType: 'road', level: 7 },
    { x: -2, y: 4, structureType: 'road', level: 7 },
    { x: 4, y: 0, structureType: 'road', level: 7 },
    { x: -3, y: 0, structureType: 'road', level: 7 },
    { x: -4, y: 0, structureType: 'road', level: 7 },
    { x: 1, y: 4, structureType: 'extension', level: 8 },
    { x: 1, y: 5, structureType: 'extension', level: 8 },
    { x: 3, y: -2, structureType: 'spawn', level: 8 },
    { x: 2, y: -3, structureType: 'spawn', level: 8 },
    { x: 4, y: 2, structureType: 'road', level: 8 },
    { x: 0, y: 4, structureType: 'road', level: 8 },
    { x: 0, y: -4, structureType: 'road', level: 8 },
    { x: -2, y: 1, structureType: 'tower', level: 8 },
    { x: 0, y: 2, structureType: 'tower', level: 8 },
    { x: 2, y: 1, structureType: 'tower', level: 8 },
    { x: 2, y: 5, structureType: 'observer', level: 8 },
    { x: 3, y: -2, structureType: 'powerSpawn', level: 8 },
    { x: -5, y: 5, structureType: 'nuker', level: 8 },
    { x: 5, y: 2, structureType: 'lab', level: 8 },
    { x: 5, y: 3, structureType: 'lab', level: 8 },
    { x: 5, y: 4, structureType: 'lab', level: 8 },
    { x: 4, y: 5, structureType: 'lab', level: 8 },
];
/* Morningtea布局信息 */
const teaPlanConstant = [
    { x: -2, y: 0, structureType: 'extension', level: 2 },
    { x: -3, y: 1, structureType: 'extension', level: 2 },
    { x: -2, y: 2, structureType: 'extension', level: 2 },
    { x: -4, y: 2, structureType: 'extension', level: 2 },
    { x: -4, y: 3, structureType: 'extension', level: 2 },
    { x: -3, y: 4, structureType: 'extension', level: 3 },
    { x: -2, y: 4, structureType: 'extension', level: 3 },
    { x: -3, y: 3, structureType: 'extension', level: 3 },
    { x: -1, y: 3, structureType: 'extension', level: 3 },
    { x: -4, y: 0, structureType: 'extension', level: 3 },
    { x: -3, y: 2, structureType: 'tower', level: 3 },
    { x: -3, y: 0, structureType: 'road', level: 3 },
    { x: -4, y: 1, structureType: 'road', level: 3 },
    { x: -5, y: 2, structureType: 'road', level: 3 },
    { x: -5, y: 3, structureType: 'road', level: 3 },
    { x: -4, y: 4, structureType: 'road', level: 3 },
    { x: -3, y: 5, structureType: 'road', level: 3 },
    { x: -2, y: 5, structureType: 'road', level: 3 },
    { x: -1, y: 4, structureType: 'road', level: 3 },
    { x: 0, y: 3, structureType: 'road', level: 3 },
    { x: -1, y: 2, structureType: 'road', level: 3 },
    { x: -2, y: 1, structureType: 'road', level: 3 },
    { x: -3, y: -1, structureType: 'extension', level: 4 },
    { x: -4, y: -2, structureType: 'extension', level: 4 },
    { x: -2, y: -2, structureType: 'extension', level: 4 },
    { x: -4, y: -3, structureType: 'extension', level: 4 },
    { x: -3, y: -3, structureType: 'extension', level: 4 },
    { x: -1, y: -3, structureType: 'extension', level: 4 },
    { x: -3, y: -4, structureType: 'extension', level: 4 },
    { x: -2, y: -4, structureType: 'extension', level: 4 },
    { x: -5, y: 1, structureType: 'extension', level: 4 },
    { x: -5, y: -1, structureType: 'extension', level: 4 },
    { x: 1, y: -1, structureType: 'storage', level: 4 },
    { x: -4, y: -1, structureType: 'road', level: 4 },
    { x: -5, y: -2, structureType: 'road', level: 4 },
    { x: -5, y: -3, structureType: 'road', level: 4 },
    { x: -4, y: -4, structureType: 'road', level: 4 },
    { x: -3, y: -5, structureType: 'road', level: 4 },
    { x: -2, y: -5, structureType: 'road', level: 4 },
    { x: -1, y: -4, structureType: 'road', level: 4 },
    { x: 0, y: -3, structureType: 'road', level: 4 },
    { x: -1, y: -2, structureType: 'road', level: 4 },
    { x: -2, y: -1, structureType: 'road', level: 4 },
    { x: 0, y: -1, structureType: 'road', level: 4 },
    { x: 0, y: 1, structureType: 'road', level: 4 },
    { x: -1, y: 0, structureType: 'road', level: 4 },
    { x: 0, y: -4, structureType: 'extension', level: 5 },
    { x: 1, y: -3, structureType: 'extension', level: 5 },
    { x: 2, y: -2, structureType: 'extension', level: 5 },
    { x: 2, y: -4, structureType: 'extension', level: 5 },
    { x: 3, y: -4, structureType: 'extension', level: 5 },
    { x: 4, y: -3, structureType: 'extension', level: 5 },
    { x: 4, y: -2, structureType: 'extension', level: 5 },
    { x: 3, y: -3, structureType: 'extension', level: 5 },
    { x: 3, y: -1, structureType: 'extension', level: 5 },
    { x: 2, y: 0, structureType: 'extension', level: 5 },
    { x: 2, y: -3, structureType: 'tower', level: 5 },
    { x: -1, y: 1, structureType: 'link', level: 5 },
    { x: 1, y: -4, structureType: 'road', level: 5 },
    { x: 2, y: -5, structureType: 'road', level: 5 },
    { x: 3, y: -5, structureType: 'road', level: 5 },
    { x: 4, y: -4, structureType: 'road', level: 5 },
    { x: 5, y: -3, structureType: 'road', level: 5 },
    { x: 5, y: -2, structureType: 'road', level: 5 },
    { x: 4, y: -1, structureType: 'road', level: 5 },
    { x: 3, y: 0, structureType: 'road', level: 5 },
    { x: 2, y: -1, structureType: 'road', level: 5 },
    { x: 1, y: -2, structureType: 'road', level: 5 },
    { x: 1, y: 0, structureType: 'road', level: 5 },
    { x: 2, y: 1, structureType: 'road', level: 5 },
    { x: 1, y: 2, structureType: 'road', level: 5 },
    { x: 3, y: 1, structureType: 'extension', level: 6 },
    { x: 1, y: 3, structureType: 'extension', level: 6 },
    { x: 1, y: -5, structureType: 'extension', level: 6 },
    { x: -1, y: -5, structureType: 'extension', level: 6 },
    { x: -2, y: -6, structureType: 'extension', level: 6 },
    { x: -3, y: -6, structureType: 'extension', level: 6 },
    { x: -4, y: -5, structureType: 'extension', level: 6 },
    { x: -5, y: -4, structureType: 'extension', level: 6 },
    { x: -6, y: -3, structureType: 'extension', level: 6 },
    { x: -6, y: -2, structureType: 'extension', level: 6 },
    { x: 1, y: 1, structureType: 'terminal', level: 6 },
    { x: 2, y: 3, structureType: 'lab', level: 6 },
    { x: 2, y: 4, structureType: 'lab', level: 6 },
    { x: 3, y: 4, structureType: 'lab', level: 6 },
    { x: 4, y: 1, structureType: 'road', level: 6 },
    { x: 5, y: 2, structureType: 'road', level: 6 },
    { x: 6, y: 3, structureType: 'road', level: 6 },
    { x: 6, y: 4, structureType: 'road', level: 6 },
    { x: 2, y: 2, structureType: 'road', level: 6 },
    { x: 3, y: 3, structureType: 'road', level: 6 },
    { x: 4, y: 4, structureType: 'road', level: 6 },
    { x: 5, y: 5, structureType: 'road', level: 6 },
    { x: 1, y: 4, structureType: 'road', level: 6 },
    { x: 2, y: 5, structureType: 'road', level: 6 },
    { x: 3, y: 6, structureType: 'road', level: 6 },
    { x: 4, y: 6, structureType: 'road', level: 6 },
    { x: 2, y: -6, structureType: 'extension', level: 7 },
    { x: 3, y: -6, structureType: 'extension', level: 7 },
    { x: 4, y: -5, structureType: 'extension', level: 7 },
    { x: 5, y: -4, structureType: 'extension', level: 7 },
    { x: 6, y: -3, structureType: 'extension', level: 7 },
    { x: -6, y: 2, structureType: 'extension', level: 7 },
    { x: -6, y: 3, structureType: 'extension', level: 7 },
    { x: -5, y: 4, structureType: 'extension', level: 7 },
    { x: -4, y: 5, structureType: 'extension', level: 7 },
    { x: -3, y: 6, structureType: 'extension', level: 7 },
    { x: 5, y: 0, structureType: 'spawn', level: 7 },
    { x: -5, y: 0, structureType: 'spawn', level: 7 },
    { x: -1, y: -1, structureType: 'factory', level: 7 },
    { x: 3, y: 2, structureType: 'lab', level: 7 },
    { x: 4, y: 2, structureType: 'lab', level: 7 },
    { x: 4, y: 3, structureType: 'lab', level: 7 },
    { x: -2, y: 3, structureType: 'tower', level: 7 },
    { x: -2, y: 6, structureType: 'extension', level: 8 },
    { x: -1, y: 5, structureType: 'extension', level: 8 },
    { x: 0, y: 4, structureType: 'extension', level: 8 },
    { x: 1, y: 5, structureType: 'extension', level: 8 },
    { x: 2, y: 6, structureType: 'extension', level: 8 },
    { x: 6, y: -2, structureType: 'extension', level: 8 },
    { x: 5, y: -1, structureType: 'extension', level: 8 },
    { x: 4, y: 0, structureType: 'extension', level: 8 },
    { x: 5, y: 1, structureType: 'extension', level: 8 },
    { x: 6, y: 2, structureType: 'extension', level: 8 },
    { x: 0, y: 5, structureType: 'spawn', level: 8 },
    { x: 5, y: 0, structureType: 'spawn', level: 8 },
    { x: -5, y: 0, structureType: 'spawn', level: 8 },
    { x: 3, y: -2, structureType: 'tower', level: 8 },
    { x: -3, y: -2, structureType: 'tower', level: 8 },
    { x: -2, y: -3, structureType: 'tower', level: 8 },
    { x: 0, y: 2, structureType: 'observer', level: 8 },
    { x: 0, y: -2, structureType: 'powerSpawn', level: 8 },
    { x: 0, y: -5, structureType: 'nuker', level: 8 },
    { x: 3, y: 5, structureType: 'lab', level: 8 },
    { x: 4, y: 5, structureType: 'lab', level: 8 },
    { x: 5, y: 4, structureType: 'lab', level: 8 },
    { x: 5, y: 3, structureType: 'lab', level: 8 },
];

/* 房间原型拓展   --内核  --房间生态 */
class RoomCoreEcosphereExtension extends Room {
    /* 房间生态主函数 */
    RoomEcosphere() {
        this.RoomState(); // 房间状态监测
        this.RoomPlan(); // 房间布局及自动修复
    }
    /* 自动布局 */
    RoomPlan() {
        // 没有中心点不进行自动布局
        let centerList = Memory.RoomControlData[this.name].center;
        if (!centerList || centerList.length < 2)
            return;
        let level = this.controller.level;
        if (level > this.memory.originLevel) {
            let LayOutPlan = Memory.RoomControlData[this.name].arrange;
            switch (LayOutPlan) {
                case 'man': {
                    break;
                }
                case 'hoho': {
                    this.RoomRuleLayout(level, hohoPlanConstant);
                    break;
                }
                case 'tea': {
                    this.RoomRuleLayout(level, teaPlanConstant);
                    break;
                }
                case 'dev': {
                    this.RoomRuleLayout(level, devPlanConstant);
                    break;
                }
                case 'auto63': {
                    /*检查是否有已经保存的布局信息*/
                    if (!Memory.RoomControlData[this.name].structMap) {
                        console.log(`[LayoutVisual63] 房间${this.name}63布局尚未录入`);
                    }
                    else {
                        let _Constant = [];
                        let structMap_length = Memory.RoomControlData[this.name].structMap.length;
                        for (let i = 0; i < structMap_length; i++) {
                            _Constant.push(unzipLayout(Memory.RoomControlData[this.name].structMap[i]));
                        }
                        console.log('63布局详情');
                        console.log(JSON.stringify(_Constant));
                        this.RoomRuleautoLayout(level, _Constant);
                        break;
                    }
                }
            }
            if (level == 6) // 6级1个source的Link
             {
                let sourceIDs = this.memory.StructureIdData.source;
                if (sourceIDs.length <= 0)
                    return;
                let sourceID = sourceIDs[0];
                let source = Game.getObjectById(sourceID);
                let harvestcontainerID = this.memory.harvestData[sourceID].containerID;
                if (!harvestcontainerID)
                    return;
                let container = Game.getObjectById(harvestcontainerID);
                if (!container)
                    return;
                let points = source.pos.getSourceLinkVoid();
                if (points.length <= 0)
                    return;
                LoopA: for (var i of points) {
                    if (i.lookFor(LOOK_CONSTRUCTION_SITES).length <= 0 && i.lookFor(LOOK_STRUCTURES).length <= 0) {
                        if (i.isNearTo(container)) {
                            i.createConstructionSite(STRUCTURE_LINK);
                            break LoopA;
                        }
                    }
                }
            }
            else if (level == 7) // 7级出source的Link
             {
                let sourceIDs = this.memory.StructureIdData.source;
                if (sourceIDs.length <= 1)
                    return;
                let sourceID = sourceIDs[1];
                let source = Game.getObjectById(sourceID);
                let harvestcontainerID = this.memory.harvestData[sourceID].containerID;
                if (!harvestcontainerID)
                    return;
                let container = Game.getObjectById(harvestcontainerID);
                if (!container)
                    return;
                let points = source.pos.getSourceLinkVoid();
                if (points.length <= 0)
                    return;
                LoopA: for (var i of points) {
                    if (i.lookFor(LOOK_CONSTRUCTION_SITES).length <= 0 && i.lookFor(LOOK_STRUCTURES).length <= 0) {
                        if (i.isNearTo(container)) {
                            i.createConstructionSite(STRUCTURE_LINK);
                            break LoopA;
                        }
                    }
                }
            }
            else if (level == 5) // 5级出控制器Link
             {
                let controller = this.controller;
                let points = controller.pos.getSourceLinkVoid();
                if (points.length <= 0)
                    return;
                LoopA: for (let i of points) {
                    if (i.lookFor(LOOK_CONSTRUCTION_SITES).length <= 0 && i.lookFor(LOOK_STRUCTURES).length <= 0) {
                        i.createConstructionSite(STRUCTURE_LINK);
                        break LoopA;
                    }
                }
            }
            // if (level == 5) {// 控制器修路
            //     /*绘制到控制器的路径*/
            //     let storageID = this.memory.StructureIdData.storageID
            //     let storageData = Game.getObjectById(storageID) as Storage
            //     let _path: any = this.findPath(storageData.pos, this.controller.pos, { maxOps: 500, ignoreCreeps: true, plainCost: 1, swampCost: 1, maxRooms: 1 });
            //     for (let _id_path in _path) {
            //         let _data = _path[_id_path]
            //         if (_path.length - 1 > Number(_id_path)) {
            //             this.createConstructionSite(_data.x, _data.y, STRUCTURE_ROAD);
            //         }
            //     }
            // }
            // /* link */
            // if (level == 3) {
            //     /*绘制到矿点的路径*/
            //     let sourceIDs = this.memory.StructureIdData.source
            //     if (sourceIDs.length <= 0) return
            //     let spawn: any = this.memory.StructureIdData.spawn
            //     let spawn_d = Game.getObjectById(spawn[0]) as StructureSpawn;
            //     for (var sourcei of sourceIDs) {
            //         let source = Game.getObjectById(sourcei) as Source
            //         // console.log(JSON.stringify(spawn_d.pos), JSON.stringify(source.pos), sourcei)
            //         let _path: any = this.findPath(spawn_d.pos, source.pos, { maxOps: 500, ignoreCreeps: true, plainCost: 1, swampCost: 1, maxRooms: 1 });
            //         for (let _id_path in _path) {
            //             let _data = _path[_id_path]
            //             if (_path.length - 1 > Number(_id_path)) {
            //                 this.createConstructionSite(_data.x, _data.y, STRUCTURE_ROAD);
            //             }
            //         }
            //     }
            // }
        }
        /* 自动重建 */
        if (Game.shard.name == 'shard3') {
            if ((Game.time - global.Gtime[this.name]) % 47)
                return;
        }
        else {
            if ((Game.time - global.Gtime[this.name]) % 11)
                return;
        }
        if (this.memory.state == 'peace') {
            /* cpu过少就不进行自动重建 */
            if (Game.cpu.bucket < 4000 && Memory.StopPixel)
                return;
            /* 仅仅在和平情况下才会打开自动重建 */
            // 寻找所有属于我的建筑的数量 -1是去除controller 包含所有非控制器的我方建筑、我方建筑工地、该房间内的道路，container
            let currentNum = this.find(FIND_MY_STRUCTURES).length + this.find(FIND_MY_CONSTRUCTION_SITES).length + this.find(FIND_STRUCTURES, { filter: (structure) => { return structure.structureType == STRUCTURE_CONTAINER || structure.structureType == STRUCTURE_ROAD; } }).length - 1;
            if (!this.memory.structureNum)
                this.memory.structureNum = 0;
            this.memory.structureNum = this.getDistributionNum();
            if (currentNum > this.memory.structureNum) {
                this.addStructureMemory();
                console.log(`房间${this.name} 更新distribution记忆! 检测到建筑:${currentNum}, memory中建筑数量:${this.memory.structureNum}`);
            }
            else if (currentNum === this.memory.structureNum) {
                return;
            }
            else {
                console.log(this.name, `房间${this.name} 检测出缺损  检测到建筑:${currentNum}, memory中建筑数量:${this.memory.structureNum}`);
                /* 运行修补函数 */
                this.repatchDistribution();
            }
        }
        else if (this.memory.state == 'war' || (Game.time - global.Gtime[this.name]) % 199 == 0) {
            /* 战争状态 */
            /* cpu过少就不进行自动重建 */
            if (Game.cpu.bucket < 4000 && Memory.StopPixel)
                return;
            // 仅检测城墙、spawn、仓库、终端、实验室的数量，检测到缺损就自动开启安全模式
            let currentNum = this.find(FIND_MY_STRUCTURES, {
                filter: (structure) => {
                    return isInArray(['rampart', 'spawn', 'storage', 'terminal', 'lab', 'extension'], structure.structureType);
                }
            }).length;
            currentNum += this.find(FIND_MY_CONSTRUCTION_SITES, {
                filter: (cons) => {
                    return isInArray(['rampart', 'spawn', 'storage', 'terminal', 'lab', 'extension'], cons.structureType);
                }
            }).length;
            let memoryNum = 0;
            // console.log('currentNum:', currentNum)
            for (var index in this.memory.distribution) {
                if (isInArray(['rampart', 'spawn', 'storage', 'terminal', 'lab', 'extension'], index)) {
                    memoryNum += this.memory.distribution[index].length;
                }
            }
            // console.log("memoryNum:", memoryNum)
            if (currentNum < memoryNum && this.memory.state == 'war') {
                /* 说明出问题了 */
                if (Game.cpu.generatePixel) {
                    this.controller.activateSafeMode();
                }
            }
        }
    }
    /* 房间状态 */
    RoomState() {
        // 每10tick观察一次房间状态，如果发现敌人，房间状态变为war，否则为peace
        if ((Game.time - global.Gtime[this.name]) % 10)
            return;
        // 安全模式下和平模式
        if (this.controller.safeMode && this.controller.level >= 8) {
            this.memory.state = 'peace';
            return;
        }
        var enemy = this.find(FIND_HOSTILE_CREEPS, {
            filter: (creep) => {
                return !isInArray(Memory.whitesheet, creep.owner.username);
            }
        });
        var enemyPowerCreep = this.find(FIND_HOSTILE_POWER_CREEPS, {
            filter: (creep) => {
                return !isInArray(Memory.whitesheet, creep.owner.username);
            }
        });
        if (enemy.length > 0 || enemyPowerCreep.length > 0) {
            this.memory.state = 'war';
        }
        else {
            this.memory.state = 'peace';
        }
    }
    /* 房间自动布局 */
    RoomRuleLayout(level, map) {
        let center_point = null;
        let centerList = Memory.RoomControlData[this.name].center;
        center_point = new RoomPosition(centerList[0], centerList[1], this.name);
        for (let obj of map) {
            if (level >= obj.level) {
                let new_point = new RoomPosition(center_point.x + obj.x, center_point.y + obj.y, this.name);
                // 忽略越界位置
                if (new_point.x >= 49 || new_point.x <= 0 || new_point.y >= 49 || new_point.y <= 0)
                    continue;
                // 墙壁不建造东西
                if (new_point.lookFor(LOOK_TERRAIN)[0] == 'wall')
                    continue;
                let posOcp = false;
                let new_point_structures = new_point.lookFor(LOOK_STRUCTURES);
                if (new_point_structures.length > 0)
                    for (let j of new_point_structures) {
                        if (j.structureType == obj.structureType)
                            posOcp = true;
                    }
                if (new_point && new_point.lookFor(LOOK_CONSTRUCTION_SITES).length <= 0 && !posOcp) {
                    let result = new_point.createConstructionSite(obj.structureType);
                    if (result != 0) {
                        let str = Colorful$1(`房间${this.name}创建工地${obj.structureType}失败! 位置: x=${obj.x}|y=${obj.y}`, 'orange', false);
                        console.log(str);
                    }
                    else {
                        let str = Colorful$1(`房间${this.name}创建工地${obj.structureType}成功! 位置: x=${obj.x}|y=${obj.y}`, 'green', false);
                        console.log(str);
                    }
                }
            }
            else
                return; // 不遍历无关建筑
        }
    }
    RoomRuleautoLayout(level, map) {
        // let center_point: RoomPosition = null
        // let centerList = Memory.RoomControlData[this.name].center
        // center_point = new RoomPosition(centerList[0], centerList[1], this.name)
        for (let obj of map) {
            if (level >= obj.level) {
                let new_point = new RoomPosition(obj.x, obj.y, this.name);
                // 忽略越界位置
                if (new_point.x >= 49 || new_point.x <= 0 || new_point.y >= 49 || new_point.y <= 0)
                    continue;
                // 墙壁不建造东西
                if (new_point.lookFor(LOOK_TERRAIN)[0] == 'wall')
                    continue;
                let posOcp = false;
                let new_point_structures = new_point.lookFor(LOOK_STRUCTURES);
                if (new_point_structures.length > 0)
                    for (let j of new_point_structures) {
                        if (j.structureType == obj.structureType)
                            posOcp = true;
                    }
                if (new_point && new_point.lookFor(LOOK_CONSTRUCTION_SITES).length <= 0 && !posOcp) {
                    let result = new_point.createConstructionSite(obj.structureType);
                    if (result != 0) {
                        let str = Colorful$1(`房间${this.name}创建工地${obj.structureType}失败! 位置: x=${obj.x}|y=${obj.y}`, 'orange', false);
                        console.log(str);
                    }
                    else {
                        let str = Colorful$1(`房间${this.name}创建工地${obj.structureType}成功! 位置: x=${obj.x}|y=${obj.y}`, 'green', false);
                        console.log(str);
                    }
                }
            }
            else
                return; // 不遍历无关建筑
        }
    }
    /* 获取房间memory中distribution总数量 */
    getDistributionNum() {
        if (!this.memory.distribution)
            return 0;
        let result = 0;
        for (var i of Object.keys(this.memory.distribution)) {
            result += this.memory.distribution[i].length;
        }
        return result;
    }
    /* 遍历该房间内所有的可以建造、维修的construction site 或者 structure，将其添加进该房间的memory中 */
    addStructureMemory() {
        if (!this.memory.distribution)
            this.memory.distribution = {};
        // 获取所有的结构和工地
        var construction = [];
        var all_my_structure = this.find(FIND_MY_STRUCTURES, {
            filter: (structure) => {
                return structure.structureType != STRUCTURE_CONTROLLER;
            }
        });
        var all_spawn = this.find(FIND_MY_SPAWNS);
        for (var i of all_my_structure)
            construction.push(i);
        for (var n of all_spawn)
            construction.push(n);
        var all_road = this.find(FIND_STRUCTURES, {
            filter: (structure) => {
                return structure.structureType == STRUCTURE_ROAD || structure.structureType == STRUCTURE_CONTAINER;
            }
        });
        for (var j of all_road)
            construction.push(j);
        var all_construct = this.find(FIND_CONSTRUCTION_SITES, {
            filter: (structure) => {
                return structure.structureType != STRUCTURE_WALL;
            }
        });
        for (var m of all_construct)
            construction.push(m);
        for (var index of construction) {
            if (!this.memory.distribution[index.structureType])
                this.memory.distribution[index.structureType] = [];
            if (!isInArray(this.memory.distribution[index.structureType], `${index.pos.x}/${index.pos.y}`))
                this.memory.distribution[index.structureType].push(`${index.pos.x}/${index.pos.y}`);
        }
    }
    /* 修补函数，根据记忆将缺损的建筑进行自动工地规划 */
    repatchDistribution() {
        if (!this.memory.distribution)
            return;
        for (var key_ of Object.keys(this.memory.distribution)) {
            // key_ : road/spawn/storage....
            for (var po of this.memory.distribution[key_]) {
                var thisPos = this.unzip(po);
                if (thisPos) {
                    if (key_ != 'spawn') {
                        if (thisPos.createConstructionSite(key_) == 0) {
                            console.log(`自动修复成功，其建筑为${key_}，位置为${thisPos.x},${thisPos.y}`);
                        }
                    }
                    else {
                        thisPos.createConstructionSite(STRUCTURE_SPAWN);
                    }
                }
            }
        }
    }
    // 解压房间内字符串获取pos对象
    unzip(str) {
        var info = str.split('/');
        return info.length == 2 ? new RoomPosition(Number(info[0]), Number(info[1]), this.name) : undefined;
    }
    /* 解绑函数，删除memory中指定的数据 */
    unbindMemory(mold, x, y) {
        var thisPosition = new RoomPosition(x, y, this.name);
        if (thisPosition.lookFor(LOOK_STRUCTURES).length == 0 && thisPosition.lookFor(LOOK_CONSTRUCTION_SITES).length == 0) {
            console.log(`房间${this.name}的位置x:${thisPosition.x},y:${thisPosition.y}无任何建筑或工地！`);
            return;
        }
        var result = [];
        for (var i of thisPosition.lookFor(LOOK_STRUCTURES))
            result.push(i);
        for (var j of thisPosition.lookFor(LOOK_CONSTRUCTION_SITES))
            result.push(j);
        for (var sample of result) {
            if (sample.structureType === mold) {
                // 在记忆列表中删除指定的数据，并删除该位置的建筑或工地
                if (!this.memory.distribution[mold])
                    return;
                if (this.memory.distribution[mold].length <= 0)
                    return;
                for (var poStr of this.memory.distribution[mold]) {
                    if (poStr == `${x}/${y}`) {
                        var index = this.memory.distribution[mold].indexOf(poStr);
                        if (index > -1) {
                            this.memory.distribution[mold].splice(index, 1);
                        }
                    }
                }
                if (sample.destroy)
                    sample.destroy();
                else if (sample.remove)
                    sample.remove();
                return;
            }
        }
        console.log(`房间${this.name}的位置x:${thisPosition.x},y:${thisPosition.y}不存在${mold}类型建筑或结构！`);
    }
}

/* 房间原型拓展   --任务  --任务框架 */
class RoomMissonFrameExtension extends Room {
    /* 任务管理器 */
    MissionManager() {
        var cpu_test = false;
        if (Memory.Systemswitch.ShowtestroomMisson) {
            cpu_test = true;
        }
        let cpu_list = [];
        if (cpu_test) {
            cpu_list.push(Game.cpu.getUsed());
        }
        this.SpeedUpcontroller();
        // 冷却监测
        this.CoolDownCaculator();
        // 超时监测
        this.DelayCaculator();
        // 任务-爬虫 绑定信息更新
        this.UnbindMonitor();
        // 任务-爬虫 孵化
        this.MissonRoleSpawn();
        // 任务相关lab绑定信息更新
        this.Update_Lab();
        /* PC任务管理器 */
        this.PowerCreep_TaskManager();
        if (cpu_test) {
            cpu_list.push(Game.cpu.getUsed());
        }
        /* [全自动] 任务挂载区域 需要按照任务重要程度进行排序 */
        this.Spawn_Feed(); // 虫卵填充任务 
        this.Task_CenterLink(); // 能量采集  
        this.Task_ComsumeLink(); // 消费、冲级link
        this.Constru_Build(); // 建筑任务
        this.Task_Clink(); // 链接送仓任务
        this.Tower_Feed(); // 防御塔填充任务
        this.Lab_Feed(); // 实验室填充\回收任务  
        this.Nuker_Feed(); // 核弹填充任务      
        this.Nuke_Defend(); // 核弹防御
        this.Task_CompoundDispatch(); // 合成规划 （中级）
        this.Task_LabAutomatic(); // Lab 自动合成规划
        this.Task_FactoryAutomatic(); // Factory 自动/压缩解压规划
        this.Task_monitorMineral(); // 挖矿
        this.Task_montitorPower(); // 烧power任务监控
        this.Task_Auto_Defend(); // 主动防御任务发布
        this.Auto_Basicmarket(); //自动化基础资源保持功能
        this.Resource_Recycle(); //资源回收
        if (cpu_test) {
            cpu_list.push(Game.cpu.getUsed());
        }
        /* 基本任务监控区域 */
        for (var index in this.memory.Misson) {
            for (var misson of this.memory.Misson[index]) {
                var a = Game.cpu.getUsed();
                switch (misson.name) {
                    case "物流运输":
                        this.Task_Carry(misson);
                        break;
                    case "位面运输":
                        this.Task_Carryshard(misson);
                        break;
                    case "拾荒者":
                        this.Task_Carrygleaner(misson);
                        break;
                    case "外矿偷取":
                        this.Task_Carrymine(misson);
                        break;
                    case "墙体维护":
                        this.Task_Repair(misson);
                        break;
                    case '黄球拆迁':
                        this.Task_dismantle(misson);
                        break;
                    case '急速冲级':
                        this.Task_Quick_upgrade(misson);
                        break;
                    case '紧急援建':
                        this.Task_HelpBuild(misson);
                        break;
                    case '紧急升级':
                        this.Task_HelpUpgrade(misson);
                        break;
                    case '紧急支援':
                        this.Task_HelpDefend(misson);
                        break;
                    case "紧急墙体":
                        this.Task_HelpRepair(misson);
                        break;
                    case '资源合成':
                        this.Task_Compound(misson);
                        break;
                    case '攻防一体':
                        this.Task_aio(misson);
                        break;
                    case '外矿开采':
                        this.Task_OutMine(misson);
                        break;
                    case "power升级":
                        this.Task_ProcessPower(misson);
                        break;
                    case '过道采集':
                        this.Task_Cross(misson);
                        break;
                    case '资源转移':
                        this.Task_Resource_transfer(misson);
                        break;
                    case 'power采集':
                        this.Task_PowerHarvest(misson);
                        break;
                    case '红球防御':
                        this.Task_Red_Defend(misson);
                        break;
                    case '蓝球防御':
                        this.Task_Blue_Defend(misson);
                        break;
                    case '双人防御':
                        this.Task_Double_Defend(misson);
                        break;
                    case '四人小队':
                        this.Task_squad(misson);
                        break;
                    case '双人小队':
                        this.Task_double(misson);
                        break;
                    case '普通冲级':
                        this.Task_Normal_upgrade(misson);
                        break;
                    case '扩张援建':
                        this.Task_Expand(misson);
                        break;
                    case '智能战争':
                        this.Task_Aiwar(misson);
                        break;
                    case '智能哨兵':
                        this.Task_Aisentry(misson);
                        break;
                    case '踩工地':
                        this.Task_CConstruction(misson);
                        break;
                }
                // return
                if (cpu_test) {
                    var b = Game.cpu.getUsed();
                    if (b - a > 0.005) {
                        console.log(misson.name, b - a, this.name);
                    }
                }
            }
        }
        if (cpu_test) {
            cpu_list.push(Game.cpu.getUsed());
            console.log(this.name, '基础任务' + (cpu_list[1] - cpu_list[0]).toFixed(3), '全自动' + (cpu_list[2] - cpu_list[1]).toFixed(3), '任务管理' + (cpu_list[3] - cpu_list[2]).toFixed(3), '总计' + (cpu_list[3] - cpu_list[0]).toFixed(3));
        }
    }
    /* 添加任务 */
    AddMission(mis) {
        if (!mis)
            return false;
        var Index;
        if (mis.range == 'Creep')
            Index = 'C-';
        else if (mis.range == 'Room')
            Index = 'R-';
        else if (mis.range == 'Structure')
            Index = 'S-';
        else if (mis.range == 'PowerCreep')
            Index = 'P-';
        else
            return;
        var tempID = Index + generateID();
        /* 最多允许同时有30个任务，超过则不能再挂载 */
        if (this.memory.Misson[mis.range] && this.memory.Misson[mis.range].length >= 30) {
            return false;
        }
        /* 超过了任务的最大重复数，也不允许挂载 默认是1*/
        var maxtime = mis.maxTime ? mis.maxTime : 1;
        if (mis.CreepBind) {
            /* 爬虫任务 */
            for (var c of Object.keys(mis.CreepBind)) {
                if (this.RoleMissionNum(c, mis.name) >= maxtime)
                    return false;
            }
        }
        else {
            /* 房间、建筑类型的任务 */
            let NowNum = this.MissionNum(mis.range, mis.name);
            if (NowNum >= maxtime) {
                return false;
            }
        }
        /* 如果该任务冷却时间不为0则不允许挂载 */
        if (this.memory.CoolDownDic[mis.name]) {
            return false;
        }
        mis.id = tempID;
        /* lab绑定相关，涉及lab的绑定和解绑 */
        // if (mis.LabBind && Object.keys(mis.LabBind).length > 0)
        // {
        //     for (var l in mis.LabBind)
        //     {
        //         if (!this.CheckLabType(l,mis.LabBind[l] as ResourceConstant) || !this.CheckLabOcc(l))
        //         {
        //             console.log(Colorful(`LabID:${l}绑定失败，请检查!`,'red',true))
        //             return false
        //         }
        //     }
        // }
        // if (mis.LabBind === null) return false
        /* 每种相同任务成功挂载一次，将有冷却时间 默认为10 */
        var coolTick = mis.cooldownTick ? mis.cooldownTick : 10;
        if (!this.memory.CoolDownDic[mis.name])
            this.memory.CoolDownDic[mis.name] = coolTick;
        mis.level = mis.level ? mis.level : 10; // 任务等级默认为10
        // 挂载任务
        this.memory.Misson[mis.range].push(mis);
        this.memory.Misson[mis.range].sort(compare$1('level')); // 每次提交任务都根据优先级排列一下
        if (!isInArray(Memory.ignoreMissonName, mis.name))
            console.log(Colorful$1(`${mis.name} 任务挂载 √√√ ID:${mis.id} Room:${this.name}`, 'green'));
        /* 任务挂载成功才绑定实验室 */
        // if (mis.LabBind && Object.keys(mis.LabBind).length > 0)
        // {
        //     for (var ll in mis.LabBind)
        //     {
        //         this.BindLabData(ll,mis.LabBind[ll] as ResourceConstant,mis.id)
        //     }
        // }
        return true;
    }
    /* 删除任务 */
    DeleteMission(id) {
        var range;
        if (!id) {
            console.log("存在id异常! 发生在房间", this.name);
            return false;
        }
        if (id[0] == 'C')
            range = 'Creep';
        else if (id[0] == 'S')
            range = 'Structure';
        else if (id[0] == 'R')
            range = 'Room';
        else if (id[0] == 'P')
            range = 'PowerCreep';
        else
            return false;
        for (var m of this.memory.Misson[range]) {
            if (m.id == id) {
                /* 解绑lab */
                if (m.LabBind && Object.keys(m.LabBind).length > 0) {
                    for (var l in m.LabBind) {
                        // console.log('LabID: ',m.LabBind[l],'------解绑-------->MissonID: ',m.id)
                        this.UnBindLabData(l, m.id);
                    }
                }
                /* 解绑爬虫的任务 对于没有超时监测的任务，删除任务也要删除任务绑定的爬虫 */
                if (!m.reserve && m.CreepBind) {
                    for (var c in m.CreepBind)
                        for (var cc of m.CreepBind[c].bind) {
                            if (Game.creeps[cc]) {
                                /* 删除任务也意味着初始化任务数据内存 */
                                Game.creeps[cc].memory.MissionData = {};
                            }
                        }
                }
                /* 删除任务*/
                var index = this.memory.Misson[range].indexOf(m);
                this.memory.Misson[range].splice(index, 1);
                if (global.getMission[this.name][id])
                    delete global.getMission[this.name][id];
                if (!isInArray(Memory.ignoreMissonName, m.name))
                    console.log(Colorful$1(`${m.name} 任务删除 xxx ID:${m.id} Room:${this.name}`, 'blue'));
                return true;
            }
        }
        console.log(Colorful$1(`任务删除失败 ID:${id} Room:${this.name}`, 'red'));
        return false;
    }
    /*新房快速起步模块*/
    SpeedUpcontroller() {
        if ((Game.time - global.Gtime[this.name]) % 19)
            return;
        if (!this.memory.switch.speedstate)
            return;
        if (this.controller.level > 6) {
            this.memory.switch.speedstate = false;
            this.memory.SpawnConfig['initial_speed'].num = 0;
            return;
        }
    }
    /* 冷却计时器 */
    CoolDownCaculator() {
        for (var i in this.memory.CoolDownDic) {
            if (this.memory.CoolDownDic[i] > 0)
                this.memory.CoolDownDic[i] -= 1;
            else
                delete this.memory.CoolDownDic[i];
        }
    }
    /* 超时计时器 */
    DelayCaculator() {
        for (var key in this.memory.Misson) {
            for (var i of this.memory.Misson[key]) {
                if (i.processing && i.delayTick < 99995)
                    i.delayTick--;
                if (i.delayTick <= 0) {
                    /* 小于0就删除任务 */
                    this.DeleteMission(i.id);
                }
            }
        }
    }
    /* 任务解绑监测 */
    UnbindMonitor() {
        /* 只适用于Creep任务 */
        if ((Game.time - global.Gtime[this.name]) % 5)
            return;
        if (!this.memory.Misson['Creep'])
            return;
        for (var m of this.memory.Misson['Creep']) {
            if (!m.CreepBind)
                continue;
            if (m.CreepBind && Object.keys(m.CreepBind).length > 0) {
                for (var r in m.CreepBind) {
                    for (var c of m.CreepBind[r].bind)
                        if (!Game.creeps[c]) {
                            //console.log(`已经清除爬虫${c}的绑定数据!`)
                            var index = m.CreepBind[r].bind.indexOf(c);
                            m.CreepBind[r].bind.splice(index, 1);
                        }
                }
            }
        }
    }
    /* 任务数量查询 */
    MissionNum(range, name) {
        if (!this.memory.Misson)
            this.memory.Misson = {};
        if (!this.memory.Misson[range])
            this.memory.Misson[range] = [];
        let n = 0;
        for (var i of this.memory.Misson[range]) {
            if (i.name == name) {
                n += 1;
            }
        }
        return n;
    }
    /* 与role相关的任务数量查询 */
    RoleMissionNum(role, name) {
        let Rolekey = `${role}|${name}|${this.memory.Misson['Creep'].length}`;
        if (!global.RoleMissionNum[this.name][Rolekey]) {
            let n = 0;
            for (var i of this.memory.Misson['Creep']) {
                if (!i.CreepBind)
                    continue;
                if (i.name == name && isInArray(Object.keys(i.CreepBind), role)) {
                    n += 1;
                }
            }
            global.RoleMissionNum[this.name][Rolekey] = n;
        }
        return global.RoleMissionNum[this.name][Rolekey];
    }
    /* 获取任务 */
    GainMission(id) {
        if (global.getMission[this.name][id])
            return global.getMission[this.name][id];
        for (var i in this.memory.Misson) {
            for (var t of this.memory.Misson[i]) {
                if (t.id == id) {
                    global.getMission[this.name][id] = t;
                    return t;
                }
            }
        }
        return null;
    }
    /* 通过名称获取唯一任务 */
    MissionName(range, name) {
        for (var i of this.memory.Misson[range]) {
            if (i.name == name) {
                return i;
            }
        }
        return null;
    }
    /* 判断实验室资源类型是否一致 */
    CheckLabType(id, rType) {
        if (!this.memory.RoomLabBind)
            this.memory.RoomLabBind = {};
        for (var i in this.memory.RoomLabBind) {
            if (i == id) {
                var thisLab = Game.getObjectById(i);
                if (!thisLab)
                    return false;
                if (thisLab.mineralType && thisLab.mineralType != rType) {
                    return false;
                }
                if (this.memory.RoomLabBind[i].rType != rType)
                    return false;
                return true;
            }
        }
        return true;
    }
    /* 判断是否允许新增 */
    CheckLabOcc(id) {
        if (!this.memory.RoomLabBind)
            this.memory.RoomLabBind = {};
        for (var i in this.memory.RoomLabBind) {
            if (i == id) {
                if (this.memory.RoomLabBind[i].occ)
                    return false;
                return true;
            }
        }
        return true;
    }
    /* 设置lab绑定数据 */
    BindLabData(id, rType, MissonID, occ) {
        for (var i in this.memory.RoomLabBind) {
            if (i == id) {
                if (this.memory.RoomLabBind[i].rType != rType)
                    return false;
                if (!isInArray(this.memory.RoomLabBind[i].missonID, MissonID)) {
                    this.memory.RoomLabBind[i].missonID.push(MissonID);
                    return true;
                }
            }
        }
        // 说明不存在该id
        this.memory.RoomLabBind[id] = { missonID: [MissonID], rType: rType, occ: occ ? occ : false };
        return true;
    }
    /* 解绑lab绑定数据 */
    UnBindLabData(id, MissonID) {
        for (var i in this.memory.RoomLabBind) {
            if (i == id) {
                if (this.memory.RoomLabBind[i].missonID.length <= 1) {
                    if (!Memory.ignoreLab) {
                        console.log('LabID: ', i, '------解绑-------->MissonID: ', MissonID);
                    }
                    delete this.memory.RoomLabBind[i];
                    return true;
                }
                else {
                    for (var j of this.memory.RoomLabBind[i].missonID) {
                        if (j == MissonID) {
                            if (!Memory.ignoreLab) {
                                console.log('LabID: ', i, '------解绑-------->MissonID: ', MissonID);
                            }
                            var index = this.memory.RoomLabBind[i].missonID.indexOf(MissonID);
                            this.memory.RoomLabBind[i].missonID.splice(index, 1);
                            return true;
                        }
                    }
                    return false;
                }
            }
        }
        return false;
    }
    /* 任务所需角色孵化管理 */
    MissonRoleSpawn() {
        if (!this.memory.Misson['Creep'])
            this.memory.Misson['Creep'] = [];
        for (var misson of this.memory.Misson['Creep']) {
            if (misson.CreepBind) {
                for (var role in misson.CreepBind) {
                    let memData = {};
                    if (RoleData[role].mem)
                        memData = RoleData[role].mem;
                    /* 间隔型 */
                    if (misson.CreepBind[role].interval) {
                        if (misson.CreepBind[role].num <= 0)
                            continue;
                        if (misson.CreepBind[role].interval <= 0)
                            continue;
                        /* 如果是间隔孵化型的爬虫角色 */
                        if (!misson.Data)
                            misson.Data = {};
                        if (!misson.Data.intervalTime)
                            misson.Data.intervalTime = Game.time;
                        if ((Game.time - misson.Data.intervalTime) % misson.CreepBind[role].interval == 0) {
                            /* 如果孵化队列里太多这种类型的爬虫就不孵化 最高允许10个 */
                            let n = 0;
                            for (var ii of this.memory.SpawnList) {
                                if (ii.role == role)
                                    n += 1;
                            }
                            if (n > 10)
                                continue;
                            memData["taskRB"] = misson.id;
                            if (misson.CreepBind[role].MSB) {
                                memData["msb"] = true;
                            }
                            for (let i = 0; i < misson.CreepBind[role].num; i++) {
                                this.SingleSpawn(role, RoleData[role].level ? RoleData[role].level : 10, memData);
                            }
                        }
                        continue;
                    }
                    /* 补全型 */
                    if (this.memory.state == 'war' && !RoleData[role].must)
                        continue; // 战争模式下非必要任务不运行
                    let spawnNum = misson.CreepBind[role].num - misson.CreepBind[role].bind.length;
                    if (spawnNum > 0 && !this.memory.SpawnConfig[role] && misson.Data.disShard != Game) {
                        /* 如果任务没招到爬，检查一下是否空闲爬 */
                        let relateSpawnList = this.SpawnListRoleNum(role);
                        let relateCreeps = _.filter(Game.creeps, (creep) => creep.memory.belong == this.name && creep.memory.role == role && (!creep.memory.MissionData || !creep.memory.MissionData.id)).length;
                        if (relateSpawnList + relateCreeps < spawnNum) {
                            if (misson.CreepBind[role].MSB) {
                                memData["msb"] = true;
                                memData["taskRB"] = misson.id;
                            }
                            this.SingleSpawn(role, RoleData[role].level ? RoleData[role].level : 10, memData);
                        }
                    }
                }
            }
        }
    }
    /* 判断lab的boost搬运模块 */
    Check_Lab(misson, role, tankType) {
        if (!misson.LabBind)
            return true;
        var tank_;
        if (tankType == 'storage') {
            if (!this.storage)
                return false;
            tank_ = this.storage;
        }
        else if (tankType == 'terminal') {
            if (!this.terminal)
                return false;
            tank_ = this.terminal;
        }
        // console.log(this.name, '填充检测', tankType)
        // var tank_ = Game.getObjectById(id as Id<Structure>) as StructureStorage | StructureTerminal
        /* 负责lab的填充 */
        var terminal = this.terminal;
        var storage = this.storage;
        let return_state = true;
        let _DispatchNum = DispatchNum(this.name);
        for (var i in misson.LabBind) {
            var All_i_Num;
            if (tankType == 'complex') {
                if (!terminal || !storage) {
                    if (storage)
                        tank_ = storage;
                    else if (terminal)
                        tank_ = terminal;
                    else
                        return false;
                }
                else {
                    var terminalNum = terminal ? terminal.store.getUsedCapacity(misson.LabBind[i]) : 0;
                    var storageNum = storage ? storage.store.getUsedCapacity(misson.LabBind[i]) : 0;
                    tank_ = terminalNum > storageNum ? terminal : storage;
                }
            }
            if (!tank_)
                return false;
            All_i_Num = tank_.store.getUsedCapacity(misson.LabBind[i]);
            if (All_i_Num < 4100) {
                /* 资源调度 */
                if (_DispatchNum <= 0 && this.MissionNum('Structure', '资源购买') <= 0 && !checkSend(this.name, misson.LabBind[i])) {
                    console.log(Colorful$1(`[资源调度] 房间${this.name}没有足够的资源[${misson.LabBind[i]}],将执行资源调度!`, 'yellow'));
                    let dispatchTask = {
                        sourceRoom: this.name,
                        rType: misson.LabBind[i],
                        num: 3000,
                        delayTick: 200,
                        conditionTick: 20,
                        buy: true,
                        mtype: 'deal'
                    };
                    Memory.ResourceDispatchData.push(dispatchTask);
                }
                return_state = false;
                continue;
            }
            var disLab = Game.getObjectById(i);
            if (!disLab) // 说明找不到lab了
             {
                let index = this.memory.StructureIdData.labs.indexOf(i);
                this.memory.StructureIdData.labs.splice(index, 1);
                return_state = false;
                continue;
            }
            // 去除无关资源
            if (disLab.mineralType && disLab.mineralType != misson.LabBind[i]) {
                var roleData = {};
                roleData[role] = { num: 1, bind: [] };
                var carryTask = this.public_Carry(roleData, 45, this.name, disLab.pos.x, disLab.pos.y, this.name, this.storage.pos.x, this.storage.pos.y, disLab.mineralType, disLab.store.getUsedCapacity(disLab.mineralType));
                this.AddMission(carryTask);
                // return_state = false;
                continue;
            }
            if (disLab.store.getUsedCapacity(misson.LabBind[i]) < 1800 && this.Check_Carry('transport', tank_.pos, disLab.pos, misson.LabBind[i])) {
                if (All_i_Num < 1000)
                    continue;
                var roleData = {};
                roleData[role] = { num: 1, bind: [] };
                var carryTask = this.public_Carry(roleData, 45, this.name, tank_.pos.x, tank_.pos.y, this.name, disLab.pos.x, disLab.pos.y, misson.LabBind[i], All_i_Num >= 2000 ? 2000 : All_i_Num);
                this.AddMission(carryTask);
                return_state = false;
                continue;
            }
        }
        return return_state;
    }
    /* 判断已经有了该类型的搬运任务 true:代表没有重复， false代表有 */
    Check_Carry(role, source, pos, rType) {
        for (let i of this.memory.Misson['Creep']) {
            if (!i.CreepBind)
                continue;
            if (i.name != '物流运输')
                continue;
            if (i.CreepBind[role] && (rType ? i.Data.rType == rType : true)) {
                let sourcePos = new RoomPosition(i.Data.sourcePosX, i.Data.sourcePosY, i.Data.sourceRoom);
                let disPos = new RoomPosition(i.Data.targetPosX, i.Data.targetPosY, i.Data.targetRoom);
                if (sourcePos.isEqualTo(source) && disPos.isEqualTo(pos))
                    return false;
            }
        }
        return true;
    }
    /* 判断是否已经有了该类型的link任务 true:代表没有重复 false代表有 */
    Check_Link(source, po) {
        let sourceLink = source.GetStructure('link');
        let posLink = po.GetStructure('link');
        if (!sourceLink || !posLink) {
            console.log(`${this.name}出现check_link错误!`);
            return false;
        }
        for (let i of this.memory.Misson['Structure']) {
            if (i.name == "链传送能" && isInArray(i.structure, sourceLink.id) && i.Data.disStructure == posLink.id) {
                return false;
            }
        }
        return true;
    }
    // 判断房间是否存在资源购买指定资源的任务
    Check_Buy(resource) {
        for (let i of this.memory.Misson['Structure']) {
            if (i.name == '资源购买' && i.Data.rType == resource)
                return true;
        }
        return false;
    }
    Check_ResourceType(rType, Num) {
        if (Object.keys(global.RoomResource).length < 1) {
            for (let Roomname in Game.rooms) {
                let _RoomData = Game.rooms[Roomname];
                if (!global.RoomResource[_RoomData.name]) {
                    global.RoomResource[_RoomData.name] = {};
                }
                if (_RoomData.storage) {
                    global.RoomResource[_RoomData.name] = _RoomData.storage.store;
                }
            }
        }
        /*开始类型检索操作*/
        for (let Roomname in global.RoomResource) {
            let _RoomData = global.RoomResource[Roomname];
            let rTypeNum = _RoomData[rType];
            if (!rTypeNum)
                continue;
            /*标记rType 查询保存量*/
            var basic_num = 0;
            if (this.name != Roomname) {
                basic_num = 8000;
                if (isInArray(t3, rType)) {
                    basic_num = 8000;
                }
                else if (isInArray(['X', 'L', 'Z', 'U', 'K', 'O', 'H', 'ops'], rType)) {
                    basic_num = 15000;
                }
                else if (isInArray(['composite', 'crystal', 'liquid',
                    'switch', 'transistor', 'microchip', 'circuit', 'device',
                    'phlegm', 'tissue', 'muscle', 'organoid', 'organism',
                    'tube', 'fixtures', 'frame', 'hydraulics', 'machine',
                    'concentrate', 'extract', 'spirit', 'emanation', 'essence'], rType)) {
                    basic_num = 0;
                }
                if (global.ResourceLimit[Roomname]) {
                    if (global.ResourceLimit[Roomname][rType]) {
                        basic_num = global.ResourceLimit[Roomname][rType];
                    }
                }
            }
            if (rTypeNum && rTypeNum - basic_num >= Num) {
                return true;
            }
        }
        return false;
    }
    GetStructData(build) {
        if (isInArray(['powerspawn', 'factory', 'Ntower', 'Atower'], build)) {
            switch (build) {
                case 'powerspawn':
                    let powerspawn_data = this.getStructure(STRUCTURE_POWER_SPAWN);
                    if (powerspawn_data)
                        return powerspawn_data[0];
                    break;
                case 'factory':
                    let factory_data = this.getStructure(STRUCTURE_FACTORY);
                    if (factory_data)
                        return factory_data[0];
                    break;
            }
        }
        return null;
    }
}

/* 房间原型拓展   --任务  --任务发布便捷函数 */
class RoomMissonPublish extends Room {
    /**
     * 搬运任务发布函数
     * @param creepData 爬虫绑定信息，例如：{'repair':{num:1,bind:[]},'build':{num:2,bind:[]}}
     * @param delayTick 任务的超时时间，如果不想设置超时可以设置为99999
     * @param sR        提取资源的建筑所在房间
     * @param sX        提取资源的建筑X坐标
     * @param sY        提取资源的建筑Y坐标
     * @param tR        存放资源的建筑所在房间
     * @param tX        存放资源的建筑X坐标
     * @param tY        存放资源的建筑Y坐标
     * @param rType     资源类型[可选] 例如： 'energy' 或者 'XLH2O'等
     * @param num       要搬运的数量[可选]
     * @returns         任务对象
     */
    public_Carry(creepData, delayTick, sR, sX, sY, tR, tX, tY, rType, num) {
        var thisTask = {
            name: '物流运输',
            CreepBind: creepData,
            range: 'Creep',
            delayTick: delayTick,
            cooldownTick: 1,
            maxTime: 3,
            Data: {
                sourceRoom: sR,
                sourcePosX: sX,
                sourcePosY: sY,
                targetRoom: tR,
                targetPosX: tX,
                targetPosY: tY,
            }
        };
        if (rType)
            thisTask.Data.rType = rType;
        if (num)
            thisTask.Data.num = num;
        return thisTask;
    }
    public_Carrygleaner(disRoom, CreepNum, suicide, interval, level = 'T0') {
        var thisTask = {
            name: '拾荒者',
            range: 'Creep',
            delayTick: 99999,
            Data: {
                disRoom: disRoom,
                level: level,
                suicide: suicide
            }
        };
        thisTask.CreepBind = { 'gleaner': { num: CreepNum, interval: interval, bind: [], MSB: (level ? true : false) } };
        switch (level) {
            case 'T3':
                thisTask.LabMessage = { 'XKH2O': 'boost', 'XZHO2': 'boost' };
                break;
            case 'T2':
                thisTask.LabMessage = { 'KH2O': 'boost', 'ZHO2': 'boost' };
                break;
            case 'T1':
                thisTask.LabMessage = { 'KH': 'boost', 'ZO': 'boost' };
                break;
        }
        return thisTask;
    }
    public_Carrymine(disRoom, creepNum, level) {
        var thisTask = {
            name: '外矿偷取',
            range: 'Creep',
            delayTick: 99999,
            maxTime: 3,
            Data: {
                disRoom: disRoom,
            }
        };
        thisTask.CreepBind = { 'steal': { num: creepNum, interval: 1350, bind: [], MSB: (level === 'T1') ? true : false } };
        return thisTask;
    }
    public_Carryshard(disRoom, CreepNum, shard, res, interval, level = 'T0') {
        var thisTask = {
            name: '位面运输',
            range: 'Creep',
            delayTick: 99999,
            Data: {
                disRoom: disRoom,
                shard: shard,
                rType: res,
                level: level
            },
            reserve: true
        };
        thisTask.CreepBind = { 'truckshard': { num: CreepNum, interval: interval, bind: [], MSB: (level ? true : false) } };
        switch (level) {
            case 'T9': /*跨位面高净值物品专用*/
                thisTask.LabMessage = { 'XKH2O': 'boost', 'XZHO2': 'boost', 'XGHO2': 'boost', 'XLHO2': 'boost' };
                break;
            case 'T3':
                thisTask.LabMessage = { 'XKH2O': 'boost', 'XZHO2': 'boost' };
                break;
            case 'T2':
                thisTask.LabMessage = { 'KH2O': 'boost', 'ZHO2': 'boost' };
                break;
            case 'T1':
            case 'T11':
                thisTask.LabMessage = { 'KH': 'boost', 'ZO': 'boost' };
                break;
        }
        return thisTask;
    }
    /**
     * 修墙任务的发布函数
     * @param Rtype     维修范围： global->全局维修 special->黄黑旗下建筑维修 nuker->核弹防御
     * @param num       任务相关维修爬数量
     * @param boostType boost类型 null->无boost LH/LH2O/XLH2O是boost类型
     * @param level     身体部件 分为 T0 T1 T2
     * @returns         任务对象
     */
    public_repair(Rtype, num, boostType, level, maxhit, retain) {
        var thisTask = {
            name: '墙体维护',
            range: 'Creep',
            delayTick: 99999,
            level: 10,
            Data: {
                RepairType: Rtype,
                num: num,
                boostType: boostType,
                level: level,
                maxhit: maxhit,
                retain: retain
            },
            maxTime: 3
        };
        thisTask.CreepBind = { 'repair': { num: num, bind: [], MSB: (level ? true : false) } };
        if (boostType == 'LH') {
            thisTask.LabMessage = { 'LH': 'boost' };
        }
        else if (boostType == 'LH2O') {
            thisTask.LabMessage = { 'LH2O': 'boost' };
        }
        else if (boostType == 'XLH2O') {
            thisTask.LabMessage = { 'XLH2O': 'boost' };
        }
        switch (level) {
            case 'T1':
                thisTask.LabMessage['KH'] = 'boost';
                thisTask.LabMessage['ZO'] = 'boost';
                break;
            case 'T2':
                thisTask.LabMessage['KH2O'] = 'boost';
                thisTask.LabMessage['ZHO2'] = 'boost';
                break;
            case 'T3':
                thisTask.LabMessage['XKH2O'] = 'boost';
                thisTask.LabMessage['XZHO2'] = 'boost';
                break;
        }
        thisTask.maxTime = 3;
        return thisTask;
    }
    /**
     *                  C计划 即占领一个房间开启安全模式，建造wall，保护主房
     * @param disRoom   目标房间
     * @returns         任务对象
     */
    public_planC(disRoom, Cnum, upNum, shard) {
        var thisTask = {
            name: 'C计划',
            range: 'Creep',
            delayTick: 20500,
            level: 10,
            Data: {
                state: 0,
                disRoom: disRoom,
            },
        };
        thisTask.reserve = true;
        if (!shard) {
            thisTask.Data.shard = Game.shard.name;
            thisTask.CreepBind = { 'cclaim': { num: Cnum, bind: [] }, 'cupgrade': { num: upNum, bind: [] } };
        }
        else {
            thisTask.Data.shard = shard;
            thisTask.CreepBind = { 'cclaim': { num: Cnum, bind: [], interval: 1000 }, 'cupgrade': { num: upNum, bind: [], interval: 1000 } };
        }
        return thisTask;
    }
    /**
     *                  link传任务发布函数
     * @param structure 传送的link
     * @param dislink   目的link
     * @param level     传送任务等级
     * @param delayTick 过期时间
     * @returns         任务对象
     */
    public_link(structure, dislink, level, delayTick) {
        var thisTask = {
            name: '链传送能',
            range: 'Structure',
            delayTick: 20,
            structure: structure,
            level: level,
            Data: {
                disStructure: dislink
            }
        };
        if (delayTick)
            thisTask.delayTick = delayTick;
        return thisTask;
    }
    /**
     *                  拆迁任务发布函数
     * @param disRoom   目标房间
     * @param num       数量
     * @param interval  时间间隔
     * @param boost     是否boost
     * @returns         任务对象
     */
    public_dismantle(disRoom, shard, num, interval, boost) {
        var thisTask = {
            name: '黄球拆迁',
            range: 'Creep',
            delayTick: 20500,
            level: 10,
            Data: {
                disRoom: disRoom,
                num: num,
                shard: shard
            },
        };
        thisTask.reserve = true;
        if (this.controller.level <= 5)
            thisTask.Data.boost = false;
        if (boost) {
            thisTask.Data.boost = true;
            thisTask.LabMessage = { 'XZHO2': 'boost', 'XZH2O': 'boost' };
        }
        thisTask.CreepBind = { 'dismantle': { num: 0, interval: interval ? interval : 1200, bind: [], MSB: (boost ? true : false) } };
        return thisTask;
    }
    public_cconstruction(disRoom, disShard, num, interval, boost, bodylevel) {
        var thisTask = {
            name: '踩工地',
            range: 'Creep',
            delayTick: 80000,
            level: 10,
            Data: {
                disRoom: disRoom,
                num: num,
                shard: disShard,
            },
            maxTime: 5,
            reserve: true
        };
        if (boost) {
            switch (bodylevel) {
                case 'T3':
                    thisTask.Data.boost = true;
                    thisTask.LabMessage = { 'XZHO2': 'boost', 'XGHO2': 'boost', 'XLHO2': 'boost', 'XKHO2': 'boost' };
                    break;
            }
            if (bodylevel)
                thisTask.Data.bodylevel = bodylevel; // 一体机体型
        }
        else
            thisTask.Data.boost = false;
        thisTask.CreepBind = { 'c-construction-site': { num: 0, interval: interval, bind: [], MSB: (boost ? true : false) } };
        thisTask.reserve = true;
        return thisTask;
    }
    public_aio(disRoom, disShard, num, interval, boost, bodylevel) {
        var thisTask = {
            name: '攻防一体',
            range: 'Creep',
            delayTick: 80000,
            level: 10,
            Data: {
                disRoom: disRoom,
                num: num,
                shard: disShard,
            },
            maxTime: 5
        };
        if (boost) {
            switch (bodylevel) {
                case 'T9':
                    break;
                case 'T8':
                    thisTask.Data.boost = true;
                    thisTask.LabMessage = { 'ZO': 'boost', 'LO': 'boost', 'KO': 'boost' };
                    break;
                case 'T0':
                    thisTask.Data.boost = true;
                    thisTask.LabMessage = { 'XZHO2': 'boost', 'XGHO2': 'boost', 'XLHO2': 'boost', 'XKHO2': 'boost' };
                    break;
                default:
                    thisTask.Data.boost = true;
                    thisTask.LabMessage = { 'XZHO2': 'boost', 'XGHO2': 'boost', 'XLHO2': 'boost', 'XKHO2': 'boost' };
                    break;
            }
            if (bodylevel)
                thisTask.Data.bodylevel = bodylevel; // 一体机体型
        }
        else
            thisTask.Data.boost = false;
        thisTask.CreepBind = { 'aio': { num: 0, interval: interval, bind: [], MSB: (boost ? true : false) } };
        thisTask.reserve = true;
        return thisTask;
    }
    public_control(disRoom, shard, interval) {
        var thisTask = {
            name: '控制攻击',
            range: 'Creep',
            delayTick: 99999,
            level: 10,
            Data: {
                disRoom: disRoom,
                shard: shard,
            },
        };
        thisTask.reserve = true;
        thisTask.CreepBind = { 'claim-attack': { num: 1, interval: interval, bind: [] } };
        return thisTask;
    }
    /**
     *                  急速冲级任务发布函数
     * @param num       冲级爬数量
     * @param boostType boost类型
     * @returns         任务对象
     */
    public_quick(num, Type) {
        var thisTask = {
            name: '急速冲级',
            range: 'Creep',
            delayTick: 99999,
            level: 10,
            Data: {},
            reserve: true
        };
        thisTask.CreepBind = { 'rush': { num: num, bind: [] } };
        if (Type && isInArray(['GH', 'GH2O', 'XGH2O'], Type)) {
            // console.log('极速冲级化合物',)
            thisTask.LabMessage = {};
            thisTask.LabMessage[Type] = 'boost';
        }
        return thisTask;
    }
    /**
     *                  普通冲级任务发布函数
     * @param num       冲级爬数量
     * @param boostType boost类型
     * @returns         任务对象
     */
    public_normal(num, boostType) {
        var thisTask = {
            name: '急速冲级',
            range: 'Creep',
            delayTick: 99999,
            level: 10,
            Data: {},
        };
        thisTask.CreepBind = { 'rush': { num: num > 2 ? 2 : num, bind: [] } };
        if (boostType && isInArray(['GH', 'GH2O', 'XGH2O'], boostType)) {
            thisTask.LabMessage = { boostType: 'boost' };
        }
        return thisTask;
    }
    /**
     *
     * @param disRoom 目标房间
     * @param shard 目标房间shard
     * @param num  援建工和升级工分别数量
     * @param cnum claimer数量
     * @param defend 是否需要能抵抗一定攻击的能力
     * @returns 任务模型
     */
    public_expand(disRoom, shard, num, cnum, level) {
        let defend = true;
        var thisTask = {
            name: '扩张援建',
            range: 'Creep',
            delayTick: 99999,
            level: 10,
            maxTime: 2,
            Data: {
                disRoom: disRoom,
                shard: shard,
                defend: defend,
                level: level
            },
        };
        thisTask.reserve = true;
        thisTask.CreepBind = {
            'claim': { num: cnum, bind: [], interval: 1000, MSB: defend  },
            'Ebuild': { num: num, bind: [], interval: 1000, MSB: defend  },
            'Eupgrade': { num: num, bind: [], interval: 1000, MSB: defend  }
        };
        {
            switch (level) {
                case 'T1':
                    thisTask.LabMessage = { 'GH': 'boost', 'ZO': 'boost' };
                    break;
                case 'T2':
                    thisTask.LabMessage = { 'GH2O': 'boost', 'ZHO2': 'boost' };
                    break;
                case 'T3':
                    thisTask.LabMessage = { 'XGH2O': 'boost', 'XZHO2': 'boost', 'XKH2O': 'boost' };
                    break;
                case 'T4':
                    break;
                case 'T5':
                    thisTask.LabMessage = { 'GH': 'boost', 'ZO': 'boost' };
                    break;
                case 'T6':
                    thisTask.LabMessage = { 'GH2O': 'boost', 'ZHO2': 'boost' };
                    break;
                case 'T7':
                    thisTask.LabMessage = { 'XGH2O': 'boost', 'XZHO2': 'boost', 'XKH2O': 'boost', 'XLHO2': 'boost' };
                    break;
            }
        }
        return thisTask;
    }
    public_helpRepair(disRoom, num, shard, time, boostType, level) {
        var thisTask = {
            name: '紧急墙体',
            range: 'Creep',
            delayTick: 20000,
            level: 10,
            Data: {
                disRoom: disRoom,
                num: num,
                shard: shard ? shard : Game.shard.name,
                level: level
            },
            maxTime: 2,
            reserve: true
        };
        thisTask.reserve = true;
        thisTask.CreepBind = { 'repair-work': { num: num, bind: [], interval: time ? time : 1000, MSB: (level ? true : false) } };
        if (boostType) {
            if (boostType == 'LH') {
                thisTask.LabMessage = { 'LH': 'boost' };
            }
            else if (boostType == 'LH2O') {
                thisTask.LabMessage = { 'LH2O': 'boost' };
            }
            else if (boostType == 'XLH2O') {
                thisTask.LabMessage = { 'XLH2O': 'boost' };
            }
        }
        switch (level) {
            case 'T3':
                thisTask.LabMessage = { 'LH2O': 'boost', 'KH2O': 'boost', 'XZHO2': 'boost' };
                break;
        }
        thisTask.maxTime = 3;
        return thisTask;
    }
    public_helpBuild(disRoom, num, shard, time, defend) {
        var thisTask = {
            name: '紧急援建',
            range: 'Creep',
            delayTick: 20000,
            level: 10,
            Data: {
                disRoom: disRoom,
                num: num,
                shard: shard ? shard : Game.shard.name,
                defend: defend,
            },
            maxTime: 2,
            reserve: true
        };
        thisTask.reserve = true;
        thisTask.CreepBind = {
            'architect': { num: num, bind: [], interval: time ? time : 1000, MSB: (defend ? false : true) },
        };
        if (defend) // 有防备的
         {
            thisTask.LabMessage = { 'XZHO2': 'boost', 'XLH2O': 'boost', 'XLHO2': 'boost', 'XGHO2': 'boost', 'XKH2O': 'boost' };
        }
        else {
            thisTask.LabMessage = { 'XZHO2': 'boost', 'XLH2O': 'boost', 'XKH2O': 'boost' };
        }
        return thisTask;
    }
    public_helpUpgrade(disRoom, num, shard, time, defend) {
        var thisTask = {
            name: '紧急升级',
            range: 'Creep',
            delayTick: 20000,
            level: 10,
            Data: {
                disRoom: disRoom,
                num: num,
                shard: shard ? shard : Game.shard.name,
                defend: defend,
            },
            maxTime: 2,
            reserve: true
        };
        thisTask.reserve = true;
        thisTask.CreepBind = {
            'upgrade-work': { num: num, bind: [], interval: time ? time : 1000, MSB: (defend ? false : true) },
        };
        if (defend) // 有防备的
         {
            thisTask.LabMessage = { 'XZHO2': 'boost', 'XGH2O': 'boost', 'XLHO2': 'boost', 'XGHO2': 'boost', 'XKH2O': 'boost' };
        }
        else {
            thisTask.LabMessage = { 'XZHO2': 'boost', 'XGH2O': 'boost', 'XKH2O': 'boost' };
        }
        return thisTask;
    }
    public_support(disRoom, sType, shard, num = 1, boost) {
        var thisTask = {
            name: '紧急支援',
            range: 'Creep',
            delayTick: 20000,
            level: 10,
            Data: {
                disRoom: disRoom,
                sType: sType,
                boost: boost
            },
            maxTime: 3,
        };
        thisTask.reserve = true;
        if (sType == 'double') {
            thisTask.CreepBind = { 'double-attack': { num: num, bind: [], interval: 1000 }, 'double-heal': { num: num, bind: [], interval: 1000 } };
            thisTask.LabMessage = { 'XUH2O': 'boost', 'XLHO2': 'boost', 'XZHO2': 'boost', 'XGHO2': 'boost', 'XKHO2': 'boost' };
        }
        else if (sType == 'aio') {
            thisTask.CreepBind = { 'saio': { num: num, bind: [], interval: 1000 } };
            thisTask.LabMessage = { 'XLHO2': 'boost', 'XZHO2': 'boost', 'XGHO2': 'boost', 'XKHO2': 'boost' };
        }
        if (shard)
            thisTask.Data.shard = shard;
        else
            thisTask.Data.shard = Game.shard.name;
        return thisTask;
    }
    /* 双人小队发布函数 */
    public_Double(disRoom, shard, CreepNum, cType, interval) {
        var thisTask = {
            name: '双人小队',
            range: 'Creep',
            delayTick: 20000,
            level: 10,
            Data: {
                disRoom: disRoom,
                shard: shard,
                teamType: cType,
                num: CreepNum
            },
            reserve: true
        };
        if (!interval || interval < 100)
            return null;
        if (cType == 'dismantle') {
            thisTask.CreepBind = { 'double-dismantle': { num: CreepNum, bind: [], interval: interval }, 'double-heal': { num: CreepNum, bind: [], interval: interval } };
            thisTask.LabMessage = { 'XZHO2': 'boost', 'XZH2O': 'boost', 'XGHO2': 'boost', 'XLHO2': 'boost', 'XKHO2': 'boost' };
        }
        else {
            thisTask.CreepBind = { 'double-attack': { num: CreepNum, bind: [], interval: interval }, 'double-heal': { num: CreepNum, bind: [], interval: interval } };
            thisTask.LabMessage = { 'XUH2O': 'boost', 'XZHO2': 'boost', 'XGHO2': 'boost', 'XLHO2': 'boost', 'XKHO2': 'boost' };
        }
        return thisTask;
    }
    public_Sign(disRoom, shard, str) {
        var thisTask = {
            name: '房间签名',
            range: 'Creep',
            delayTick: 1600,
            level: 10,
            Data: {
                disRoom: disRoom,
                shard: shard,
                str: str, // 签名内容
            },
            maxTime: 2 // 最大同时任务数量
        };
        thisTask.CreepBind = { 'scout': { num: 1, bind: [] } };
        return thisTask;
    }
    /* 资源传送任务发布函数 */
    public_Send(disRoom, rType, num) {
        if (!this.memory.StructureIdData.terminalID)
            return null;
        var terminal = this.terminal;
        if (!terminal) {
            delete this.memory.StructureIdData.terminalID;
            return null;
        }
        var thisTask = {
            name: '资源传送',
            range: 'Structure',
            delayTick: 2500,
            structure: [terminal.id],
            level: 5,
            Data: {
                disRoom: disRoom,
                rType: rType,
                num: num
            },
            maxTime: 8
        };
        return thisTask;
    }
    /**
     *  资源购买任务发布函数 做多同时允许3个
     * @param res   要购买的资源
     * @param num   要购买的数量
     * @param range 价格波动可接受区间
     * @param max   最高接受的价格
     * @returns     任务对象
     */
    public_Buy(res, num, range, max) {
        if (!this.memory.StructureIdData.terminalID)
            return null;
        var terminal = this.terminal;
        if (!terminal) {
            delete this.memory.StructureIdData.terminalID;
            return null;
        }
        /* 开始进行任务 */
        var thisTask = {
            name: '资源购买',
            range: 'Structure',
            structure: [terminal.id],
            delayTick: 60,
            level: 10,
            maxTime: 3,
            Data: {
                rType: res,
                num: num,
                range: range
            }
        };
        thisTask.Data.maxPrice = max ? max : 35;
        return thisTask;
    }
    public_Compound(num, disResource, bindData) {
        // 检验阶段
        if (!this.memory.StructureIdData.labInspect || Object.keys(this.memory.StructureIdData.labInspect).length < 3)
            return null;
        var raw1 = Game.getObjectById(this.memory.StructureIdData.labInspect.raw1);
        var raw2 = Game.getObjectById(this.memory.StructureIdData.labInspect.raw2);
        if (!raw1) {
            delete this.memory.StructureIdData.labInspect.raw1;
            return;
        }
        if (!raw2) {
            delete this.memory.StructureIdData.labInspect.raw2;
            return;
        }
        for (var i of this.memory.StructureIdData.labInspect.com) {
            var thisLab = Game.getObjectById(i);
            if (!thisLab) {
                var index = this.memory.StructureIdData.labInspect.com.indexOf(i);
                this.memory.StructureIdData.labInspect.com.splice(index, 1);
                continue;
            }
        }
        var raw1str = LabMap[disResource].raw1;
        var raw2str = LabMap[disResource].raw2;
        /* 开始进行任务 */
        var thisTask = {
            name: '资源合成',
            range: 'Room',
            delayTick: 50000,
            processing: true,
            level: 10,
            LabBind: {},
            Data: {
                num: num
            }
        };
        thisTask.LabMessage = {};
        thisTask.LabMessage[raw1str] = 'raw';
        thisTask.LabMessage[raw2str] = 'raw';
        thisTask.LabMessage[disResource] = 'com';
        thisTask.Data.raw1 = raw1str;
        thisTask.Data.raw2 = raw2str;
        return thisTask;
    }
    /* 外矿开采任务发布函数 */
    public_OutMine(sourceRoom, x, y, disRoom, central) {
        var pos = new RoomPosition(x, y, sourceRoom);
        if (!this.storage)
            return null;
        if (!pos)
            return null;
        // 检查是否已经存在重复任务了
        for (var i of this.memory.Misson['Creep']) {
            if (i.name == '外矿开采' && i.Data.disRoom == disRoom)
                return null;
        }
        var thisTask = {
            name: '外矿开采',
            range: 'Creep',
            delayTick: 99999,
            level: 10,
            Data: {
                disRoom: disRoom,
                central: central ? central : false,
                startpoint: zipPosition(pos)
            },
        };
        thisTask.CreepBind = { 'out-claim': { num: 0, bind: [] }, 'out-harvest': { num: 0, bind: [] }, 'out-car': { num: 0, bind: [] }, 'out-defend': { num: 0, bind: [] }, 'out-attack': { num: 0, bind: [] }, 'out-carry': { num: 0, bind: [] } };
        return thisTask;
    }
    /* power采集任务发布函数 */
    public_PowerHarvest(disRoom, x, y, num) {
        var thisTask = {
            name: 'power采集',
            range: 'Creep',
            delayTick: 5000,
            level: 10,
            Data: {
                room: disRoom,
                x: x,
                y: y,
                state: 1,
                num: num,
                Cnum: Math.ceil(num / 1600)
            },
            maxTime: 2,
        };
        thisTask.CreepBind = { 'power-attack': { num: 1, bind: [] }, 'power-heal': { num: 1, bind: [] }, 'power-carry': { num: 0, bind: [] } };
        return thisTask;
    }
    /* deposit采集任务发布函数 */
    public_DepositHarvest(disRoom, x, y, rType, Num = 1) {
        var thisTask = {
            name: 'deposit采集',
            range: 'Creep',
            delayTick: 10000,
            level: 10,
            Data: {
                room: disRoom,
                x: x,
                y: y,
                state: 1,
                rType: rType
            },
            maxTime: 2,
            reserve: true
        };
        // thisTask.CreepBind = { 'deposit': { num: 1, bind: [] } }
        thisTask.CreepBind = { 'deposit-harvest': { num: Num > 3 ? 3 : Num, bind: [] }, 'deposit-transfer': { num: 1, bind: [] } };
        // var MissonNum = this.MissionNum('Creep','deposit采集')
        // if (MissonNum > 2) return null
        // thisTask.maxTime = MissonNum
        return thisTask;
    }
    /* 红球防御任务发布函数 */
    public_red_defend(num) {
        if (num < 1)
            return null;
        var thisTask = {
            name: '红球防御',
            range: 'Creep',
            delayTick: 99999,
            reserve: false,
            level: 10,
            Data: {},
        };
        thisTask.CreepBind = {};
        thisTask.CreepBind['defend-attack'] = { num: num, bind: [] };
        thisTask.LabMessage = { 'XZHO2': 'boost', 'XUH2O': 'boost' };
        return thisTask;
    }
    /* 蓝球防御任务发布函数 */
    public_blue_defend(num) {
        if (num < 1)
            return null;
        var thisTask = {
            name: '蓝球防御',
            range: 'Creep',
            delayTick: 99999,
            reserve: false,
            level: 10,
            Data: {}
        };
        thisTask.CreepBind = {};
        thisTask.CreepBind['defend-range'] = { num: num, bind: [] };
        thisTask.LabMessage = { 'XZHO2': 'boost', 'XKHO2': 'boost' };
        return thisTask;
    }
    /* 双人小队防御任务发布函数 */
    public_double_defend(num) {
        if (num < 1)
            return null;
        var thisTask = {
            name: '双人防御',
            range: 'Creep',
            delayTick: 99999,
            reserve: false,
            level: 10,
            Data: {}
        };
        thisTask.CreepBind = {};
        thisTask.CreepBind['defend-douAttack'] = { num: num, bind: [] };
        thisTask.CreepBind['defend-douHeal'] = { num: num, bind: [] };
        thisTask.LabMessage = { 'XZHO2': 'boost', 'XUH2O': 'boost', 'XLHO2': 'boost', 'XGHO2': 'boost' };
        return thisTask;
    }
    /* 四人小队任务发布函数 */
    public_squad(disRoom, shard, interval, RNum, ANum, DNum, HNum, AIONum, flag) {
        var thisTask = {
            name: '四人小队',
            range: 'Creep',
            delayTick: 40000,
            level: 10,
            Data: {
                disRoom: disRoom,
                shard: shard,
                flag: flag
            },
            CreepBind: {},
            maxTime: 3,
            reserve: true
        };
        if (RNum + ANum + DNum + HNum + AIONum != 4)
            return null; // 防止数量不对
        if (HNum != 2 && AIONum != 4)
            return null; // 防止搭配不均
        let creepData = {
            'x-range': { num: RNum, bd: ['XZHO2', 'XLHO2', 'XKHO2', 'XGHO2'] },
            'x-heal': { num: HNum, bd: ['XZHO2', 'XLHO2', 'XKHO2', 'XGHO2'] },
            'x-aio': { num: AIONum, bd: ['XZHO2', 'XLHO2', 'XKHO2', 'XGHO2'] },
            'x-attack': { num: ANum, bd: ['XZHO2', 'XUH2O', 'XGHO2'] },
            'x-dismantle': { num: DNum, bd: ['XZHO2', 'XZH2O', 'XGHO2'] },
        };
        let tbd = [];
        for (var i in creepData) {
            if (creepData[i].num > 0) {
                thisTask.CreepBind[i] = { num: creepData[i].num, bind: [], interval: interval };
                for (var j of creepData[i].bd) {
                    if (!isInArray(tbd, j))
                        tbd.push(j);
                }
            }
        }
        let mes = {};
        for (let tbdRes of tbd) {
            mes[tbdRes] = 'boost';
        }
        thisTask.LabMessage = mes;
        return thisTask;
    }
    /* 资源转移任务发布函数 */
    public_resource_transfer(disRoom, resource, num, whitelist) {
        var thisTask = {
            name: '资源转移',
            range: 'Room',
            delayTick: 40000,
            level: 10,
            Data: {
                disRoom: disRoom,
                rType: resource ? resource : null,
                num: num ? num : 8000000,
                whitelist: whitelist ? whitelist : []
            },
            maxTime: 1,
        };
        return thisTask;
    }
    /* 资源链任务发布函数 */
    /**
     * 智能战争发布引擎
     * @param disRoom 目标房间
     * @param shard 目标房间shard
     * @param boost  是否进行boost
     * @returns 任务模型
     */
    public_Aidestroy(disRoom, shard, boost, bodylevel) {
        var thisTask = {
            name: '智能战争',
            range: 'Room',
            delayTick: 99999,
            level: 10,
            Data: {
                disRoom: disRoom,
                shard: shard
            },
        };
        if (boost) {
            thisTask.Data.boost = boost;
        }
        if (bodylevel) {
            thisTask.Data.bodylevel = bodylevel;
        }
        // thisTask.reserve = true
        // thisTask.CreepBind = { 'ai-sentry': { num: 1, interval: 1000, bind: [] } }
        // thisTask.LabMessage = { 'XZHO2': 'boost', 'XLHO2': 'boost', 'XGHO2': 'boost' }
        return thisTask;
    }
}

/* 资源调度模块 */
// 主调度函数
function ResourceDispatch(thisRoom) {
    if (Game.cpu.bucket < 3000 && Memory.StopPixel)
        return;
    if ((Game.time - global.Gtime[thisRoom.name]) % 15)
        return;
    // 处理订单前检查
    let storage_ = thisRoom.storage;
    let terminal_ = thisRoom.terminal;
    if (thisRoom.controller.level < 6 || !storage_ || !terminal_)
        return;
    if (thisRoom.MissionNum('Structure', '资源传送') >= 1)
        return; // 如果房间有资源传送任务，则不执行
    // ResourceLimit更新
    ResourceLimitUpdate(thisRoom);
    /* 对资源调度进行操作 */
    for (let i of Memory.ResourceDispatchData) {
        // 执行资源调度
        if (i.sourceRoom == thisRoom.name) {
            // 执行买操作
            if (i.conditionTick <= 0 && i.buy) {
                if (i.mtype == 'order') {
                    /**
                     *       1.获取近两天的平均价格
                     *       2.拉取平均价格+10以内价格最高的订单
                     *       3.发布订单的价格比最高的订单的价格多0.01
                    */
                    console.log(Colorful$1(`[资源调度] 房间${thisRoom.name}需求资源[${i.rType}]无法调度,将进行购买! 购买方式为${i.mtype},购买数量${i.num}`, 'yellow'));
                    let ave = avePrice(i.rType, 2);
                    if (!haveOrder(thisRoom.name, i.rType, 'buy', ave)) {
                        let highest = highestPrice(i.rType, 'buy', ave + 10);
                        let result = Game.market.createOrder({
                            type: ORDER_BUY,
                            resourceType: i.rType,
                            price: highest + 0.01,
                            totalAmount: i.num,
                            roomName: thisRoom.name
                        });
                        if (result != OK) {
                            console.log("[资源调度]创建能量订单出错,房间", thisRoom.name);
                            continue;
                        }
                        console.log(Colorful$1(`房间${thisRoom.name}创建${i.rType}订单,价格:${highest + 0.01};数量:${i.num}`, 'green', true));
                        i.delayTick = 0;
                    }
                    continue;
                }
                else if (i.mtype == 'deal') {
                    if (isInArray(['energy'], i.rType))
                        continue; /*能量将不会进行deal操作*/
                    if (thisRoom.Check_Buy(i.rType) || thisRoom.MissionNum('Structure', '资源购买') >= 2)
                        continue;
                    // 在一定范围内寻找最便宜的订单deal 例如平均价格20 范围 10 最高价格31 便只能接受30以下的价格 （根据资源不同选择不同参数）
                    console.log(Colorful$1(`[资源调度] 房间${thisRoom.name}需求资源[${i.rType}]无法调度,将进行购买! 购买方式为${i.mtype},购买数量:${i.num}`, 'yellow'));
                    // 能量 ops
                    if (isInArray(['ops', 'energy'], i.rType)) {
                        let task = thisRoom.public_Buy(i.rType, i.num, 5, 50);
                        if (task) {
                            thisRoom.AddMission(task);
                            i.delayTick = 0;
                        }
                        continue;
                    }
                    // 原矿 中间化合物
                    else if (isInArray(['X', 'L', 'H', 'O', 'Z', 'K', 'U', 'G', 'OH', 'ZK', 'UL'], i.rType)) {
                        let task = thisRoom.public_Buy(i.rType, i.num, 10, 20);
                        if (task) {
                            thisRoom.AddMission(task);
                            i.delayTick = 0;
                        }
                        continue;
                    }
                    // t3
                    else if (isInArray(t3, i.rType)) {
                        let task = thisRoom.public_Buy(i.rType, i.num, 50, 300);
                        if (task) {
                            thisRoom.AddMission(task);
                            i.delayTick = 0;
                        }
                        continue;
                    }
                    // power
                    else if (i.rType == 'power') {
                        let task = thisRoom.public_Buy(i.rType, i.num, 20, 70);
                        if (task) {
                            thisRoom.AddMission(task);
                            i.delayTick = 0;
                        }
                        continue;
                    }
                    // t1 t2
                    else if (isInArray(t2, i.rType) || isInArray(t1, i.rType)) {
                        let task = thisRoom.public_Buy(i.rType, i.num, 20, 100);
                        if (task) {
                            thisRoom.AddMission(task);
                            i.delayTick = 0;
                        }
                        continue;
                    }
                    // 其他商品类资源 bar类资源
                    else {
                        let task = thisRoom.public_Buy(i.rType, i.num, 5, 20);
                        if (task) {
                            thisRoom.AddMission(task);
                            i.delayTick = 0;
                        }
                        continue;
                    }
                }
                else {
                    // 未定义i.mtype 便按照默认的执行
                    if (i.rType == 'energy')
                        i.mtype = 'order';
                    else
                        i.mtype = 'deal';
                    continue;
                }
            }
        }
        else {
            if (i.dealRoom)
                continue;
            // 接单
            if (storage_.store.getUsedCapacity(i.rType))
                var limitNum = global.ResourceLimit[thisRoom.name][i.rType] ? global.ResourceLimit[thisRoom.name][i.rType] : 0;
            if (storage_.store.getUsedCapacity(i.rType) <= 0)
                continue; // 没有就删除
            // console.log(i.rType,limitNum)
            // storage里资源大于等于调度所需资源
            if ((storage_.store.getUsedCapacity(i.rType) - limitNum) >= i.num) {
                var SendNum = i.num > 50000 ? 50000 : i.num;
                let task = thisRoom.public_Send(i.sourceRoom, i.rType, SendNum);
                if (task && thisRoom.AddMission(task)) {
                    if (i.num <= 50000)
                        i.dealRoom = thisRoom.name; // 如果调度数量大于50k 则只减少num数量
                    console.log(`房间${thisRoom.name}接取房间${i.sourceRoom}的资源调度申请,资源:${i.rType},数量:${SendNum}`);
                    i.num -= SendNum;
                    return;
                }
            }
            // sotrage里资源小于调度所需资源
            if ((storage_.store.getUsedCapacity(i.rType) - limitNum) > 0 && storage_.store.getUsedCapacity(i.rType) - limitNum < i.num) {
                let SendNum = storage_.store.getUsedCapacity(i.rType) - limitNum;
                let task = thisRoom.public_Send(i.sourceRoom, i.rType, SendNum);
                if (task && thisRoom.AddMission(task)) {
                    console.log(`房间${thisRoom.name}接取房间${i.sourceRoom}的资源调度申请,资源:${i.rType},数量:${SendNum}`);
                    i.num -= SendNum;
                    return;
                }
            }
        }
    }
}
// 调度信息超时管理器
function ResourceDispatchTick() {
    for (let i of Memory.ResourceDispatchData) {
        // 超时将删除调度信息
        if (!i.delayTick || i.delayTick <= 0 || i.num <= 0 || !i.rType) {
            console.log(`[资源调度]房间${i.sourceRoom}的[${i.rType}]资源调度删除!原因:调度任务已部署|超时|无效调度`);
            let index = Memory.ResourceDispatchData.indexOf(i);
            Memory.ResourceDispatchData.splice(index, 1);
        }
        if (i.delayTick > 0)
            i.delayTick--;
        if (i.conditionTick > 0) {
            if (i.dealRoom) // 有deal房间的时候， conditionTick衰减减慢
             {
                if (Game.time % 5 == 0)
                    i.conditionTick--;
            }
            else {
                i.conditionTick--;
            }
        }
    }
    /*帕瓦资源调度器 100tick 调度一次*/
    // if (Game.shard.name != 'shard3') return;
    if (Game.time % 101)
        return;
    if (Memory.PowerSupply.length > 0 && global.PowerDemand.length > 0) {
        let rType = RESOURCE_POWER;
        let PowerNum = 2000;
        LoopP: for (let roomName of Memory.PowerSupply) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                continue;
            var terminal_ = thisRoom.terminal;
            var storage_ = thisRoom.storage;
            if (!thisRoom.memory.Misson['Structure'])
                thisRoom.memory.Misson['Structure'] = [];
            for (var tM of thisRoom.memory.Misson['Structure']) {
                if (tM.name == '资源传送' && tM.Data.rType == rType) {
                    continue LoopP; /*存在任务将会直接跳出*/
                }
            }
            /* 计算资源是否满足 */
            if (terminal_.store.getUsedCapacity(rType) + storage_.store.getUsedCapacity(rType) < PowerNum + 5000)
                continue;
            /*提前进行保留运费的计算操作*/
            if (terminal_.store.getUsedCapacity('energy') < 25000)
                continue;
            /*开始具体房间的运算操作*/
            let disRoom = global.PowerDemand.shift();
            var thisTask = thisRoom.public_Send(disRoom, rType, PowerNum);
            if (thisRoom.AddMission(thisTask)) {
                continue;
            }
        }
    }
}
const ResourceDispatchDelayManager = {
    tickEnd: ResourceDispatchTick
};
// 调度信息更新器  ResourceLimit 建议放global里
function ResourceLimitUpdate(thisRoom) {
    global.ResourceLimit[thisRoom.name] = {}; // 初始化
    global.ResourceLimit[thisRoom.name]['energy'] = 350000;
    for (var i of t3)
        global.ResourceLimit[thisRoom.name][i] = 8000; // 所有t3保存8000基础量，以备应急
    for (var b of ['X', 'L', 'Z', 'U', 'K', 'O', 'H', 'ops'])
        global.ResourceLimit[thisRoom.name][b] = 15000; // 所有基础资源保存15000的基础量
    // 监测boost
    if (Object.keys(thisRoom.memory.RoomLabBind).length > 0) {
        for (var l in thisRoom.memory.RoomLabBind) {
            let lab = Game.getObjectById(l);
            if (!lab)
                continue;
            if (!global.ResourceLimit[thisRoom.name][thisRoom.memory.RoomLabBind[l].rType])
                global.ResourceLimit[thisRoom.name][thisRoom.memory.RoomLabBind[l].rType] = 8000;
            else {
                global.ResourceLimit[thisRoom.name][thisRoom.memory.RoomLabBind[l].rType] = global.ResourceLimit[thisRoom.name][thisRoom.memory.RoomLabBind[l].rType] > 8000 ? global.ResourceLimit[thisRoom.name][thisRoom.memory.RoomLabBind[l].rType] : 8000;
            }
        }
    }
    // 监测lab合成
    if (thisRoom.MissionNum('Room', '资源合成') > 0) {
        for (var m of thisRoom.memory.Misson['Room'])
            if (m.name == '资源合成') {
                if (!global.ResourceLimit[thisRoom.name][m.Data.raw1])
                    global.ResourceLimit[thisRoom.name][m.Data.raw1] = m.Data.num;
                else {
                    global.ResourceLimit[thisRoom.name][m.Data.raw1] = global.ResourceLimit[thisRoom.name][m.Data.raw1] > m.Data.num ? global.ResourceLimit[thisRoom.name][m.Data.raw1] : m.Data.num;
                }
                if (!global.ResourceLimit[thisRoom.name][m.Data.raw2])
                    global.ResourceLimit[thisRoom.name][m.Data.raw2] = m.Data.num;
                else {
                    global.ResourceLimit[thisRoom.name][m.Data.raw2] = global.ResourceLimit[thisRoom.name][m.Data.raw2] > m.Data.num ? global.ResourceLimit[thisRoom.name][m.Data.raw2] : m.Data.num;
                }
            }
    }
    // 监测合成规划
    if (Object.keys(thisRoom.memory.ComDispatchData).length > 0) {
        for (var g in thisRoom.memory.ComDispatchData) {
            if (!global.ResourceLimit[thisRoom.name][g])
                global.ResourceLimit[thisRoom.name][g] = thisRoom.memory.ComDispatchData[g].dispatch_num;
            else {
                global.ResourceLimit[thisRoom.name][g] = global.ResourceLimit[thisRoom.name][g] > thisRoom.memory.ComDispatchData[g].dispatch_num ? global.ResourceLimit[thisRoom.name][g] : thisRoom.memory.ComDispatchData[g].dispatch_num;
            }
        }
    }
    // 监测资源卖出
    for (var mtype in thisRoom.memory.market)
        for (var obj of thisRoom.memory.market[mtype]) {
            if (!global.ResourceLimit[thisRoom.name][obj.rType])
                global.ResourceLimit[thisRoom.name][obj.rType] = obj.num;
            else {
                global.ResourceLimit[thisRoom.name][obj.rType] = global.ResourceLimit[thisRoom.name][obj.rType] > obj.num ? global.ResourceLimit[thisRoom.name][obj.rType] : obj.num;
            }
        }
    // 监测工厂相关
    for (var b in thisRoom.memory.productData.baseList) {
        // 基础合成物品也做一定限制
        // global.ResourceLimit[thisRoom.name][b] = Math.ceil(thisRoom.memory.productData.baseList[b].num / 2)
        // 所有基础合成物品的底物也做一定限制
        let highlist = [
            'composite', 'crystal', 'liquid',
            'switch', 'transistor', 'microchip', 'circuit', 'device',
            'phlegm', 'tissue', 'muscle', 'organoid', 'organism',
            'tube', 'fixtures', 'frame', 'hydraulics', 'machine',
            'concentrate', 'extract', 'spirit', 'emanation', 'essence'
        ];
        LoopC: for (let row in COMMODITIES[b].components) {
            if (isInArray(['L', 'G', 'H', 'O', 'Z', 'U', 'Z'], row)) {
                global.ResourceLimit[thisRoom.name][row] = 15000;
            }
            else if (isInArray(highlist, row)) {
                global.ResourceLimit[thisRoom.name][row] = 0;
            }
            else if (row == 'energy')
                continue LoopC;
            else {
                global.ResourceLimit[thisRoom.name][row] = 5000;
                // if (!isInArray(Object.keys(thisRoom.memory.productData.baseList), row)) {
                //     global.ResourceLimit[thisRoom.name][row] = 5000
                // }
                // else continue LoopC
            }
        }
    }
    if (thisRoom.memory.productData.flowCom) {
        let disCom = thisRoom.memory.productData.flowCom;
        if (COMMODITIES[disCom].level >= 4) {
            for (let row in COMMODITIES[thisRoom.memory.productData.flowCom].components) {
                if (!global.ResourceLimit[thisRoom.name][row] || global.ResourceLimit[thisRoom.name][row] < COMMODITIES[thisRoom.memory.productData.flowCom].components[row] * 10)
                    global.ResourceLimit[thisRoom.name][row] = COMMODITIES[thisRoom.memory.productData.flowCom].components[row] * 10;
            }
        }
        else if (COMMODITIES[disCom].level == 3) {
            for (let row in COMMODITIES[thisRoom.memory.productData.flowCom].components) {
                if (!global.ResourceLimit[thisRoom.name][row] || global.ResourceLimit[thisRoom.name][row] < COMMODITIES[thisRoom.memory.productData.flowCom].components[row] * 100)
                    global.ResourceLimit[thisRoom.name][row] = COMMODITIES[thisRoom.memory.productData.flowCom].components[row] * 100;
            }
        }
        else if ((COMMODITIES[disCom].level <= 2)) {
            for (let row in COMMODITIES[thisRoom.memory.productData.flowCom].components) {
                if (!global.ResourceLimit[thisRoom.name][row] || global.ResourceLimit[thisRoom.name][row] < COMMODITIES[thisRoom.memory.productData.flowCom].components[row] * 100)
                    global.ResourceLimit[thisRoom.name][row] = COMMODITIES[thisRoom.memory.productData.flowCom].components[row] * 100;
            }
        }
    }
}
/* --------------隔离区---------------- */
/**
 * 判断某种类型化合物是否还需要调度
 * 1. 如果有mtype，即有该资源的资源购买任务的，则不再需要进行调度
 * 2. 如果有关该房间的资源调度信息过多，则不再需要进行调度
 * 3. 如果已经存在该资源的调度信息了，则不再需要进行调度
 * 4. 如果已经发现传往该房间的资源传送任务了，则不再需要进行调度
*/
function identifyDispatch(thisRoom, resource_, num, disNum = 1, mtype) {
    // 先判断是否已经存在该房间的调度了
    if (mtype) {
        if (Game.market.credits < 1000000)
            return false;
        if (mtype == 'deal' && thisRoom.MissionNum('Structure', '资源购买') > 0)
            return false; // 存在资源购买任务的情况下，不执行资源调度
        if (mtype == 'order' && haveOrder(thisRoom.name, resource_, 'buy'))
            return false; // 如果是下单类型 已经有单就不进行资源调度
    }
    if (DispatchNum(thisRoom.name) >= disNum)
        return false; // 资源调度数量过多则不执行资源调度
    if (checkDispatch(thisRoom.name, resource_))
        return false; // 已经存在调用信息的情况
    if (checkSend(thisRoom.name, resource_))
        return false; // 已经存在其它房间的传送信息的情况
    return true;
}
/**
 * 判断某种类型的函数是否可以调度
 * 1. 如果发现有房间有指定数量的某类型资源，则返回 can 代表可调度
 * 2. 如果没有发现其他房间有送往该房间资源的任务，则返回 running 代表已经有了调度任务了
 * 3. 如果没有发现调度大厅存在该类型的调度任务，则返回 running 代表已经有了调度任务了
 * 4. 以上情况都不符合，返回 no 代表不可调度
*/
function ResourceCanDispatch(thisRoom, resource_, num) {
    if (checkDispatch(thisRoom.name, resource_))
        return "running"; // 有调度信息
    if (checkSend(thisRoom.name, resource_))
        return "running"; // 有传送信息
    for (let i in Memory.RoomControlData) {
        if (i == thisRoom.name)
            continue;
        if (Game.rooms[i] && Game.rooms[i].controller && Game.rooms[i].controller.my) {
            if (!global.Stru[i])
                continue;
            let storage_ = Game.rooms[i].storage;
            if (!storage_)
                continue;
            let limit = global.ResourceLimit[i][resource_] ? global.ResourceLimit[i][resource_] : 0;
            if (storage_.store.getUsedCapacity(resource_) - limit > num)
                return "can";
        }
    }
    return "no"; // 代表房间内没有可调度的资源
}

/* 房间原型拓展   --任务  --基本功能 */
class RoomMissonBehaviourExtension extends Room {
    // 搬运基本任务
    Task_Carry(mission) {
        /* 搬运任务需求 sourcePosX,Y sourceRoom targetPosX,Y targetRoom num  rType  */
        // 没有任务数据 或者数据不全就取消任务
        if (!mission.Data)
            this.DeleteMission(mission.id);
        if (!mission.CreepBind)
            this.DeleteMission(mission.id);
    }
    // 搬运基本任务
    Task_Carryshard(mission) {
        /* 搬运任务需求 sourcePosX,Y sourceRoom targetPosX,Y targetRoom num  rType  */
        // 没有任务数据 或者数据不全就取消任务
        if (mission.CreepBind.truckshard.num > 0) {
            let level = mission.Data.level;
            switch (level) {
                case 'T3':
                    global.MSB[mission.id] = { 'truckshard': GenerateAbility(0, 40, 10, 0, 0, 0, 0, 0) };
                    break;
                case 'T2':
                    global.MSB[mission.id] = { 'truckshard': GenerateAbility(0, 37, 13, 0, 0, 0, 0, 0) };
                    break;
                case 'T1':
                    global.MSB[mission.id] = { 'truckshard': GenerateAbility(0, 32, 16, 0, 0, 0, 0, 0) };
                    break;
                case 'T11':
                    global.MSB[mission.id] = { 'truckshard': GenerateAbility(0, 16, 8, 0, 0, 0, 0, 0) };
                    break;
                case 'T9':
                    global.MSB[mission.id] = { 'truckshard': GenerateAbility(0, 2, 10, 0, 0, 18, 0, 20) };
                    break;
            }
            if ((Game.time - global.Gtime[this.name]) % 8)
                return;
            if (mission.LabBind) {
                if (!this.Check_Lab(mission, 'transport', 'complex')) ;
            }
        }
        if (!mission.Data)
            this.DeleteMission(mission.id);
        if (!mission.CreepBind)
            this.DeleteMission(mission.id);
    }
    Task_Carrygleaner(mission) {
        /* 搬运任务需求 sourcePosX,Y sourceRoom targetPosX,Y targetRoom num  rType  */
        // 没有任务数据 或者数据不全就取消任务
        if (mission.CreepBind.gleaner.num > 0) {
            let level = mission.Data.level;
            switch (level) {
                case 'T3':
                    global.MSB[mission.id] = { 'gleaner': GenerateAbility(0, 40, 10, 0, 0, 0, 0, 0) };
                    break;
                case 'T2':
                    global.MSB[mission.id] = { 'gleaner': GenerateAbility(0, 37, 13, 0, 0, 0, 0, 0) };
                    break;
                case 'T1':
                    global.MSB[mission.id] = { 'gleaner': GenerateAbility(0, 32, 16, 0, 0, 0, 0, 0) };
                    break;
            }
            if ((Game.time - global.Gtime[this.name]) % 8)
                return;
            if (mission.LabBind) {
                if (!this.Check_Lab(mission, 'transport', 'complex')) ;
            }
        }
        if (!mission.Data)
            this.DeleteMission(mission.id);
        if (!mission.CreepBind)
            this.DeleteMission(mission.id);
    }
    Task_Carrymine(mission) {
        // 没有任务数据 或者数据不全就取消任务
        if (!mission.Data)
            this.DeleteMission(mission.id);
        if (!mission.CreepBind)
            this.DeleteMission(mission.id);
        if (mission.CreepBind.steal.num > 0) {
            let level = mission.Data.level;
            switch (level) {
                case 'T1':
                    global.MSB[mission.id] = { 'steal': GenerateAbility(0, 13, 15, 0, 0, 2, 0, 0) };
                    break;
            }
        }
    }
    // 建造任务
    Constru_Build() {
        if ((Game.time - global.Gtime[this.name]) % 51)
            return;
        if (this.controller.level < 5)
            return;
        var myConstrusion = this.find(FIND_MY_CONSTRUCTION_SITES);
        if (myConstrusion.length > 0) {
            /* 添加一个进孵化队列 */
            if (this.memory.state == 'war') {
                this.NumSpawn('build', 1);
            }
            else {
                if (myConstrusion.length > 10) {
                    let _number = Math.ceil(myConstrusion.length / 10);
                    _number = _number > 3 ? 3 : _number;
                    this.NumSpawn('build', _number);
                }
                else {
                    this.NumSpawn('build', 1);
                    // if ((!this.storage || !this.terminal) && this.controller.level >= 8) {
                    //     this.NumSpawn('build', 3)
                    // }
                }
            }
        }
        else {
            if (this.memory.SpawnConfig['build']) {
                delete this.memory.SpawnConfig['build'];
            }
        }
    }
    // 资源link资源转移至centerlink中
    Task_CenterLink() {
        if ((global.Gtime[this.name] - Game.time) % 2)
            return;
        if (!this.memory.StructureIdData.source_links)
            this.memory.StructureIdData.source_links = [];
        if ((!this.memory.StructureIdData.upgrade_link && !this.memory.StructureIdData.center_link) || this.memory.StructureIdData.source_links.length <= 0)
            return;
        // let center_link = Game.getObjectById(this.memory.StructureIdData.center_link) as StructureLink
        // if (!center_link) { delete this.memory.StructureIdData.center_link; return }
        // else { if (center_link.store.getUsedCapacity('energy') > 750) return }
        // this.getStructure(STRUCTURE_LINK)
        // let source_links = this.getStructureData(STRUCTURE_LINK, 'source_links', this.memory.StructureIdData.source_links)
        for (let source_linkid of this.memory.StructureIdData.source_links) {
            let source_link = Game.getObjectById(source_linkid);
            if (!source_link) {
                let index = this.memory.StructureIdData.source_links.indexOf(source_linkid);
                this.memory.StructureIdData.source_links.splice(index, 1);
                return;
            }
            if (source_link.cooldown > 0) {
                continue;
            }
            if (source_link.store.getUsedCapacity('energy') < 700) {
                continue;
            }
            /*检查up_link状态*/
            if (this.memory.StructureIdData.upgrade_link) {
                // let upgrade_link = this.getStructureData(STRUCTURE_LINK, 'upgrade_link', [this.memory.StructureIdData.upgrade_link])[0] as StructureLink
                let upgrade_link = Game.getObjectById(this.memory.StructureIdData.upgrade_link);
                if (upgrade_link && upgrade_link.store.getFreeCapacity('energy') > 600) {
                    var thisTask = this.public_link([source_link.id], upgrade_link.id, 10);
                    this.AddMission(thisTask);
                    return;
                }
            }
            /*检查中央link*/
            if (this.memory.StructureIdData.center_link) {
                // let center_link = this.getStructureData(STRUCTURE_LINK, 'center_link', [this.memory.StructureIdData.center_link])[0] as StructureLink
                let center_link = Game.getObjectById(this.memory.StructureIdData.center_link);
                if (center_link && center_link.store.getFreeCapacity('energy') > 600) {
                    var thisTask = this.public_link([source_link.id], center_link.id, 10);
                    this.AddMission(thisTask);
                }
                /*没有对应任务提前结束*/
                return;
            }
            // if (source_link.store.getUsedCapacity('energy') >= 600 && this.Check_Link(source_link.pos, center_link.pos)) {
            //     var thisTask = this.public_link([source_link.id], center_link.id, 10)
            //     this.AddMission(thisTask)
            //     return
            // }
        }
    }
    // 消费link请求资源 例如升级Link
    Task_ComsumeLink() {
        var _a;
        if (this.controller.level > 4 && this.controller.level < 8) {
            if ((global.Gtime[this.name] - Game.time) % 2)
                return;
        }
        else {
            if ((global.Gtime[this.name] - Game.time) % 7)
                return;
        }
        if (((_a = this.storage) === null || _a === void 0 ? void 0 : _a.store.getUsedCapacity('energy')) < 1000)
            return;
        if (!this.memory.StructureIdData.center_link)
            return;
        // let center_link = this.getStructureData(STRUCTURE_LINK, 'center_link', [this.memory.StructureIdData.center_link])[0] as StructureLink
        let center_link = Game.getObjectById(this.memory.StructureIdData.center_link);
        if (!center_link) {
            delete this.memory.StructureIdData.center_link;
            return;
        }
        if (this.memory.StructureIdData.upgrade_link) {
            // let upgrade_link = this.getStructureData(STRUCTURE_LINK, 'upgrade_link', [this.memory.StructureIdData.upgrade_link])[0] as StructureLink
            let upgrade_link = Game.getObjectById(this.memory.StructureIdData.upgrade_link);
            if (!upgrade_link) {
                delete this.memory.StructureIdData.upgrade_link;
                return;
            }
            if (upgrade_link.store.getUsedCapacity('energy') < 400) {
                var thisTask = this.public_link([center_link.id], upgrade_link.id, 25);
                this.AddMission(thisTask);
                return;
            }
            if (this.memory.StructureIdData.comsume_link.length > 0) {
                // let comsume_link = this.getStructureData(STRUCTURE_LINK, 'comsume_link', [this.memory.StructureIdData.comsume_link]) as StructureLink[]
                for (var i of this.memory.StructureIdData.comsume_link) {
                    let l = Game.getObjectById(i);
                    if (!l) {
                        let index = this.memory.StructureIdData.comsume_link.indexOf(l.id);
                        this.memory.StructureIdData.comsume_link.splice(index, 1);
                        return;
                    }
                    if (l.store.getUsedCapacity('energy') > 500) {
                        var thisTask = this.public_link([center_link.id], l.id, 35);
                        this.AddMission(thisTask);
                        return;
                    }
                }
            }
        }
    }
    // lab合成任务 （底层）
    Task_Compound(misson) {
        if ((Game.time - global.Gtime[this.name]) % 5)
            return;
        if (!this.memory.StructureIdData.labInspect || Object.keys(this.memory.StructureIdData.labInspect).length < 3)
            return;
        let storage_ = this.storage;
        let terminal_ = this.terminal;
        if (misson.Data.num <= -50 || !storage_ || !terminal_) // -50 为误差允许值
         {
            this.DeleteMission(misson.id);
            return;
        }
        let raw1 = Game.getObjectById(this.memory.StructureIdData.labInspect.raw1);
        let raw2 = Game.getObjectById(this.memory.StructureIdData.labInspect.raw2);
        if (!raw1 || !raw2) {
            this.DeleteMission(misson.id);
            return;
        }
        if (raw1.mineralType && raw1.mineralType != misson.Data.raw1 && this.Check_Carry('transport', raw1.pos, storage_.pos, raw1.mineralType)) {
            var thisTask = this.public_Carry({ 'transport': { num: 1, bind: [] } }, 30, this.name, raw1.pos.x, raw1.pos.y, this.name, storage_.pos.x, storage_.pos.y, raw1.mineralType, raw1.store.getUsedCapacity(raw1.mineralType));
            this.AddMission(thisTask);
            return;
        }
        if (raw2.mineralType && raw2.mineralType != misson.Data.raw2 && this.Check_Carry('transport', raw2.pos, storage_.pos, raw2.mineralType)) {
            var thisTask = this.public_Carry({ 'transport': { num: 1, bind: [] } }, 30, this.name, raw2.pos.x, raw2.pos.y, this.name, storage_.pos.x, storage_.pos.y, raw2.mineralType, raw2.store.getUsedCapacity(raw2.mineralType));
            this.AddMission(thisTask);
            return;
        }
        let re = false;
        let comData = [];
        for (let bindLab in misson.LabBind) {
            if (!isInArray([misson.Data.raw1, misson.Data.raw2], misson.LabBind[bindLab]))
                comData.push(bindLab);
        }
        for (let i of comData) {
            var thisLab = Game.getObjectById(i);
            if (!thisLab) {
                let index = this.memory.StructureIdData.labs.indexOf(i);
                this.memory.StructureIdData.labs.splice(index, 1);
                continue;
            }
            if (thisLab.mineralType && thisLab.mineralType != misson.LabBind[i] && this.Check_Carry('transport', thisLab.pos, storage_.pos, thisLab.mineralType)) {
                // 说明该lab内有异物
                var thisTask = this.public_Carry({ 'transport': { num: 1, bind: [] } }, 30, this.name, thisLab.pos.x, thisLab.pos.y, this.name, storage_.pos.x, storage_.pos.y, thisLab.mineralType, thisLab.store.getUsedCapacity(thisLab.mineralType));
                this.AddMission(thisTask);
                return;
            }
            if (thisLab.cooldown)
                continue;
            let comNum = 5;
            if (thisLab.effects && thisLab.effects.length > 0) {
                for (var effect_ of thisLab.effects) {
                    if (effect_.effect == PWR_OPERATE_LAB) {
                        var level = effect_.level;
                        comNum += level * 2;
                    }
                }
            }
            if (thisLab.runReaction(raw1, raw2) == OK) {
                misson.Data.num -= comNum;
            }
            if (thisLab.mineralType && thisLab.store.getUsedCapacity(thisLab.mineralType) >= 2500 && this.RoleMissionNum('transport', '物流运输') < 2 && this.Check_Carry('transport', thisLab.pos, storage_.pos, thisLab.mineralType)) {
                /* 资源快满了就要搬运 */
                re = true;
                var thisTask = this.public_Carry({ 'transport': { num: 1, bind: [] } }, 30, this.name, thisLab.pos.x, thisLab.pos.y, this.name, storage_.pos.x, storage_.pos.y, thisLab.mineralType, thisLab.store.getUsedCapacity(thisLab.mineralType));
                this.AddMission(thisTask);
                continue;
            }
        }
        if (re)
            return;
        /* 源lab缺资源就运 */
        if (storage_.store.getUsedCapacity(misson.Data.raw1) > 0)
            if (raw1.store.getUsedCapacity(misson.Data.raw1) < 500 && this.RoleMissionNum('transport', '物流运输') < 2 && this.Check_Carry('transport', storage_.pos, raw1.pos, misson.Data.raw1)) {
                var thisTask = this.public_Carry({ 'transport': { num: 1, bind: [] } }, 30, this.name, storage_.pos.x, storage_.pos.y, this.name, raw1.pos.x, raw1.pos.y, misson.Data.raw1, storage_.store.getUsedCapacity(misson.Data.raw1) >= 1000 ? 1000 : storage_.store.getUsedCapacity(misson.Data.raw1));
                this.AddMission(thisTask);
            }
        if (storage_.store.getUsedCapacity(misson.Data.raw2) > 0)
            if (raw2.store.getUsedCapacity(misson.Data.raw2) < 500 && this.RoleMissionNum('transport', '物流运输') < 2 && this.Check_Carry('transport', storage_.pos, raw2.pos, misson.Data.raw2)) {
                var thisTask = this.public_Carry({ 'transport': { num: 1, bind: [] } }, 30, this.name, storage_.pos.x, storage_.pos.y, this.name, raw2.pos.x, raw2.pos.y, misson.Data.raw2, storage_.store.getUsedCapacity(misson.Data.raw2) >= 1000 ? 1000 : storage_.store.getUsedCapacity(misson.Data.raw2));
                this.AddMission(thisTask);
            }
        /* 资源调度 */
        var needResource = [misson.Data.raw1, misson.Data.raw2];
        if (this.MissionNum('Structure', '资源购买') > 0)
            return; // 存在资源购买任务的情况下，不执行资源调度
        if (DispatchNum(this.name) >= 2)
            return; // 资源调度数量过多则不执行资源调度
        let buy = false;
        if (!Game.cpu.generatePixel) {
            buy = true;
        }
        for (var resource_ of needResource) {
            // 原矿 资源调用
            if (storage_.store.getUsedCapacity(resource_) + terminal_.store.getUsedCapacity(resource_) < 10000 && isInArray(['H', 'O', 'K', 'L', 'X', 'U', 'Z'], resource_)) {
                if (checkDispatch(this.name, resource_))
                    continue; // 已经存在调用信息的情况
                if (checkSend(this.name, resource_))
                    continue; // 已经存在其它房间的传送信息的情况
                console.log(Colorful$1(`[资源调度]<lab com> 房间${this.name}没有足够的资源[${resource_}],将执行资源调度!`, 'yellow'));
                let dispatchTask = {
                    sourceRoom: this.name,
                    rType: resource_,
                    num: 10000,
                    delayTick: 200,
                    conditionTick: 35,
                    buy: buy,
                    mtype: 'deal'
                };
                Memory.ResourceDispatchData.push(dispatchTask);
                return;
            }
            // 其他中间物 资源调用
            else if (storage_.store.getUsedCapacity(resource_) + terminal_.store.getUsedCapacity(resource_) < 1000 && !isInArray(['H', 'O', 'K', 'L', 'X', 'U', 'Z'], resource_)) {
                if (checkDispatch(this.name, resource_))
                    continue; // 已经存在调用信息的情况
                if (checkSend(this.name, resource_))
                    continue; // 已经存在其它房间的传送信息的情况
                console.log(Colorful$1(`[资源调度]<lab com> 房间${this.name}没有足够的资源[${resource_}],将执行资源调度!`, 'yellow'));
                let dispatchTask = {
                    sourceRoom: this.name,
                    rType: resource_,
                    num: 2000,
                    delayTick: 100,
                    conditionTick: 25,
                    buy: buy,
                    mtype: 'deal'
                };
                Memory.ResourceDispatchData.push(dispatchTask);
                return;
            }
        }
    }
    /*Factory自动压缩和解压操作基于房间的设定*/
    Task_FactoryAutomatic() {
        if ((Game.time - global.Gtime[this.name]) % 35)
            return;
        /*必须storage terminal 同时存在*/
        if (!this.storage)
            return;
        if (!this.terminal)
            return;
        /*解压缩设定*/
        if (this.memory.DynamicConfig.Dynamicfactoryuncondense) {
            if (!_.isEmpty(this.memory.productData.unzip))
                return; /*已有解压任务的情况下不做处理*/
            /*检索以下特定资源*/
            for (let bar in unzipMap) {
                let resource = unzipMap[bar];
                let resource_store = this.storage.store.getUsedCapacity(resource) + this.terminal.store.getUsedCapacity(resource);
                let bar_store = this.storage.store.getUsedCapacity(bar) + this.terminal.store.getUsedCapacity(bar);
                if (bar_store <= 1000)
                    continue;
                if (bar_store > 0 && resource_store < (resource == RESOURCE_ENERGY ? 300000 : 20000)) {
                    let un_number = bar_store > 1000 ? 1000 : bar_store;
                    this.memory.productData.unzip[bar] = { num: Math.trunc(un_number / 100) * 100 };
                    return;
                }
            }
        }
        if (this.memory.DynamicConfig.Dynamicfactorycondense) ;
    }
    // Lab自动合成 根据预想设定在目标房间中保持固定数量的对应资源
    Task_LabAutomatic() {
        if ((Game.time - global.Gtime[this.name]) % 50)
            return;
        if (!this.memory.Labautomatic.automaticState)
            return;
        if (this.memory.Labautomatic.automaticData.length < 1) {
            this.memory.Labautomatic.automaticState = false;
            return;
        }
        /*进行自动合成操作*/
        var storage_ = this.storage;
        if (!storage_)
            return;
        var terminal_ = this.terminal;
        if (!terminal_)
            return;
        let MissionName = this.MissionName('Room', '资源合成');
        if (MissionName) {
            /*有任务的情况下检查是否满足继续合成的要求*/
            /*进行任务规则匹配操作-首先获取任务目标信息*/
            let Type = null;
            let RawState = false;
            for (let Message in MissionName.LabMessage) {
                switch (MissionName.LabMessage[Message]) {
                    case 'com':
                        Type = Message;
                        break;
                }
            }
            if (!Type) { /*获取合成产物失败,取消任务同时终止*/
                this.DeleteMission(MissionName.id);
                return;
            }
            /*检查是否完整占用任务*/
            if (Object.keys(this.memory.RoomLabBind).length < 10) {
                this.DeleteMission(MissionName.id);
                var thisTask = this.public_Compound(MissionName.Data.num, Type);
                if (thisTask) {
                    /*进行任务发布*/
                    this.AddMission(thisTask);
                }
                return;
            }
            let automaticData = null;
            for (let i_Data of this.memory.Labautomatic.automaticData) {
                if (i_Data.Type == Type) {
                    automaticData = i_Data;
                }
            }
            if (!automaticData) { /*获取自动规划失败,取消任务同时终止*/
                this.DeleteMission(MissionName.id);
                return;
            }
            /*检查仓库 以及终端的库存信息*/
            let use_number = storage_.store.getUsedCapacity(Type) + terminal_.store.getUsedCapacity(Type);
            if (use_number < automaticData.Num) {
                /*继续进行Lab数量的检查*/
                for (let lab_id in MissionName.LabBind) {
                    var lab_data = Game.getObjectById(lab_id);
                    if (!lab_data)
                        continue;
                    if (MissionName.LabBind[lab_id] == Type) {
                        use_number += lab_data.store.getUsedCapacity(Type);
                    }
                    else {
                        /*原材料的容器*/
                        if (lab_data.store.getUsedCapacity(Type) < 100) {
                            /*原料容器资源过少-检查仓库的资源情况*/
                            RawState = true;
                        }
                    }
                }
            }
            /*如果超出数量则自动暂停*/
            if (use_number >= automaticData.Num) {
                // console.log(this.name, '自动规划', '已满足合成要求')
                this.DeleteMission(MissionName.id);
                return;
            }
            /**
             * 如果尚未完成自动合成操作那么检查备用材料是否足够，以及是否存在其他房间调度的可能
             * 会跨房检索两种资源信息
             * */
            if (!RawState) {
                return;
            }
            if (!LabMap[Type]) {
                /*无法检测合成配方-自动终止*/
                // console.log(this.name, '自动规划', '无法检测合成配方-自动终止')
                this.DeleteMission(MissionName.id);
                return;
            }
            var raw1str = LabMap[Type].raw1;
            var raw2str = LabMap[Type].raw2;
            /*检查其他库存资源的情况*/
            if (!this.Check_ResourceType(raw1str, 1000) || !this.Check_ResourceType(raw2str, 1000)) {
                /*已有的资源数量不足终止任务*/
                // console.log(this.name, '自动规划', '任务不足自动取消')
                this.DeleteMission(MissionName.id);
                return;
            }
            // console.log(this.name, '自动规划', '检测完成')
        }
        else {
            /*没有任务的情况下进行任务规划*/
            // console.log(this.name, '自动规划')
            /*先对Lab进行一次检查*/
            let LabTypeList = {};
            for (let lab_id of this.memory.StructureIdData.labs) {
                let lab_data = Game.getObjectById(lab_id);
                if (!lab_data)
                    continue;
                if (!lab_data.mineralType)
                    continue;
                if (!LabTypeList[lab_data.mineralType]) {
                    LabTypeList[lab_data.mineralType] = 0;
                }
                LabTypeList[lab_data.mineralType] += lab_data.store.getUsedCapacity(lab_data.mineralType);
            }
            for (let i in this.memory.Labautomatic.automaticData) {
                let _Data = this.memory.Labautomatic.automaticData[i];
                // console.log(this.name, '自动规划', _Data.Type)
                /*检查资源是否已经满足要求*/
                let use_number = storage_.store.getUsedCapacity(_Data.Type) + terminal_.store.getUsedCapacity(_Data.Type);
                let defect_numer = _Data.Num - use_number;
                if (defect_numer >= 5000) {
                    /*检查Lab的信息*/
                    if (LabTypeList[_Data.Type]) {
                        defect_numer -= LabTypeList[_Data.Type];
                        if (defect_numer <= 0)
                            continue;
                    }
                    /**
                     * 当库存缺损超过5000的情况下执行合成操作
                     * 检查合成所需材料的信息
                     * */
                    if (!LabMap[_Data.Type]) {
                        continue;
                    }
                    var raw1str = LabMap[_Data.Type].raw1;
                    var raw2str = LabMap[_Data.Type].raw2;
                    if (this.Check_ResourceType(raw1str, 5000) && this.Check_ResourceType(raw2str, 5000)) {
                        /*有足够的资源-执行合成操作*/
                        var thisTask = this.public_Compound(defect_numer, _Data.Type);
                        if (thisTask) {
                            /*进行任务发布*/
                            if (this.AddMission(thisTask)) {
                                /*任务发布成功终止筛选*/
                                return;
                            }
                        }
                    }
                }
            }
        }
    }
    // 合成规划     (中层)    目标化合物 --> 安排一系列合成
    Task_CompoundDispatch() {
        if ((Game.time - global.Gtime[this.name]) % 50)
            return;
        if (this.memory.Labautomatic.automaticState)
            return;
        if (this.memory.switch.AutoDefend)
            return;
        if (this.RoleMissionNum('transport', '物流运输') > 0)
            return;
        if (Object.keys(this.memory.ComDispatchData).length <= 0)
            return; //  没有合成规划情况
        if (this.MissionNum('Room', '资源合成') > 0)
            return; // 有合成任务情况
        var storage_ = this.storage;
        if (!storage_)
            return;
        var terminal_ = this.terminal;
        if (!terminal_)
            return;
        /* 没有房间合成实验室数据，不进行合成 */
        if (!this.memory.StructureIdData.labInspect.raw1) {
            console.log(`房间${this.name}不存在合成实验室数据！`);
            return;
        }
        // /* 查看合成实验室的被占用状态 */
        // if (this.memory.RoomLabBind[this.memory.StructureIdData.labInspect.raw1] || this.memory.RoomLabBind[this.memory.StructureIdData.labInspect.raw2]) { console.log(`房间${this.name}的源lab被占用!`); return }
        // var comLabs = []
        // for (var otLab of this.memory.StructureIdData.labInspect.com) {
        //     if (!this.memory.RoomLabBind[otLab]) comLabs.push(otLab)
        // }
        // if (comLabs.length <= 0) { console.log(`房间${this.name}的合成lab全被占用!`); return }
        // /* 确认所有目标lab里都没有其他资源 */
        // for (var i of this.memory.StructureIdData.labs) {
        //     var thisLab = Game.getObjectById(i) as StructureLab
        //     if (!thisLab) continue
        //     if (thisLab.mineralType && !this.memory.RoomLabBind[i]) return
        // }
        /**
         * 正式开始合成规划
         *  */
        var data = this.memory.ComDispatchData;
        LoopA: for (var disType in data) {
            let storeNum = storage_.store.getUsedCapacity(disType);
            let dispatchNum = this.memory.ComDispatchData[disType].dispatch_num;
            // 不是最终目标资源的情况下
            if (Object.keys(data)[Object.keys(data).length - 1] != disType)
                if (storeNum + 50 < dispatchNum) // +50 是误差容许
                 {
                    let diff = dispatchNum - storeNum;
                    /* 先判定一下是否已经覆盖，如果已经覆盖就不合成 例如：ZK 和 G的关系，只要G数量满足了就不考虑 */
                    var mapResource = resourceMap(disType, Object.keys(data)[Object.keys(data).length - 1]);
                    if (mapResource.length > 0) {
                        for (var mR of mapResource) {
                            if (storage_.store.getUsedCapacity(mR) >= data[disType].dispatch_num)
                                continue LoopA;
                        }
                    }
                    // 先判断能不能调度，如果能调度，就暂时 return
                    let identify = ResourceCanDispatch(this, disType, dispatchNum - storeNum);
                    if (identify == 'can') {
                        console.log(`[dispatch]<lab> 房间${this.name}将进行资源为${disType}的资源调度!`);
                        let dispatchTask = {
                            sourceRoom: this.name,
                            rType: disType,
                            num: dispatchNum - storeNum,
                            delayTick: 220,
                            conditionTick: 35,
                            buy: false,
                        };
                        Memory.ResourceDispatchData.push(dispatchTask);
                    }
                    else if (identify == 'running')
                        return;
                    // 如果terminal存在该类型资源，就暂时return
                    if (terminal_.store.getUsedCapacity(disType) > (this.memory.TerminalData[disType] ? this.memory.TerminalData[disType].num : 0))
                        return;
                    // 如果存在manage搬运任务 就 return
                    if (!this.Check_Carry("manage", terminal_.pos, storage_.pos, disType))
                        return;
                    // 下达合成命令
                    var thisTask = this.public_Compound(diff, disType);
                    if (this.AddMission(thisTask)) {
                        data[disType].ok = true;
                    }
                    return;
                }
            // 是最终目标资源的情况下
            if (Object.keys(data)[Object.keys(data).length - 1] == disType) {
                // 下达合成命令
                var thisTask = this.public_Compound(data[disType].dispatch_num, disType);
                if (this.AddMission(thisTask))
                    this.memory.ComDispatchData = {};
                return;
            }
        }
    }
    /* 烧Power发布函数任务 */
    Task_montitorPower() {
        if (Game.cpu.bucket < 6000 && Memory.StopPixel)
            return; /*CPU不足情况下暂停*/
        if ((Game.time - global.Gtime[this.name]) % 13)
            return;
        if (this.controller.level < 8)
            return;
        if (!this.memory.switch.StartPower && !Memory.Systemswitch.SystemEconomy)
            return;
        let storage_ = this.storage;
        //  powerspawn_ = global.Stru[this.name]['powerspawn'] as StructurePowerSpawn
        if (!storage_ || !this.terminal)
            return;
        let storage_number = storage_.store.getUsedCapacity('power');
        if (storage_number + this.terminal.store.getUsedCapacity('power') <= 5000) {
            // console.log(this.name, '等待帕瓦供应')
            /*将补充信息添加到待处理的列表中*/
            global.PowerDemand = _.uniq([...global.PowerDemand, this.name]);
        }
        else {
            if (global.PowerDemand.length > 0) {
                global.PowerDemand = _.difference(global.PowerDemand, this.name);
            }
        }
        // 有任务了就不发布烧帕瓦的任务
        if (this.MissionNum('Room', 'power升级') > 0)
            return;
        if (!Memory.Systemswitch.SystemStopPower) {
            /* 检测类型*/
            let SavePower = this.memory.switch.SavePower;
            if (!SavePower && Memory.Systemswitch.SystemEconomy && !this.memory.switch.StartPower) {
                SavePower = true;
            }
            // SavePower 是节省能量的一种"熔断"机制 防止烧power致死
            if (storage_.store.getUsedCapacity('energy') > (SavePower ? 250000 : 150000) && storage_number > 100) {
                /* 发布烧power任务 */
                var thisTask = {
                    name: 'power升级',
                    delayTick: 200,
                    range: 'Room',
                    state: 1
                };
                this.AddMission(thisTask);
            }
        }
    }
    /* 烧Power执行函数 */
    Task_ProcessPower(misson) {
        if (Game.cpu.bucket < 6000 && Memory.StopPixel)
            return; /*CPU不足情况下暂停*/
        if (!Game.rooms[this.name].memory.StructureIdData.PowerSpawnID)
            return;
        let powerspawn_ = Game.getObjectById(Game.rooms[this.name].memory.StructureIdData.PowerSpawnID);
        if (!powerspawn_) {
            delete Game.rooms[this.name].memory.StructureIdData.PowerSpawnID;
            return;
        }
        let storage_ = this.storage;
        // let powerspawn_ = Game.rooms[this.name].GetStructData('powerspawn') as StructurePowerSpawn
        let terminal_ = this.terminal;
        if (!storage_ || !terminal_)
            return;
        if (misson.state == 1) {
            if (this.RoleMissionNum('manage', '物流运输') > 0)
                return;
            if (powerspawn_.store.getFreeCapacity('energy') > 0) {
                var carryTask = this.public_Carry({ 'manage': { num: 1, bind: [] } }, 10, this.name, storage_.pos.x, storage_.pos.y, this.name, powerspawn_.pos.x, powerspawn_.pos.y, 'energy', powerspawn_.store.getFreeCapacity('energy'));
                this.AddMission(carryTask);
                return;
            }
            if (powerspawn_.store.getFreeCapacity('power') > 0) {
                var carryTask = this.public_Carry({ 'manage': { num: 1, bind: [] } }, 10, this.name, storage_.pos.x, storage_.pos.y, this.name, powerspawn_.pos.x, powerspawn_.pos.y, 'power', powerspawn_.store.getFreeCapacity('power'));
                this.AddMission(carryTask);
                return;
            }
            misson.state = 2;
        }
        else if (misson.state == 2) {
            let result = powerspawn_.processPower();
            if (result != OK) {
                this.DeleteMission(misson.id);
            }
        }
    }
    /*基础资源保持功能,当资源数量不满足基础要求的情况下将会执行资源的采购操作*/
    Auto_Basicmarket() {
        var _a;
        if (Game.cpu.bucket < 5000 && Memory.StopPixel)
            return; /*CPU不足情况下暂停*/
        if ((Game.time - global.Gtime[this.name]) % 88)
            return;
        if (Object.keys(this.memory.AutoBasicmarket).length < 1)
            return; /*没有保持内容的房间将不会进行保持操作*/
        if (((_a = this.controller) === null || _a === void 0 ? void 0 : _a.level) < 6)
            return; /*6级以下控制器不执行当前操作内容*/
        if (!this.storage || !this.terminal)
            return; /*没有仓库或者终端将不会执行当前操作*/
        /*把已有的order订单进行格式化*/
        var _order_list = [];
        if (this.memory.market.order.length > 0) {
            for (var _order of this.memory.market.order) {
                if (_order.autoBasic)
                    _order_list.push(_order.rType);
            }
        }
        /*检查当前房间需要保持的资源信息(包括类型、数量、最高价格)*/
        let AutoBasicmarket = this.memory.AutoBasicmarket;
        for (let res in AutoBasicmarket) {
            /*检查仓库对应的资源数量*/
            let resdata = AutoBasicmarket[res];
            let Resource = this.storage.store.getUsedCapacity(res) + this.terminal.store.getUsedCapacity(res);
            if (Resource >= Math.round(resdata.number * 0.5))
                continue;
            if (isInArray(_order_list, res))
                continue;
            /*检查缺少的数量*/
            let _add_number = resdata.number - Resource;
            let unit = 3000;
            if (unit > _add_number)
                unit = _add_number;
            /*获取一个平均的价格信息*/
            let price = 0;
            var avePriceprice = avePrice(res, 1);
            if (avePriceprice)
                price = avePriceprice;
            let _addbR = {
                rType: res,
                num: _add_number,
                unit: unit,
                price: price,
                mTyep: 'buy',
                retain: true,
                autotrade: true,
                autoBasic: true,
                autoatype: 1,
                autofilteraisle: true
            };
            /*如果有预设的最高价则进行加载操作*/
            if (resdata.pricemax)
                _addbR.automax = resdata.pricemax;
            this.memory.market.order.push(_addbR);
            console.log(Colorful$1(`房间${this.name}下达资源平衡rType:${res},price:${price},num:${_add_number},unit:${unit}!`, '#0099FF', true));
            return;
        }
    }
}

/* 房间原型拓展   --任务  --运输工任务 */
class RoomMissonTransportExtension extends Room {
    // 虫卵填充任务
    Spawn_Feed() {
        /* 每11 tick 观察一次 */
        if ((Game.time - global.Gtime[this.name]) % 11)
            return;
        if (!this.storage && !this.terminal)
            return;
        if (this.energyAvailable >= this.energyCapacityAvailable)
            return;
        if (this.RoleMissionNum('transport', '虫卵填充') < 1) {
            /*存储填充对象的信息*/
            // this.memory.Transport['SpawnFeed'] = []
            // for (let id in emptyExtensions) {
            //     this.memory.Transport['SpawnFeed'].push(emptyExtensions[id].id)
            // }
            /* 满足条件则触发虫卵填充任务 */
            var thisMisson = {
                name: "虫卵填充",
                range: "Creep",
                delayTick: 50,
                cooldownTick: 4,
                CreepBind: { 'transport': { num: 2, bind: [] } },
                Data: {}
            };
            this.AddMission(thisMisson);
        }
    }
    // 资源回收任务
    Resource_Recycle() {
        if ((Game.time - global.Gtime[this.name]) % 17)
            return;
        if (!this.storage)
            return;
        let tombstone = this.find(FIND_TOMBSTONES, {
            filter: (tomb) => {
                return (tomb.store.getUsedCapacity('energy') >= tomb.pos.getRangeTo(this.storage) * 25) ||
                    (tomb.store.getUsedCapacity() > tomb.store.getUsedCapacity('energy'));
            }
        });
        if (tombstone.length > 0) {
            /* 下达搬运任务搬运 */
            if (this.RoleMissionNum('transport', '物流运输') > 3)
                return;
            if (this.storage) {
                if (!this.Check_Carry('transport', this.storage.pos, tombstone[0].pos))
                    return;
                let thisTask = this.public_Carry({ 'transport': { num: 1, bind: [] } }, 35, this.name, tombstone[0].pos.x, tombstone[0].pos.y, this.name, this.storage.pos.x, this.storage.pos.y);
                this.AddMission(thisTask);
                return;
            }
        }
        else {
            let droppedResource = this.find(FIND_DROPPED_RESOURCES, {
                filter: (dropped) => {
                    return (dropped.amount >= dropped.pos.getRangeTo(this.storage) * 25) || (dropped.resourceType != 'energy');
                }
            });
            if (droppedResource.length > 0) {
                /* 下达搬运任务搬运 */
                if (this.RoleMissionNum('transport', '物流运输') > 3)
                    return;
                if (this.storage) {
                    if (!this.Check_Carry('transport', this.storage.pos, droppedResource[0].pos))
                        return;
                    let thisTask = this.public_Carry({ 'transport': { num: 1, bind: [] } }, 35, this.name, droppedResource[0].pos.x, droppedResource[0].pos.y, this.name, this.storage.pos.x, this.storage.pos.y);
                    this.AddMission(thisTask);
                    return;
                }
            }
        }
    }
    // 防御塔填充任务
    Tower_Feed() {
        var _a;
        if (Game.shard.name == 'shard3') {
            if ((Game.time - global.Gtime[this.name]) % 17)
                return;
        }
        else {
            if ((Game.time - global.Gtime[this.name]) % 5)
                return;
        }
        if (!this.storage && !this.terminal)
            return;
        if (!((_a = this.memory.StructureIdData) === null || _a === void 0 ? void 0 : _a.AtowerID))
            return;
        for (let towerid of this.memory.StructureIdData.AtowerID) {
            let tower = Game.getObjectById(towerid);
            if (!tower) {
                this.memory.StructureIdData.AtowerID = _.difference(this.memory.StructureIdData.AtowerID, [towerid]);
                continue;
            }
            if (tower.store.getUsedCapacity('energy') < 500) {
                /* 下达搬运任务搬运 */
                if (this.RoleMissionNum('transport', '物流运输') > 3)
                    continue;
                if (this.storage) {
                    if (!this.Check_Carry('transport', this.storage.pos, tower.pos, 'energy'))
                        continue;
                    if (this.storage.store.getUsedCapacity('energy') >= 1000) {
                        let thisTask = this.public_Carry({ 'transport': { num: 2, bind: [] } }, 35, this.name, this.storage.pos.x, this.storage.pos.y, this.name, tower.pos.x, tower.pos.y, 'energy', 1000 - tower.store.getUsedCapacity('energy'));
                        this.AddMission(thisTask);
                        return;
                    }
                }
                if (this.controller.level < 6)
                    return;
                if (this.terminal) {
                    if (!this.Check_Carry('transport', this.terminal.pos, tower.pos, 'energy'))
                        continue;
                    if (this.terminal.store.getUsedCapacity('energy') >= 1000) {
                        let thisTask = this.public_Carry({ 'transport': { num: 2, bind: [] } }, 35, this.name, this.terminal.pos.x, this.terminal.pos.y, this.name, tower.pos.x, tower.pos.y, 'energy', 1000 - tower.store.getUsedCapacity('energy'));
                        this.AddMission(thisTask);
                    }
                }
            }
        }
    }
    // 实验室能量填充任务 [包含多余物回收]
    Lab_Feed() {
        var _a;
        if ((global.Gtime[this.name] - Game.time) % 13)
            return;
        if (!this.storage && !this.terminal)
            return;
        if (!((_a = this.memory.StructureIdData) === null || _a === void 0 ? void 0 : _a.labs))
            return;
        let missionNum = this.RoleMissionNum('transport', '物流运输');
        if (missionNum > 3)
            return;
        for (var thisLabid of this.memory.StructureIdData.labs) {
            let thisLab = Game.getObjectById(thisLabid);
            if (!thisLab) {
                this.memory.StructureIdData.labs = _.difference(this.memory.StructureIdData.labs, [thisLabid]);
                continue;
            }
            if (thisLab.store.getUsedCapacity('energy') <= 1800) {
                /* 下布搬运命令 */
                if (this.storage) {
                    if (this.storage.store.getUsedCapacity('energy') > 2000) {
                        if (!this.Check_Carry('transport', this.storage.pos, thisLab.pos, 'energy'))
                            return;
                        var thisTask = this.public_Carry({ 'transport': { num: 1, bind: [] } }, 25, this.name, this.storage.pos.x, this.storage.pos.y, this.name, thisLab.pos.x, thisLab.pos.y, 'energy', 2000 - thisLab.store.getUsedCapacity('energy'));
                        this.AddMission(thisTask);
                        return;
                    }
                }
                if (this.controller.level < 6)
                    return;
                if (this.terminal) {
                    if (this.terminal.store.getUsedCapacity('energy') > 2000) {
                        if (!this.Check_Carry('transport', this.terminal.pos, thisLab.pos, 'energy'))
                            return;
                        var thisTask = this.public_Carry({ 'transport': { num: 1, bind: [] } }, 25, this.name, this.terminal.pos.x, this.terminal.pos.y, this.name, thisLab.pos.x, thisLab.pos.y, 'energy', 2000 - thisLab.store.getUsedCapacity('energy'));
                        this.AddMission(thisTask);
                        return;
                    }
                }
                return;
            }
            /* 如果该实验室不在绑定状态却有多余资源 */
            if (!this.memory.RoomLabBind[thisLab.id] && thisLab.mineralType) {
                if (!this.storage)
                    return;
                var thisTask = this.public_Carry({ 'transport': { num: 1, bind: [] } }, 25, this.name, thisLab.pos.x, thisLab.pos.y, this.name, this.storage.pos.x, this.storage.pos.y, thisLab.mineralType, thisLab.store.getUsedCapacity(thisLab.mineralType));
                this.AddMission(thisTask);
                return;
            }
        }
    }
    // 核弹填充任务
    Nuker_Feed() {
        if ((Game.time - global.Gtime[this.name]) % 103)
            return;
        if (this.memory.switch.StopFillNuker)
            return;
        if (!this.memory.StructureIdData.NukerID || !this.storage)
            return;
        if (this.RoleMissionNum('transport', '物流运输') >= 1)
            return;
        const nuker = Game.getObjectById(this.memory.StructureIdData.NukerID);
        const storage_ = this.storage;
        const terminal_ = this.terminal;
        if (!nuker) {
            delete this.memory.StructureIdData.NukerID;
            return;
        }
        if (!storage_ || !terminal_) {
            return;
        }
        const storedGhodium = storage_.store.getUsedCapacity('G') + terminal_.store.getUsedCapacity('G');
        if (nuker.store.getUsedCapacity('G') < 5000 && (storedGhodium + nuker.store.getUsedCapacity('G')) >= 5000) {
            var thisTask = this.public_Carry({ 'transport': { num: 1, bind: [] } }, 40, this.name, storage_.pos.x, storage_.pos.y, this.name, nuker.pos.x, nuker.pos.y, 'G', 5000 - nuker.store.getUsedCapacity('G'));
            this.AddMission(thisTask);
            return;
        }
        else {
            if (nuker.store.getUsedCapacity('G') < 5000) {
                let ghodiumRequired = 5000 - storedGhodium;
                if (ghodiumRequired > 0) {
                    let _DispatchNum = DispatchNum(this.name);
                    /* 资源调度 */
                    if (_DispatchNum <= 0 && this.MissionNum('Structure', '资源购买') <= 0 && !checkSend(this.name, 'G')) {
                        console.log(Colorful$1(`[资源调度] 房间${this.name}没有足够的资源[G],将执行资源调度!`, 'yellow'));
                        let dispatchTask = {
                            sourceRoom: this.name,
                            rType: 'G',
                            num: ghodiumRequired,
                            delayTick: 200,
                            conditionTick: 20,
                            buy: true,
                            mtype: 'deal'
                        };
                        Memory.ResourceDispatchData.push(dispatchTask);
                    }
                }
            }
        }
        if (nuker.store.getUsedCapacity('energy') < 300000 && storage_.store.getUsedCapacity('energy') > 200000) {
            var thisTask = this.public_Carry({ 'transport': { num: 1, bind: [] } }, 40, this.name, storage_.pos.x, storage_.pos.y, this.name, nuker.pos.x, nuker.pos.y, 'energy', Math.min(300000 - nuker.store.getUsedCapacity('energy'), storage_.store.getUsedCapacity('energy') - 200000));
            this.AddMission(thisTask);
            return;
        }
    }
}

/* 房间原型拓展   --行为  --维护任务 */
class RoomMissonVindicateExtension extends Room {
    Task_Repair(mission) {
        /* 根据level决定任务爬虫体型 */
        if (mission.CreepBind.repair.num > 0) {
            let level = mission.Data.level;
            if (!level)
                mission.Data.level = 'T0';
            if (level == 'T3') {
                global.MSB[mission.id] = { 'repair': GenerateAbility(30, 10, 10, 0, 0, 0, 0, 0) };
            }
            else if (level == 'T2') {
                global.MSB[mission.id] = { 'repair': GenerateAbility(6, 4, 10, 0, 0, 0, 0, 0) };
            }
            else if (level == 'T1') {
                global.MSB[mission.id] = { 'repair': GenerateAbility(20, 10, 15, 0, 0, 0, 0, 0) };
            }
            else ;
            if ((Game.time - global.Gtime[this.name]) % 8)
                return;
            if (mission.LabBind) {
                if (!this.Check_Lab(mission, 'transport', 'complex')) ;
            }
        }
        /*任务检测工具*/
        if ((Game.time - global.Gtime[this.name]) % 50)
            return;
        if (mission.Data.maxhit && mission.CreepBind.repair.bind.length < 1) {
            /*存在最大生命判定 以及 爬已经全部死完*/
            var leastRam = this.getListHitsleast([STRUCTURE_RAMPART, STRUCTURE_WALL], 3);
            if (leastRam) {
                if (leastRam.hits > mission.Data.maxhit) {
                    /*完成刷墙任务*/
                    if (!mission.Data.retain) {
                        this.DeleteMission(mission.id);
                    }
                    else {
                        mission.Data.hangstate = true;
                        if (Object.keys(mission.LabBind).length > 0) {
                            for (var l in mission.LabBind) {
                                // console.log('LabID: ',m.LabBind[l],'------解绑-------->MissonID: ',m.id)
                                this.UnBindLabData(l, mission.id);
                            }
                            mission.LabBind = {};
                        }
                    }
                }
                else {
                    if (this.memory.state == 'war' && mission.CreepBind.repair.num < 2) {
                        mission.CreepBind.repair.historynum = mission.CreepBind.repair.num;
                        mission.CreepBind.repair.num = 2;
                        mission.Data.hangstate = false;
                    }
                    else if (this.memory.state == 'peace' && mission.CreepBind.repair.historynum) {
                        mission.CreepBind.repair.num = mission.CreepBind.repair.historynum;
                        delete mission.CreepBind.repair.historynum;
                        mission.Data.hangstate = false;
                    }
                    else if (mission.CreepBind.repair.num < 1) {
                        mission.CreepBind.repair.num = 1;
                        mission.Data.hangstate = false;
                    }
                }
            }
        }
    }
    Task_HelpRepair(mission) {
        let level = mission.Data.level;
        if (!level)
            mission.Data.level = 'T0';
        if (level == 'T3') {
            global.MSB[mission.id] = { 'repair-work': GenerateAbility(30, 10, 10, 0, 0, 0, 0, 0) };
        }
        else if (level == 'T2') {
            global.MSB[mission.id] = { 'repair-work': GenerateAbility(6, 4, 10, 0, 0, 0, 0, 0) };
        }
        else if (level == 'T1') {
            global.MSB[mission.id] = { 'repair-work': GenerateAbility(20, 10, 15, 0, 0, 0, 0, 0) };
        }
        else ;
        if ((Game.time - global.Gtime[this.name]) % 8)
            return;
        if (mission.LabBind) {
            if (!this.Check_Lab(mission, 'transport', 'complex')) ;
        }
    }
    /* 急速冲级 */
    Task_Quick_upgrade(mission) {
        if (this.controller.level >= 8) {
            this.DeleteMission(mission.id);
            console.log(`房间${this.name}等级已到8级，删除任务!`);
            return;
        }
        if (!this.terminal)
            return;
        if (!this.memory.StructureIdData.labs || this.memory.StructureIdData.labs.length <= 0)
            return;
        /* 能量购买 */
        let terminal_ = this.terminal;
        if (!terminal_)
            return;
        if (!mission.Data.standed)
            mission.Data.standed = true;
        /* 如果terminal附近已经充满了爬虫，则standed为false */
        // let creeps = terminal_.pos.findInRange(FIND_MY_CREEPS, 1)
        // if (creeps.length >= 8) mission.Data.standed = false
        // else mission.Data.standed = true
        if (!this.Check_Lab(mission, 'transport', 'complex'))
            return;
        // if (Game.time % 40) return
        // if (terminal_.store.getUsedCapacity('energy') < 100000 && Game.market.credits >= 1000000) {
        //     let ave = avePrice('energy', 2)
        //     let highest = highestPrice('energy', 'buy', ave + 6)
        //     if (!haveOrder(this.name, 'energy', 'buy', highest, -0.2)) {
        //         let result = Game.market.createOrder({
        //             type: ORDER_BUY,
        //             resourceType: 'energy',
        //             price: highest + 0.1,
        //             totalAmount: 100000,
        //             roomName: this.name
        //         });
        //         if (result != OK) { console.log("创建能量订单出错,房间", this.name) }
        //         console.log(Colorful(`[急速冲级]房间${this.name}创建energy订单,价格:${highest + 0.01};数量:100000`, 'green', true))
        //     }
        // }
    }
    /* 普通冲级 */
    Task_Normal_upgrade(mission) {
        if (this.controller.level >= 8) {
            this.DeleteMission(mission.id);
            console.log(`房间${this.name}等级已到8级，删除任务!`);
            return;
        }
        if (!this.memory.StructureIdData.terminalID)
            return;
        if (!this.memory.StructureIdData.labs || this.memory.StructureIdData.labs.length <= 0)
            return;
        if (mission.LabBind && !this.Check_Lab(mission, 'transport', 'complex'))
            return; // boost
    }
    /* 紧急援建 */
    Task_HelpBuild(mission) {
        if (!mission.Data.defend) {
            global.MSB[mission.id] = { 'architect': GenerateAbility(15, 24, 10, 0, 0, 1, 0, 0) };
        }
        if ((Game.time - global.Gtime[this.name]) % 9)
            return;
        if (mission.LabBind) {
            if (!this.Check_Lab(mission, 'transport', 'complex'))
                return; // 如果目标lab的t3少于 1000 发布搬运任务
        }
    }
    /*紧急升级*/
    Task_HelpUpgrade(mission) {
        if (!mission.Data.defend) {
            global.MSB[mission.id] = { 'upgrade-work': GenerateAbility(10, 30, 10, 0, 0, 0, 0, 0) };
        }
        if ((Game.time - global.Gtime[this.name]) % 9)
            return;
        if (mission.LabBind) {
            if (!this.Check_Lab(mission, 'transport', 'complex'))
                return; // 如果目标lab的t3少于 1000 发布搬运任务
        }
    }
    /* 资源转移任务 */
    Task_Resource_transfer(mission) {
        if (this.controller.level >= 8) {
            if ((Game.time - global.Gtime[this.name]) % 50)
                return;
        }
        else {
            if ((Game.time - global.Gtime[this.name]) % 5)
                return;
        }
        let storage_ = this.storage;
        let terminal_ = this.terminal;
        if (!storage_ || !terminal_) {
            this.DeleteMission(mission.id);
            return;
        }
        if (this.MissionNum('Structure', '资源传送') > 0)
            return; //有传送任务就先不执行
        let _all_store = 0;
        if (storage_)
            _all_store += storage_.store.getUsedCapacity('energy');
        if (terminal_)
            _all_store += terminal_.store.getUsedCapacity('energy');
        if (_all_store < 100000)
            return; // 仓库资源太少不执行
        // 不限定资源代表除了能量和ops之外所有资源都要转移
        if (!mission.Data.rType) {
            for (var i in storage_.store) {
                if (mission.Data.whitelist.length > 0) {
                    if (!isInArray(mission.Data.whitelist, i))
                        continue;
                }
                if (isInArray(['energy', 'ops'], i))
                    continue;
                let missNum = (storage_.store[i] >= 50000) ? 50000 : storage_.store[i];
                let sendTask = this.public_Send(mission.Data.disRoom, i, missNum);
                if (this.AddMission(sendTask))
                    return;
            }
            // 代表已经没有资源了 - 8级控制器终止任务
            if (this.controller.level >= 8) {
                this.DeleteMission(mission.id);
            }
            return;
        }
        else {
            let rType = mission.Data.rType;
            let num = mission.Data.num;
            if (num <= 0 || storage_.store.getUsedCapacity(rType) <= 0) // 数量或存量小于0 就删除任务
             {
                this.DeleteMission(mission.id);
                return;
            }
            let missNum = (num >= 50000) ? 50000 : num;
            if (missNum > storage_.store.getUsedCapacity(rType))
                missNum = storage_.store.getUsedCapacity(rType);
            let sendTask = this.public_Send(mission.Data.disRoom, rType, missNum);
            if (sendTask && this.AddMission(sendTask)) {
                mission.Data.num -= missNum;
            }
        }
    }
    // 扩张援建
    Task_Expand(mission) {
        // console.log('扩张援助体型检测',mission.Data.level)
        if (mission.Data.defend && mission.Data.level) {
            // console.log('扩张援助体型3',mission.Data.level)
            switch (mission.Data.level) {
                case 'T1':
                    global.MSB[mission.id] = {
                        'claim': GenerateAbility(0, 0, 5, 0, 0, 0, 1, 0),
                        'Ebuild': GenerateAbility(15, 15, 15, 0, 0, 0, 0, 0),
                        'Eupgrade': GenerateAbility(15, 15, 15, 0, 0, 0, 0, 0)
                    };
                    break;
                case 'T2':
                    global.MSB[mission.id] = {
                        'claim': GenerateAbility(0, 0, 5, 0, 0, 0, 1, 0),
                        'Ebuild': GenerateAbility(18, 18, 12, 0, 0, 0, 0, 0),
                        'Eupgrade': GenerateAbility(18, 18, 12, 0, 0, 0, 0, 0)
                    };
                    break;
                case 'T3':
                    // console.log('扩张援助体型3')
                    global.MSB[mission.id] = {
                        'claim': GenerateAbility(0, 0, 5, 0, 0, 0, 1, 0),
                        'Ebuild': GenerateAbility(30, 10, 10, 0, 0, 0, 0, 0),
                        'Eupgrade': GenerateAbility(30, 10, 10, 0, 0, 0, 0, 0)
                    };
                    break;
                case 'T4':
                    global.MSB[mission.id] = {
                        'claim': GenerateAbility(0, 0, 6, 0, 0, 1, 1, 0),
                        'Ebuild': GenerateAbility(14, 14, 15, 0, 0, 1, 0, 0),
                        'Eupgrade': GenerateAbility(14, 14, 15, 0, 0, 1, 0, 0)
                    };
                    break;
                case 'T5':
                    global.MSB[mission.id] = {
                        'claim': GenerateAbility(0, 0, 6, 0, 0, 1, 1, 0),
                        'Ebuild': GenerateAbility(14, 14, 15, 0, 0, 1, 0, 0),
                        'Eupgrade': GenerateAbility(14, 14, 15, 0, 0, 1, 0, 0)
                    };
                    break;
                case 'T6':
                    global.MSB[mission.id] = {
                        'claim': GenerateAbility(0, 0, 6, 0, 0, 1, 1, 0),
                        'Ebuild': GenerateAbility(17, 17, 12, 0, 0, 2, 0, 0),
                        'Eupgrade': GenerateAbility(17, 17, 12, 0, 0, 2, 0, 0)
                    };
                    break;
                case 'T7':
                    global.MSB[mission.id] = {
                        'claim': GenerateAbility(0, 0, 6, 0, 0, 1, 1, 0),
                        'Ebuild': GenerateAbility(28, 10, 10, 0, 0, 2, 0, 0),
                        'Eupgrade': GenerateAbility(28, 10, 10, 0, 0, 2, 0, 0)
                    };
                    break;
            }
            // global.MSB[mission.id] = {
            //     'claim': GenerateAbility(0, 0, 10, 0, 0, 5, 1, 4),
            //     'Ebuild': GenerateAbility(10, 4, 20, 0, 0, 6, 0, 0),
            //     'Eupgrade': GenerateAbility(10, 4, 20, 0, 0, 6, 0, 0)
            // }
        }
        if ((Game.time - global.Gtime[this.name]) % 11)
            return;
        if (!this.Check_Lab(mission, 'transport', 'complex'))
            return;
    }
}

/* 房间原型拓展   --方法  --防御塔 */
class RoomFunctionTowerExtension extends Room {
    TowerWork() {
        this.TowerRepair();
        if (this.memory.state == 'peace') {
            if (Game.flags[`${this.name}/repair`]) {
                var towers = this.find(FIND_MY_STRUCTURES, {
                    filter: (stru) => {
                        return stru.structureType == 'tower' && stru.id != this.memory.StructureIdData.NtowerID;
                    }
                });
                var ramparts = this.getListHitsleast(['rampart', 'constructedWall'], 3);
                for (var t of towers)
                    if (t.store.getUsedCapacity('energy') > 400)
                        t.repair(ramparts);
            }
            if (global.Repairlist[this.name].length > 0) {
                let Ntower = null;
                if (this.memory.StructureIdData.NtowerID) {
                    Ntower = Game.getObjectById(this.memory.StructureIdData.NtowerID);
                }
                if (!Ntower) {
                    delete this.memory.StructureIdData.NtowerID;
                    return;
                }
                let Repairdata = Game.getObjectById(global.Repairlist[this.name][0]);
                if (!Repairdata) {
                    global.Repairlist[this.name].shift();
                    return;
                }
                if (Repairdata.hits >= Repairdata.hitsMax) {
                    global.Repairlist[this.name].shift();
                    return;
                }
                Ntower.repair(Repairdata);
            }
        }
        else if (this.memory.state == 'war') {
            if (Game.flags[`${this.name}/stop`])
                return;
            if (this.memory.switch.AutoDefend && this.controller.level > 6) {
                if (this.controller.level >= 8) {
                    if (global.Repairlist[this.name].length > 0) {
                        let Ntower = null;
                        if (this.memory.StructureIdData.NtowerID) {
                            Ntower = Game.getObjectById(this.memory.StructureIdData.NtowerID);
                        }
                        if (!Ntower) {
                            delete this.memory.StructureIdData.NtowerID;
                            return;
                        }
                        let Repairdata = Game.getObjectById(global.Repairlist[this.name][0]);
                        if (!Repairdata) {
                            global.Repairlist[this.name].shift();
                            return;
                        }
                        if (Repairdata.hits >= Repairdata.hitsMax) {
                            global.Repairlist[this.name].shift();
                            return;
                        }
                        Ntower.repair(Repairdata);
                    }
                }
                return;
            }
            else {
                if (Game.flags[`${this.name}/repair`]) {
                    var towers = this.find(FIND_MY_STRUCTURES, {
                        filter: (stru) => {
                            return stru.structureType == 'tower' && stru.id != this.memory.StructureIdData.NtowerID;
                        }
                    });
                    var ramparts = this.getListHitsleast(['rampart', 'constructedWall'], 3);
                    for (var t of towers)
                        if (t.store.getUsedCapacity('energy') > 400)
                            t.repair(ramparts);
                }
            }
            /* 没有主动防御下的防御塔逻辑 */
            let enemys = this.find(FIND_HOSTILE_CREEPS, {
                filter: (creep) => {
                    return !isInArray(Memory.whitesheet, creep.owner.username);
                }
            });
            if (!this.memory.StructureIdData.AtowerID)
                this.memory.StructureIdData.AtowerID = [];
            if (enemys.length <= 0)
                return;
            else if (enemys.length == 1) {
                for (let thisTower of this.getStructure(STRUCTURE_TOWER)) {
                    // let thisTower = Game.getObjectById(c) as StructureTower
                    // if (!thisTower) {
                    //     let index = this.memory.StructureIdData.AtowerID.indexOf(c); this.memory.StructureIdData.AtowerID.splice(index, 1); continue
                    // }
                    thisTower.attack(enemys[0]);
                }
            }
            else if (enemys.length > 1) {
                if (enemys.length >= 3 && enemys[0].ticksToLive < 1450) {
                    return;
                }
                for (let thisTower of this.getStructure(STRUCTURE_TOWER)) {
                    // let thisTower = Game.getObjectById(c) as StructureTower
                    // if (!thisTower) {
                    //     let index = this.memory.StructureIdData.AtowerID.indexOf(c); this.memory.StructureIdData.AtowerID.splice(index, 1); continue
                    // }
                    if (Game.time % 2)
                        thisTower.attack(enemys[0]);
                    else
                        thisTower.attack(enemys[1]);
                }
            }
        }
    }
    TowerRepair() {
        if ((Game.time - global.Gtime[this.name]) % 20) {
            return;
        }
        global.Repairlist[this.name] = [];
        if (this.memory.state == 'war') {
            var repairRoad = this.find(FIND_STRUCTURES, {
                filter: (stru) => {
                    return (stru.structureType == 'road' || stru.structureType == 'container') && stru.hits / stru.hitsMax < 0.3;
                }
            });
        }
        else {
            var repairRoad = this.find(FIND_STRUCTURES, {
                filter: (stru) => {
                    return (stru.structureType == 'road' || stru.structureType == 'container') && stru.hits / stru.hitsMax < 0.8;
                }
            });
        }
        if (repairRoad.length > 0) {
            for (let i in repairRoad) {
                let repairRoad_ = repairRoad[i];
                global.Repairlist[this.name].push(repairRoad_.id);
            }
        }
    }
}

/* 房间原型拓展   --任务  --常规战争 */
class NormalWarExtension$1 extends Room {
    // 拆迁黄球
    Task_dismantle(mission) {
        if ((Game.time - global.Gtime[this.name]) % 10)
            return;
        if (mission.Data.boost) {
            // 体型
            global.MSB[mission.id] = { 'dismantle': GenerateAbility(40, 0, 10, 0, 0, 0, 0, 0) };
            // boost lab填充检查
            if (!this.Check_Lab(mission, 'transport', 'complex'))
                return;
        }
        /* 数量投放 */
        if (mission.CreepBind['dismantle'].num == 0)
            mission.CreepBind['dismantle'].num = mission.Data.num;
    }
    Task_CConstruction(mission) {
        if (mission.Data.boost) {
            // 体型
            let bodylevel = mission.Data.bodylevel;
            switch (bodylevel) {
                case 'T3':
                    // 高级奶妈
                    global.MSB[mission.id] = { 'c-construction-site': GenerateAbility(0, 0, 10, 0, 1, 27, 0, 12) };
                    break;
                default:
                    // 默认不处理的
                    global.MSB[mission.id] = { 'c-construction-site': GenerateAbility(0, 0, 1, 0, 0, 0, 0, 0) };
                    break;
            }
            if ((Game.time - global.Gtime[this.name]) % 10)
                return;
            // boost lab填充检查
            if (!this.Check_Lab(mission, 'transport', 'complex'))
                return;
        }
        else {
            if ((Game.time - global.Gtime[this.name]) % 10)
                return;
        }
        if (mission.CreepBind['c-construction-site'].num == 0)
            mission.CreepBind['c-construction-site'].num = mission.Data.num;
    }
    // 一体机
    Task_aio(mission) {
        if (mission.Data.boost) {
            // 体型
            let bodylevel = mission.Data.bodylevel;
            switch (bodylevel) {
                case 'T9':
                    global.MSB[mission.id] = { 'aio': GenerateAbility(0, 0, 10, 0, 15, 20, 0, 5) };
                    break;
                case 'T8':
                    /*过道清理员 -T1化合物*/
                    global.MSB[mission.id] = { 'aio': GenerateAbility(0, 0, 17, 0, 18, 15, 0, 0) };
                    break;
                case 'T2':
                    // 不可以防御6塔的体型，适合清理七级以内新手房
                    global.MSB[mission.id] = { 'aio': GenerateAbility(0, 0, 10, 0, 15, 20, 0, 5) };
                    break;
                case 'T1':
                    // 可以防御距离适中的六塔，适合骑墙
                    global.MSB[mission.id] = { 'aio': GenerateAbility(0, 0, 10, 0, 11, 20, 0, 9) };
                    break;
                case 'T0':
                    // 最高防御单位
                    global.MSB[mission.id] = { 'aio': GenerateAbility(0, 0, 10, 0, 6, 23, 0, 11) };
                    break;
            }
            if ((Game.time - global.Gtime[this.name]) % 10)
                return;
            // boost lab填充检查
            if (!this.Check_Lab(mission, 'transport', 'complex'))
                return;
        }
        else {
            if ((Game.time - global.Gtime[this.name]) % 10)
                return;
        }
        if (mission.CreepBind['aio'].num == 0)
            mission.CreepBind['aio'].num = mission.Data.num;
    }
    // 双人小队
    Task_double(mission) {
        if ((Game.time - global.Gtime[this.name]) % 11)
            return;
        if (!this.Check_Lab(mission, 'transport', 'complex'))
            return;
    }
    // 四人小队
    Task_squad(mission) {
        if ((Game.time - global.Gtime[this.name]) % 7)
            return;
        if (!mission.Data.squadID) {
            if (!Memory.squadMemory)
                Memory.squadMemory = {};
            let randomStr = Math.random().toString(36).substr(3);
            if (!Memory.squadMemory[`${mission.Data.flag}|${randomStr}|${Game.shard.name}`]) {
                mission.Data.squadID = `${mission.Data.flag}|${randomStr}|${Game.shard.name}`;
            }
        }
        else {
            if (Memory.squadMemory[mission.Data.squadID] && Object.keys(Memory.squadMemory[mission.Data.squadID].creepData).length >= 4) {
                delete mission.Data.squadID;
            }
        }
        if (!this.Check_Lab(mission, 'transport', 'complex'))
            return;
    }
    // 紧急支援
    Task_HelpDefend(mission) {
        if (mission.Data.sType == 'aio' && mission.Data.boost) {
            global.SpecialBodyData[this.name]['saio'] = GenerateAbility(0, 0, 10, 0, 6, 23, 0, 11);
        }
        if ((Game.time - global.Gtime[this.name]) % 7)
            return;
        if (mission.LabBind) {
            if (!this.Check_Lab(mission, 'transport', 'complex'))
                return;
        }
    }
}

/* 房间原型拓展   --任务  --Ai战争 */
class NormalWarExtension extends Room {
    Task_Aisentry(mission) {
        if ((Game.time - global.Gtime[this.name]) % 11)
            return;
        if (!this.Check_Lab(mission, 'transport', 'complex'))
            return;
    }
}

/* 房间原型拓展   --任务  --中央运输工任务 */
class RoomMissonManageExtension extends Room {
    /* 链接送仓   即中央链接能量转移至仓库 */
    Task_Clink() {
        if ((Game.time - global.Gtime[this.name]) % 5)
            return;
        if (!this.memory.StructureIdData.center_link)
            return; /*不存在中央LINK终止*/
        var center_link = Game.getObjectById(this.memory.StructureIdData.center_link);
        if (!center_link) {
            delete this.memory.StructureIdData.center_link;
            return;
        }
        var storage_ = this.storage; /*获取storage*/
        if (!storage_) {
            return;
        }
        if (storage_.store.getFreeCapacity() <= 10000)
            return; // storage满了就不挂载任务了
        for (var i of this.memory.Misson['Structure']) {
            if (i.name == '链传送能' && isInArray(i.structure, this.memory.StructureIdData.center_link))
                return;
        }
        if (center_link.store.getUsedCapacity('energy') >= 200 && this.Check_Carry('manage', center_link.pos, storage_.pos, 'energy')) {
            var thisTask = this.public_Carry({ 'manage': { num: 1, bind: [] } }, 20, this.name, center_link.pos.x, center_link.pos.y, this.name, storage_.pos.x, storage_.pos.y, 'energy');
            this.AddMission(thisTask);
        }
    }
}

/* 房间原型拓展   --行为  --防御任务 */
class RoomMissonDefendExtension$1 extends Room {
}

/* 房间原型拓展   --行为  --采矿任务 */
class RoomMissonMineExtension extends Room {
    /* 房间内矿资源采集发布任务 */
    Task_monitorMineral() {
        if (Game.cpu.bucket < 7000 && Memory.StopPixel)
            return;
        if ((Game.time - global.Gtime[this.name]) % 67)
            return;
        if (this.memory.switch.stopmineral)
            return;
        if (this.controller.level < 6)
            return;
        if (!this.memory.StructureIdData.mineralID)
            return;
        if (this.MissionNum('Creep', '原矿开采') > 0)
            return;
        var mineral = Game.getObjectById(this.memory.StructureIdData.mineralID);
        if (!mineral || mineral.ticksToRegeneration)
            return;
        if (!this.memory.mineralType)
            this.memory.mineralType = mineral.mineralType;
        if (this.controller.level >= 6 && !this.memory.StructureIdData.extractID) {
            /* 寻找矿物点 在其附近撒下建筑 */
            if (!mineral.pos.GetStructure('extractor') && mineral.pos.lookFor(LOOK_CONSTRUCTION_SITES).length <= 0) {
                mineral.pos.createConstructionSite('extractor');
                return;
            }
            return;
        }
        /* 寻找mineralContainerID */
        var container_ = mineral.pos.findInRange(FIND_STRUCTURES, 1, {
            filter: (stru) => {
                return stru.structureType == 'container';
            }
        });
        var container_cons = mineral.pos.findInRange(FIND_MY_CONSTRUCTION_SITES, 1, {
            filter: (stru) => {
                return stru.structureType == 'container';
            }
        });
        if (container_.length <= 0 && container_cons.length <= 0) {
            /* 建立container */
            var result = [];
            var terrain = new Room.Terrain(this.name);
            var xs = [mineral.pos.x - 1, mineral.pos.x, mineral.pos.x + 1];
            var ys = [mineral.pos.y - 1, mineral.pos.y, mineral.pos.y + 1];
            xs.forEach(x => ys.forEach(y => {
                if (terrain.get(x, y) != TERRAIN_MASK_WALL) {
                    result.push(new RoomPosition(x, y, this.name));
                }
            }));
            for (var p of result) {
                if (p.lookFor(LOOK_CONSTRUCTION_SITES).length <= 0 && p.lookFor(LOOK_STRUCTURES).length <= 0) {
                    p.createConstructionSite('container');
                    return;
                }
            }
            return;
        }
        if (container_.length <= 0) {
            return;
        }
        /* 建筑都到位了，开始下任务 */
        var storage_ = this.storage;
        if (!storage_)
            return;
        /* 如果矿物饱和，自动进行打包操作 */
        if (storage_.store.getUsedCapacity(this.memory.mineralType) > 100000) {
            let factory_ = this.GetStructData(STRUCTURE_FACTORY);
            // console.log('矿物饱和打包',this.name,zipMap[this.memory.mineralType],Object.keys(this.memory.productData.unzip).length,JSON.stringify(factory_))
            if (factory_ && zipMap[this.memory.mineralType] && Object.keys(this.memory.productData.unzip).length < 1) {
                // console.log('矿物饱和打包',this.name,this.memory.productData.state)
                // let storage_zip_number = Number(storage_.store.getUsedCapacity(zipMap[this.memory.mineralType]))
                // factory_.add(zipMap[this.memory.mineralType], 6000 + storage_zip_number)
                if (this.memory.productData.state == 'sleep') {
                    this.memory.productData.state = 'base';
                    this.memory.productData.producing = { com: zipMap[this.memory.mineralType], num: 6000 };
                }
            }
            // if (!this.memory.market) this.memory.market = {}
            // if (!this.memory.market['deal']) this.memory.market['deal'] = []
            // var bR = true
            // for (var od of this.memory.market['deal']) {
            //     if (od.rType == this.memory.mineralType)
            //         bR = false
            // }
            // if (bR) {
            //     /* 下达自动deal的任务 */
            //     this.memory.market['deal'].push({ rType: this.memory.mineralType, num: 30000, mTyep: 'sell'  })
            // }
        }
        /* 防止挖矿致死 */
        if (storage_.store.getFreeCapacity() > 100000 && storage_.store.getUsedCapacity(this.memory.mineralType) < 220000) {
            // 下达挖矿任务
            var thisTask = {
                name: '原矿开采',
                range: 'Creep',
                delayTick: 50000,
                level: 10,
                Data: {},
            };
            thisTask.CreepBind = { 'mineral': { num: 1, bind: [] } };
            this.AddMission(thisTask);
        }
    }
    /* 房间外矿处理任务 只适用于一般外矿 */
    Task_OutMine(mission) {
        var _a, _b, _c;
        if ((Game.time - global.Gtime[this.name]) % 13)
            return;
        if (!mission.Data.state)
            mission.Data.state = 1; // 默认状态1
        function setBind(role, num) {
            if (!mission.CreepBind[role]) {
                mission.CreepBind[role] = { num: num, bind: [] };
            }
            else {
                mission.CreepBind[role].num = num;
            }
        }
        setBind('out-claim', 1);
        let disRoomName = mission.Data.disRoom;
        if (!Memory.outMineData[disRoomName])
            Memory.outMineData[disRoomName] = { road: [], startpoint: mission.Data.startpoint, minepoint: [], mineType: 'normal' };
        // 相关爬虫死亡后的数据擦除
        if (Memory.outMineData[disRoomName].minepoint && Memory.outMineData[disRoomName].minepoint.length > 0 && Memory.outMineData[disRoomName].mineType == 'normal') {
            for (var obj of Memory.outMineData[disRoomName].minepoint) {
                if (obj.bind && obj.bind.harvest && !Game.creeps[obj.bind.harvest])
                    delete obj.bind.harvest;
                if (obj.bind && obj.bind.car && !Game.creeps[obj.bind.car])
                    delete obj.bind.car;
            }
        }
        //房间等级低于7级时不能采集中央矿区
        if (mission.Data.central && Game.rooms[this.name].controller.level < 7) {
            console.log(`房间等级低于7级时不能采集中央矿区！`);
            this.DeleteMission(mission.id);
            return;
        }
        if (mission.Data.state == 1) // 初始化状态
         {
            /* 状态1下仅仅获取外矿信息和派出claimer */
            if (Game.rooms[disRoomName]) {
                var sources = Game.rooms[disRoomName].find(FIND_SOURCES);
                if (sources.length <= 0) {
                    Game.notify(`房间${disRoomName}未发现能量点！删除外矿任务！`);
                    this.DeleteMission(mission.id);
                    return;
                }
                /* 说明有该房间的视野了 先查找矿点 */
                if (Memory.outMineData[disRoomName].minepoint.length < sources.length) {
                    LoopS: for (var s of sources) {
                        for (var m of Memory.outMineData[disRoomName].minepoint) {
                            if (m.pos == zipPosition(s.pos))
                                continue LoopS;
                        }
                        Memory.outMineData[disRoomName].minepoint.push({ pos: zipPosition(s.pos), bind: {} });
                    }
                    return;
                }
                /* 矿点信息更新完毕了 接下来更新路线信息 */
                if (!mission.Data.roadUpdated) {
                    Memory.outMineData[disRoomName].road = [];
                    var startpos = unzipPosition(Memory.outMineData[disRoomName].startpoint);
                    if (!startpos) {
                        console.log(`${startpos}不能解压成RoomPosition对象`);
                        return;
                    }
                    /* 每个矿点都要有一个路线信息 */
                    for (var s of sources) {
                        var results = startpos.FindPath(s.pos, 1, mission.Data.roadUpdatedforce);
                        for (var p of results) {
                            if (p.isNearTo(s.pos))
                                continue;
                            if (isInArray([0, 49], p.x) || isInArray([0, 49], p.y))
                                continue;
                            /* 如果不再路径点缓存中，就push进路径列表中 */
                            if (!isInArray(Memory.outMineData[disRoomName].road, zipPosition(p))) {
                                Memory.outMineData[disRoomName].road.push(zipPosition(p));
                            }
                        }
                    }
                    mission.Data.roadUpdated = true;
                    mission.Data.roadUpdatedforce = false;
                    return;
                }
                /* 先看路径点中是否有本房间的位置点，有的话就创建工地 */
                for (var mess of Memory.outMineData[disRoomName].road) {
                    if (unzipPosition(mess).roomName == this.name) {
                        unzipPosition(mess).createConstructionSite('road');
                        //var index = Memory.outMineData[disRoomName].road.indexOf(mess)
                        //Memory.outMineData[disRoomName].road.splice(index,1)
                    }
                }
                /* 路线信息更新完毕 接下来进入阶段2 */
                mission.Data.state = 2;
                /* 若是中央九房就进入阶段4 */
                if (mission.Data.central) {
                    setBind('out-claim', 0);
                    setBind('out-defend', 0);
                    mission.Data.state = 4;
                }
            }
        }
        else if (mission.Data.state == 2) // 采集状态 [正常状态]
         {
            if (((_c = (_b = (_a = Game.rooms[disRoomName]) === null || _a === void 0 ? void 0 : _a.controller) === null || _b === void 0 ? void 0 : _b.reservation) === null || _c === void 0 ? void 0 : _c.ticksToEnd) > 4000) {
                setBind('out-claim', 0);
            }
            setBind('out-harvest', Memory.outMineData[disRoomName].minepoint.length);
            setBind('out-defend', 0);
            if (Memory.outMineData[disRoomName].car) {
                setBind('out-car', Memory.outMineData[disRoomName].minepoint.length);
            }
            else
                setBind('out-car', 0);
            if (Game.rooms[mission.Data.disRoom]) {
                var container = Game.rooms[mission.Data.disRoom].find(FIND_STRUCTURES, {
                    filter: (stru) => {
                        return stru.structureType == STRUCTURE_CONTAINER &&
                            stru.store.getFreeCapacity() <= 0;
                    }
                });
                if (container.length > 0 && mission.CreepBind['out-car'].bind.length == mission.CreepBind['out-car'].num) {
                    setBind('out-carry', container.length);
                }
            }
        }
        else if (mission.Data.state == 3) // 防御状态
         {
            setBind('out-harvest', 0);
            setBind('out-car', 0);
            setBind('out-claim', 0);
            setBind('out-defend', 1);
            if (Game.rooms[mission.Data.disRoom]) {
                var enemys = Game.rooms[mission.Data.disRoom].find(FIND_HOSTILE_CREEPS, {
                    filter: (creep) => {
                        return !isInArray(Memory.whitesheet, creep.owner.username) && (creep.getActiveBodyparts(ATTACK) > 0 || creep.getActiveBodyparts(RANGED_ATTACK) > 0);
                    }
                });
                var InvaderCore = Game.rooms[mission.Data.disRoom].find(FIND_STRUCTURES, {
                    filter: (stru) => {
                        return stru.structureType == STRUCTURE_INVADER_CORE;
                    }
                });
                if (enemys.length <= 0 && InvaderCore.length <= 0)
                    mission.Data.state = 2;
            }
        }
        else if (mission.Data.state == 4) //中央九房采集
         {
            setBind('out-claim', 0);
            if (Game.time < mission.Data.sleepTime) {
                mission.Data.nextLair = 0;
                for (const role in mission.CreepBind) {
                    setBind(role, 0);
                }
                return;
            }
            var atkCreep = Game.creeps[mission.CreepBind['out-attack'].bind[0]];
            if (atkCreep && !mission.Data.hasInvader) {
                if (atkCreep.ticksToLive < 200 && mission.CreepBind['out-attack'].bind.length < 2) {
                    setBind('out-attack', 2); //提前产爬
                }
                else {
                    setBind('out-attack', 1);
                }
                setBind('out-defend', 0);
                setBind('out-harvest', 3); //有守护者则开始采集
                setBind('out-car', 3);
                setBind('out-carry', 2);
            }
            else {
                if (mission.Data.hasInvader) {
                    setBind('out-defend', 1); //有Invader则加强防御
                }
                else {
                    setBind('out-defend', 0);
                }
                setBind('out-attack', 1); //先生产守护者
                setBind('out-harvest', 0);
                setBind('out-car', 0);
                setBind('out-carry', 0);
            }
            if (Game.rooms[mission.Data.disRoom]) {
                //寻找要塞
                var stronghold = Game.rooms[mission.Data.disRoom].find(FIND_STRUCTURES, {
                    filter: (stru) => {
                        return stru.structureType == STRUCTURE_INVADER_CORE && stru.level >= 1 && !stru.ticksToDeploy;
                    }
                });
                if (stronghold.length > 0) {
                    if (stronghold[0].level <= 2 && this.controller.level >= 8) { //对于低等级要塞发布攻防一体任务,七级房就摆烂
                        var thisTask = this.public_aio(mission.Data.disRoom, Game.shard.name, 1, 1500, true, "T2");
                        if (thisTask && this.AddMission(thisTask)) {
                            mission.Data.state = 5;
                            console.log(`[war] 对${mission.Data.disRoom}等级为${stronghold[0].level}的要塞挂载攻防一体任务!`);
                        }
                    }
                    mission.Data.sleepTime = Game.time + stronghold[0].effects[0].ticksRemaining;
                }
                //寻找Invader
                var invader = Game.rooms[mission.Data.disRoom].find(FIND_HOSTILE_CREEPS, {
                    filter: (creep) => {
                        return creep.owner.username == 'Invader' &&
                            (creep.getActiveBodyparts(ATTACK) > 0 || creep.getActiveBodyparts(RANGED_ATTACK) > 0);
                    }
                });
                if (invader.length > 0) {
                    if (invader.length >= 2) {
                        mission.Data.sleepTime = Game.time + invader[0].ticksToLive - 200; //Invader太多了就暂停采集
                        return;
                    }
                    mission.Data.hasInvader = true;
                }
                else {
                    mission.Data.hasInvader = false;
                }
                //寻找container
                var container = Game.rooms[mission.Data.disRoom].find(FIND_STRUCTURES, {
                    filter: (stru) => {
                        return stru.structureType == STRUCTURE_CONTAINER &&
                            stru.store.getFreeCapacity() <= 0;
                    }
                });
                if (container.length > 0 && mission.CreepBind['out-car'].bind.length == mission.CreepBind['out-car'].num) {
                    setBind('out-carry', 2 + container.length);
                }
            }
        }
        else if (mission.Data.state == 5) //低等级要塞
         {
            mission.Data.nextLair = 0;
            for (const role in mission.CreepBind) {
                setBind(role, 0);
            }
            if (Game.time < mission.Data.sleepTime) {
                if (Game.rooms[mission.Data.disRoom]) {
                    var stronghold = Game.rooms[mission.Data.disRoom].find(FIND_STRUCTURES, {
                        filter: (stru) => {
                            return stru.structureType == STRUCTURE_INVADER_CORE && stru.level >= 1 && !stru.ticksToDeploy;
                        }
                    });
                    if (stronghold.length <= 0) {
                        mission.Data.state = 4;
                        delete mission.Data.sleepTime;
                    }
                }
            }
            else {
                mission.Data.state = 4;
                delete mission.Data.sleepTime;
            }
        }
    }
    /* 过道采集监控发布任务 */
    Task_Cross(mission) {
        if (this.controller.level < 8 || !this.memory.StructureIdData.ObserverID)
            return;
        if (Game.cpu.bucket < 9500 && Memory.StopPixel)
            return; /*CPU不足情况下不进行任务发布*/
        if (this.memory.switch.StopCross)
            return;
        var observer_ = Game.getObjectById(this.memory.StructureIdData.ObserverID);
        if (!observer_) {
            delete this.memory.StructureIdData.ObserverID;
            return;
        }
        if (!mission.Data.relateRooms)
            mission.Data.relateRooms = [];
        if (mission.Data.relateRooms.length <= 0)
            return;
        if (!mission.Data.index)
            mission.Data.index = 0;
        if (!mission.Data.state)
            mission.Data.state = 1;
        if (mission.Data.state == 1) {
            // let a = Game.cpu.getUsed();
            /* 观察房间 */
            if (mission.Data.relateRooms[mission.Data.index]) {
                observer_.observeRoom(mission.Data.relateRooms[mission.Data.index]);
            }
            // console.log(`observer正在观察房间${mission.Data.relateRooms[mission.Data.index]}`)
            /* 获取上个tick的房间名 */
            let beforRoom;
            if (mission.Data.relateRooms.length == 1)
                beforRoom = mission.Data.relateRooms[0];
            else if (mission.Data.relateRooms.length > 1) {
                if (mission.Data.index == 0)
                    beforRoom = mission.Data.relateRooms[mission.Data.relateRooms.length - 1];
                else
                    beforRoom = mission.Data.relateRooms[mission.Data.index - 1];
            }
            if (Game.rooms[beforRoom]) {
                /* 查找power和deposit */
                // console.log('扫描房间',this.name)
                if (mission.Data.power) {
                    this.Add_Cross_power(beforRoom);
                }
                if (mission.Data.deposit) {
                    this.Add_Cross_deposit(beforRoom);
                }
            }
            if (mission.Data.index > mission.Data.relateRooms.length) {
                mission.Data.index = 0;
                mission.Data.time = Game.time;
                mission.Data.state = 2;
            }
            else {
                mission.Data.index++;
            }
            // let b = Game.cpu.getUsed();
            // console.log(this.name, beforRoom, b - a)
        }
        else if (mission.Data.state == 2) {
            if (Game.time - mission.Data.time != 0 && (Game.time - mission.Data.time) % 180 == 0) {
                mission.Data.state = 1;
                // console.log(Colorful("进入观察模式",'blue'))
            }
        }
    }
    Add_Cross_deposit(beforRoom) {
        if (this.MissionNum('Creep', 'deposit采集') >= 2)
            return;
        var deposit = Game.rooms[beforRoom].find(FIND_DEPOSITS, {
            filter: (stru) => {
                return stru.ticksToDecay >= 3800 && stru.lastCooldown < 100;
            }
        });
        if (deposit.length < 1)
            return;
        for (let _dp of deposit) {
            let _ob_pos = zipPosition(_dp.pos);
            let BR = true;
            if (Memory.ObserverList[_ob_pos])
                continue; /*这里将会过滤无法到达的位置以及已经进行任务发布的任务*/
            for (var i of this.memory.Misson['Creep']) {
                if (i.name == 'deposit采集' && i.Data.room == beforRoom) {
                    BR = false;
                }
            }
            if (BR) {
                /*检查shard 以及是否需要新手区检测*/
                if (!this.Check_Cross_newbies(_dp, beforRoom))
                    continue;
                /*检测dp可以挖掘的位置数量*/
                var harvest_void = _dp.pos.getSourceVoid();
                /* 下达采集任务 */
                var thisTask = this.public_DepositHarvest(beforRoom, _dp.pos.x, _dp.pos.y, _dp.depositType, harvest_void.length);
                if (thisTask != null) {
                    thisTask.Data.deposit_id = _dp.id;
                    this.AddMission(thisTask);
                    Memory.ObserverList[_ob_pos] = Game.time; /*进行状态标记操作*/
                }
            }
        }
    }
    Add_Cross_power(beforRoom) {
        if (this.MissionNum('Creep', 'power采集') >= 2)
            return;
        var powerbank = Game.rooms[beforRoom].find(FIND_STRUCTURES, {
            filter: (stru) => {
                return stru.structureType == 'powerBank' && stru.ticksToDecay >= 3600 && stru.power > 3000;
            }
        });
        if (powerbank.length < 1)
            return;
        for (let _pw of powerbank) {
            let _ob_pos = zipPosition(_pw.pos);
            let BR = true;
            if (Memory.ObserverList[_ob_pos])
                continue; /*这里将会过滤无法到达的位置以及已经进行任务发布的任务*/
            for (var i of this.memory.Misson['Creep']) {
                if (i.name == 'power采集' && i.Data.room == beforRoom && i.Data.x == _pw.pos.x && i.Data.y == _pw.pos.y) {
                    BR = false;
                }
            }
            if (BR) {
                /*检查shard 以及是否需要新手区检测*/
                if (!this.Check_Cross_newbies(_pw, beforRoom))
                    continue;
                /* 下达采集任务 */
                var thisTask = this.public_PowerHarvest(beforRoom, _pw.pos.x, _pw.pos.y, _pw.power);
                if (thisTask != null) {
                    this.AddMission(thisTask);
                    Memory.ObserverList[_ob_pos] = Game.time; /*进行状态标记操作*/
                }
            }
        }
    }
    Check_Cross_newbies(structure, beforRoom) {
        if (Game.shard.name != 'shard3')
            return true;
        /*检测是否存在墙壁信息*/
        if (Game.rooms[beforRoom].find(FIND_STRUCTURES).find(e => e.structureType == STRUCTURE_WALL)) { //如果有墙壁
            if (!Game.rooms[beforRoom].lookForAtArea(LOOK_STRUCTURES, Math.min(structure.pos.y, 25), Math.min(structure.pos.x, 25), Math.max(structure.pos.y, 25), Math.max(structure.pos.x, 25), true)
                .find(e => e.structure.structureType == STRUCTURE_WALL)) {
                return true;
            }
        }
        else {
            return true;
        }
        /*如果不存在路径则进行存储防止后续的刷新操作*/
        console.log(this.name, JSON.stringify(structure.pos), '无法到达');
        let _ob_pos = zipPosition(structure.pos);
        Memory.ObserverList[_ob_pos] = Game.time + structure.ticksToDecay;
        return false;
    }
    /* Power采集 */
    Task_PowerHarvest(mission) {
        if (this.controller.level < 8)
            return;
        if (!mission.Data.state)
            mission.Data.state = 1;
        if (mission.Data.state == 1) {
            mission.CreepBind['power-carry'].num = 0;
        }
        else if (mission.Data.state == 2) {
            if (!mission.Data.down)
                mission.Data.down = false;
            if (!mission.Data.down) {
                mission.CreepBind['power-carry'].num = Math.ceil(mission.Data.num / 1600);
                mission.Data.down = true;
            }
            mission.CreepBind['power-attack'].num = 0;
            mission.CreepBind['power-heal'].num = 0;
            if (mission.CreepBind['power-carry'].num == mission.CreepBind['power-carry'].bind.length && mission.CreepBind['power-carry'].num != 0) {
                mission.CreepBind['power-carry'].num = 0;
            }
            if (mission.CreepBind['power-attack'].bind.length <= 0 && mission.CreepBind['power-heal'].bind.length <= 0 && mission.CreepBind['power-carry'].bind.length <= 0
                && mission.CreepBind['power-carry'].num <= 0) {
                this.DeleteMission(mission.id);
            }
        }
    }
}

/* 房间原型拓展   --智能战争 */
class RoomMissonDefendExtension extends Room {
    /*智能战争初始化保持*/
    Task_Aiwar(mission) {
        if (this.MissionNum('Creep', '智能哨兵') > 0)
            return;
        /*派发智能哨兵任务*/
        var thisTask = {
            name: '智能哨兵',
            range: 'Creep',
            delayTick: 50000,
            level: 10,
            Data: {
                disRoom: mission.Data.disRoom,
                shard: mission.Data.shard,
                bodylevel: mission.Data.bodylevel
            },
        };
        if (mission.Data.boost) { /*强化任务*/
            thisTask.Data.boost = mission.Data.boost;
        }
        if (mission.Data.shardData) { /*位面传送*/
            thisTask.Data.shardData = mission.Data.shardData;
        }
        thisTask.CreepBind = { 'Ai-sentry': { num: 1, bind: [], interval: 1000, MSB: true } };
        switch (mission.Data.bodylevel) {
            case 'T3':
                thisTask.LabMessage = { 'XLHO2': 'boost', 'XZHO2': 'boost', 'XGHO2': 'boost' };
                break;
        }
        this.AddMission(thisTask);
    }
}

/* 房间原型拓展   --任务  --防御战争 */
class DefendWarExtension extends Room {
    // 核弹防御
    Nuke_Defend() {
        if (this.memory.nukeData && this.memory.nukeData.damage && Object.keys(this.memory.nukeData.damage).length > 0)
            for (var i in this.memory.nukeData.damage) {
                var thisPos = unzipPosition(i);
                new RoomVisual(this.name).text(`${this.memory.nukeData.damage[i] / 1000000}M`, thisPos.x, thisPos.y, { color: this.memory.nukeData.damage[i] == 0 ? 'green' : 'red', font: 0.5 });
            }
        if ((Game.time - global.Gtime[this.name]) % 41)
            return;
        if (this.memory.switch.Stopnukeprotect)
            return;
        if (this.controller.level < 6)
            return;
        // var nuke_ = this.find(FIND_FLAGS,{filter:(flag_)=>{return flag_.color == COLOR_ORANGE}})
        if (!this.memory.nukeID)
            this.memory.nukeID = [];
        if (!this.memory.nukeData)
            this.memory.nukeData = { damage: {}, rampart: {} };
        var nuke_ = this.find(FIND_NUKES);
        if (nuke_.length > 0) {
            /* 发现核弹，激活核防御任务 */
            var data = this.memory.nukeData.damage;
            var rampart = this.memory.nukeData.rampart;
            for (var n of nuke_) {
                if (isInArray(this.memory.nukeID, n.id))
                    continue;
                var strPos = zipPosition(n.pos);
                if (n.pos.GetStructureList(['spawn', 'rampart', 'terminal', 'powerSpawn', 'factory', 'nuker', 'lab', 'tower', 'storage']).length > 0) {
                    if (!data[strPos])
                        data[strPos] = 10000000;
                    else
                        data[strPos] += 10000000;
                    if (!rampart[strPos]) {
                        var rampart_ = n.pos.GetStructure('rampart');
                        if (rampart_)
                            rampart[strPos] = rampart_.hits;
                        else
                            rampart[strPos] = 0;
                    }
                }
                for (var nX = n.pos.x - 2; nX < n.pos.x + 3; nX++)
                    LoopB: for (var nY = n.pos.y - 2; nY < n.pos.y + 3; nY++) {
                        var thisPos = new RoomPosition(nX, nY, this.name);
                        if (nX == n.pos.x && nY == n.pos.y)
                            continue LoopB;
                        if (thisPos.GetStructureList(['spawn', 'rampart', 'terminal', 'powerSpawn', 'factory', 'nuker', 'lab', 'tower']).length <= 0)
                            continue LoopB;
                        if (nX > 0 && nY > 0 && nX < 49 && nY < 49) {
                            var strThisPos = zipPosition(thisPos);
                            if (!data[strThisPos])
                                data[strThisPos] = 5000000;
                            else
                                data[strThisPos] += 5000000;
                            if (!rampart[strThisPos]) {
                                var rampart_ = n.pos.GetStructure('rampart');
                                if (rampart_)
                                    rampart[strThisPos] = rampart_.hits;
                                else
                                    rampart[strThisPos] = 0;
                            }
                        }
                    }
                this.memory.nukeID.push(n.id);
            }
            let allDamageNum = 0;
            for (var i in data) {
                /*  */
                var thisPos = unzipPosition(i);
                if (data[i] == 0) {
                    var rampart__ = thisPos.GetStructure('rampart');
                    if (rampart__) {
                        rampart[i] = rampart__.hits;
                    }
                }
                allDamageNum += data[i];
            }
            /* 计算总核弹需要维修的伤害确定 */
            var boostType = null;
            if (allDamageNum >= 50000000)
                boostType = 'XLH2O';
            var num = 1;
            if (allDamageNum >= 10000000 && allDamageNum < 20000000)
                num = 2;
            else if (allDamageNum >= 20000000 && allDamageNum < 40000000)
                num = 3;
            else if (allDamageNum >= 40000000)
                num = 3;
            var task;
            for (var t of this.memory.Misson['Creep']) {
                if (t.name == '墙体维护' && t.Data.RepairType == 'nuker')
                    task = t;
            }
            if (task) {
                task.Data.num = num;
                if (task.CreepBind['repair'].num != num)
                    task.CreepBind['repair'].num = num;
                if (task.Data.boostType == undefined && boostType == 'XLH2O') {
                    /* 删除现有任务，重新挂载有boost的任务 */
                    this.DeleteMission(task.id);
                }
            }
            /* 激活维修防核任务 */
            else {
                var thisTask = this.public_repair('nuker', num, boostType, 'T0');
                if (thisTask && allDamageNum > 0)
                    this.AddMission(thisTask);
            }
            /* 去除废除的维护坐标 例如核弹已经砸过了，但是还没有修完 */
            if ((Game.time - global.Gtime[this.name]) % 9 == 0)
                LoopP: for (var po in this.memory.nukeData.damage) {
                    var thisPos = unzipPosition(po);
                    for (var nuk of nuke_) {
                        if (thisPos.inRangeTo(nuk, 2))
                            continue LoopP;
                    }
                    if (this.memory.nukeData.rampart[po])
                        delete this.memory.nukeData.rampart[po];
                    delete this.memory.nukeData.damage[po];
                }
        }
        else {
            for (var m of this.memory.Misson['Creep']) {
                if (m.name == '墙体维护' && m.Data.RepairType == 'nuker') {
                    this.DeleteMission(m.id);
                }
            }
            if (this.memory.nukeID.length > 0)
                this.memory.nukeID = [];
            this.memory.nukeData = { damage: {}, rampart: {} };
        }
    }
    /* 主动防御任务发布 */
    Task_Auto_Defend() {
        if (this.memory.state == 'war') {
            // let s = Game.cpu.getUsed()
            this.Task_Defend_init();
            // let e = Game.cpu.getUsed()
            // console.log('初始化', e - s)
        }
        if ((Game.time - global.Gtime[this.name]) % 5)
            return;
        // if (!Game.rooms[this.name].terminal) return
        if (this.controller.level < 6)
            return;
        if (!this.memory.state)
            return;
        if (this.memory.state != 'war') {
            this.memory.switch.AutoDefend = false;
            this.memory.enemy = {};
            return;
        }
        /* 激活主动防御 */
        var enemys = this.find(FIND_HOSTILE_CREEPS, {
            filter: (creep) => {
                return !isInArray(Memory.whitesheet, creep.owner.username) && (creep.owner.username != 'Invader') && deserveDefend(creep);
            }
        });
        if (enemys.length <= 0) {
            this.memory.switch.AutoDefend = false;
            this.memory.enemy = {};
            return;
        }
        /* 如果有合成任务，删除合成任务 */
        // let compoundTask = this.MissionName('Room', '资源合成')
        // if (compoundTask) {
        //     this.DeleteMission(compoundTask.id)
        //     return
        // }
        if (!this.memory.switch.AutoDefend) {
            this.memory.switch.AutoDefend = true; // 表示房间存在主动防御任务
            /* 寻找攻击方 */
            let users = [];
            for (let c of enemys)
                if (!isInArray(users, c.owner.username))
                    users.push(c.owner.username);
            let str = '';
            for (let s of users)
                str += ` ${s}`;
            Game.notify(`房间${this.name}激活主动防御! 目前检测到的攻击方为:${str},爬虫数为:${enemys.length},我们将抗战到底!`);
            console.log(`房间${this.name}激活主动防御! 目前检测到的攻击方为:${str},爬虫数为:${enemys.length},我们将抗战到底!`);
            // if (str == ' Bulletproof' && enemys.length <= 1) {
            //     this.memory.switch.AutoDefend = false        // 表示房间存在主动防御任务
            //     return;
            // } else {
            // }
        }
        // console.log(JSON.stringify(enemys))
        /* 分析敌对爬虫的数量,应用不同的主防任务应对 */
        let hostileCreep = this.hostileCreep_atk(enemys);
        let defend_plan = {};
        if (enemys.length < 2 || hostileCreep < 600) // 1
         {
            defend_plan = { 'attack': 1, 'double': 0, 'range': 0 };
        }
        else if (enemys.length <= 2) // 2
         {
            defend_plan = { 'attack': 1, 'double': 0, 'range': 0 };
        }
        else if (enemys.length > 2 && enemys.length < 5) // 3-4
         {
            defend_plan = { 'attack': 2, 'double': 0, 'range': 0 };
        }
        else if (enemys.length >= 5 && enemys.length < 8) // 5-7
         {
            defend_plan = { 'attack': 3, 'double': 0, 'range': 0 };
        }
        else if (enemys.length >= 8) // >8     一般这种情况下各个类型的防御任务爬虫的数量都要调高
         {
            let attack_number = 2;
            if (global.HostileGroup[this.name].length > 4) {
                attack_number = global.HostileGroup[this.name].length;
                attack_number = attack_number > 6 ? 6 : attack_number;
            }
            defend_plan = { 'attack': attack_number, 'double': 2, 'range': 0 };
        }
        for (var plan in defend_plan) {
            switch (plan) {
                case 'attack':
                    var num = this.MissionNum('Creep', '红球防御');
                    if (num <= 0) {
                        let thisTask = this.public_red_defend(defend_plan[plan]);
                        if (thisTask) {
                            this.AddMission(thisTask);
                            console.log(`房间${this.name}红球防御任务激活!`, enemys.length);
                        }
                    }
                    else {
                        /* 已经存在的话查看数量是否正确 */
                        let task = this.MissionName('Creep', '红球防御');
                        if (task) {
                            task.CreepBind['defend-attack'].num = defend_plan[plan];
                            // console.log(Colorful(`房间${this.name}红球防御任务数量调整为${defend_plan[plan]}!`,'red'))
                        }
                    }
                    break;
                case 'range':
                    var num = this.MissionNum('Creep', '蓝球防御');
                    if (num <= 0) {
                        let thisTask = this.public_blue_defend(defend_plan[plan]);
                        if (thisTask) {
                            this.AddMission(thisTask);
                            console.log(`房间${this.name}蓝球防御任务激活!`, enemys.length);
                        }
                    }
                    else {
                        /* 已经存在的话查看数量是否正确 */
                        let task = this.MissionName('Creep', '蓝球防御');
                        if (task) {
                            task.CreepBind['defend-range'].num = defend_plan[plan];
                            // console.log(Colorful(`房间${this.name}蓝球防御任务数量调整为${defend_plan[plan]}!`,'blue'))
                        }
                    }
                    break;
                case 'double':
                    if (this.controller.level < 8) {
                        break;
                    }
                    var num = this.MissionNum('Creep', '双人防御');
                    if (num <= 0) {
                        let thisTask = this.public_double_defend(defend_plan[plan]);
                        if (thisTask) {
                            this.AddMission(thisTask);
                            console.log(`房间${this.name}双人防御任务激活!`, enemys.length);
                        }
                    }
                    else {
                        /* 已经存在的话查看数量是否正确 */
                        let task = this.MissionName('Creep', '双人防御');
                        if (task && !task.warstop) {
                            task.CreepBind['defend-douAttack'].num = defend_plan[plan];
                            task.CreepBind['defend-douHeal'].num = defend_plan[plan];
                            // console.log(Colorful(`房间${this.name}双人防御任务数量调整为${defend_plan[plan]}!`,'green'))
                        }
                    }
                    break;
            }
        }
        /* 主动防御分配系统更新 删除过期敌对爬虫数据 */
        for (let myCreepName in this.memory.enemy) {
            if (!Game.creeps[myCreepName])
                delete this.memory.enemy[myCreepName];
            else {
                /* 查找项目里的爬虫是否已经死亡 */
                for (let enemyID of this.memory.enemy[myCreepName]) {
                    if (!Game.getObjectById(enemyID)) {
                        let index = this.memory.enemy[myCreepName].indexOf(enemyID);
                        this.memory.enemy[myCreepName].splice(index, 1);
                    }
                }
            }
        }
    }
    hostileCreep_atk(nearCreep) {
        let all_atk = 0;
        for (let i in nearCreep) {
            var creeps_hostile = nearCreep[i];
            for (let boost_i in creeps_hostile.body) {
                let body_data = creeps_hostile.body[boost_i];
                switch (body_data.type) {
                    case 'attack':
                    case 'ranged_attack':
                        all_atk += this.attack_number(body_data.type, body_data.boost);
                        break;
                }
            }
        }
        return all_atk;
    }
    // public Get_Hostile_creeps_range(creep: Creep, range: number = 1): Creep | null {
    // }
    Get_HOSTILE_CREEPS() {
        if (global.HostileCreeps[this.name].length < 1) {
            var enemys = this.find(FIND_HOSTILE_CREEPS, {
                filter: (creep) => {
                    return !isInArray(Memory.whitesheet, creep.owner.username) && (creep.owner.username != 'Invader');
                }
            });
            global.HostileCreeps[this.name] = enemys;
            for (let creeps of enemys) {
                global.HostileCreepsData[creeps.name] = creeps;
            }
        }
        return global.HostileCreeps[this.name];
    }
    Task_Defend_init() {
        let duplicate_list = [];
        for (let creeps in this.memory.Enemydistribution) {
            if (!Memory.creeps[creeps]) {
                delete this.memory.Enemydistribution[creeps];
            }
            if (isInArray(duplicate_list, this.memory.Enemydistribution[creeps])) {
                delete this.memory.Enemydistribution[creeps];
            }
            duplicate_list.push(this.memory.Enemydistribution[creeps]);
        }
        /*开始进行矩阵计算*/
        let creep_team_list = {};
        var enemys = this.Get_HOSTILE_CREEPS();
        for (let HostileCeeps of enemys) {
            /*开始进行匹配操作*/
            HostileCeeps.pos;
            creep_team_list[HostileCeeps.name] = CheckCreepTeam(HostileCeeps, enemys);
        }
        /*二次数据加工检测四人队伍信息*/
        let _creep_list = [];
        let creep_team_result = [];
        for (let creep_name in creep_team_list) {
            if (isInArray(_creep_list, creep_name)) {
                continue;
            }
            /*检查KEY里面的爬是否均包含对应的爬信息*/
            switch (creep_team_list[creep_name].length) {
                case 4:
                case 2:
                case 1:
                    let _c_data = [];
                    for (let c_data of creep_team_list[creep_name]) {
                        _creep_list.push(c_data.name);
                        _c_data.push(c_data.name);
                    }
                    creep_team_result.push(_c_data);
                    break;
            }
        }
        for (let group of creep_team_result) {
            if (global.HostileCreepsData[group[0]]) {
                global.HostileGroup[this.name].push(global.HostileCreepsData[group[0]].id);
            }
        }
        // console.log('分组', creep_team_result.length, JSON.stringify(global.HostileGroup[this.name]))
        if (!global.HostileData[this.name])
            global.HostileData[this.name] = { time: Game.time, data: this.Task_Defend_Operation() };
        if (Game.time == global.HostileData[this.name].time)
            return; // 跳过
        else // 说明数据过时了，更新数据
         {
            global.HostileData[this.name].time = Game.time;
            global.HostileData[this.name].data = this.Task_Defend_Operation();
        }
    }
    /*敌人强度计算*/
    Task_Defend_Operation() {
        let _boost_attack = {
            'UH': 1,
            'KO': 1,
            'LO': 1,
            'UH2O': 2,
            'KHO2': 2,
            'LHO2': 2,
            'XUH2O': 3,
            'XKHO2': 3,
            'XLHO2': 3,
        };
        /*搜索所有的敌对爬的信息*/
        // var enemys = this.find(FIND_HOSTILE_CREEPS, {
        //     filter: (creep) => {
        //         return !isInArray(Memory.whitesheet, creep.owner.username) && (creep.owner.username != 'Invader')
        //     }
        // })
        var enemys = this.Get_HOSTILE_CREEPS();
        let Defend_Data = {};
        for (let HostileCeeps of enemys) {
            /*检查爬的攻防信息 包括奶量*/
            let attcak_body = 0;
            let ranged_attcak_body = 0;
            let heal_body = 0;
            for (let body of HostileCeeps.body) {
                let boost_num = 1;
                if (body.boost) {
                    boost_num += _boost_attack[body.boost];
                }
                switch (body.type) {
                    case 'attack':
                        attcak_body += boost_num;
                        break;
                    case 'ranged_attack':
                        ranged_attcak_body += boost_num;
                        break;
                    case 'heal':
                        heal_body += boost_num;
                        break;
                }
            }
            /*完成部位统计进行具体伤害的结算*/
            if (attcak_body > 0) {
                // console.log('搜索到attcak')
                /*获取有效范围同时进行伤害标记*/
                let get_Updatehurt = this.Updatehurt_atk(HostileCeeps.pos, 1, attcak_body * 30);
                for (let key in get_Updatehurt) {
                    Defend_Data = this.UpdateposData(key, get_Updatehurt[key], 0, 0, Defend_Data);
                }
            }
            if (ranged_attcak_body > 0) {
                // console.log('搜索到ranged_attcak')
                let get_Updatehurt = this.Updatehurt_atk(HostileCeeps.pos, 3, ranged_attcak_body * 10);
                for (let key in get_Updatehurt) {
                    Defend_Data = this.UpdateposData(key, 0, get_Updatehurt[key], 0, Defend_Data);
                }
            }
            if (heal_body > 0) {
                let get_Updatehurt = this.Updatehurt_heal(HostileCeeps.pos, 3, heal_body * 12);
                for (let key in get_Updatehurt) {
                    Defend_Data = this.UpdateposData(key, 0, 0, get_Updatehurt[key], Defend_Data);
                }
            }
        }
        // 
        // console.log(JSON.stringify(Defend_Data))
        return Defend_Data;
    }
    UpdateposData(key, attcak_number, ranged_attcak_number, heal_number, globaldata) {
        if (!globaldata[key])
            globaldata[key] = { attack: 0, rattack: 0, heal: 0, repair: 0 };
        if (attcak_number > 0) {
            globaldata[key].attack += attcak_number;
        }
        if (ranged_attcak_number > 0) {
            globaldata[key].rattack += ranged_attcak_number;
        }
        if (heal_number > 0) {
            globaldata[key].heal += heal_number;
        }
        return globaldata;
    }
    Updatehurt_heal(pos, range, hurt) {
        var a = -range;
        let _roomlist = {};
        for (var i = a; i <= range; i++) {
            for (var ii = a; ii <= range; ii++) {
                // console.log(i, ii)
                /*检查具体的距离*/
                let m_range = Math.max(Math.abs(i), Math.abs(ii));
                /*出坐标信息*/
                let x = pos.x + i;
                let y = pos.y + ii;
                let pos_ = `${x}/${y}`;
                // if (!global.warData.tower[pos.roomName].data[pos_]) { continue; }
                // console.log(pos_, '更新伤害', JSON.stringify(this[pos_]))
                switch (m_range) {
                    case 1:
                    case 0:
                        _roomlist[pos_] = hurt;
                        break;
                    case 2:
                    case 3:
                        _roomlist[pos_] = hurt / 3;
                        break;
                }
            }
        }
        return _roomlist;
    }
    Updatehurt_atk(pos, range, hurt) {
        var a = -range;
        let _roomlist = {};
        for (var i = a; i <= range; i++) {
            for (var ii = a; ii <= range; ii++) {
                // console.log(i, ii)
                /*检查具体的距离*/
                let m_range = Math.max(Math.abs(i), Math.abs(ii));
                /*出坐标信息*/
                let x = pos.x + i;
                let y = pos.y + ii;
                let pos_ = `${x}/${y}`;
                // if (!global.warData.tower[pos.roomName].data[pos_]) { continue; }
                // console.log(pos_, '更新伤害', JSON.stringify(this[pos_]))
                switch (m_range) {
                    case 1:
                    case 2:
                    case 3:
                        _roomlist[pos_] = hurt;
                        break;
                }
            }
        }
        return _roomlist;
    }
    attack_number(type, boost) {
        let _boost_attack = {
            'UH': 1,
            'KO': 1,
            'LO': 1,
            'UH2O': 2,
            'KHO2': 2,
            'LHO2': 2,
            'XUH2O': 3,
            'XKHO2': 3,
            'XLHO2': 3,
        };
        let _x = 1;
        if (_boost_attack[boost]) {
            _x += _boost_attack[boost];
        }
        let _number = 0;
        switch (type) {
            case 'attack':
                _number = _x * 30;
                break;
            case 'ranged_attack':
                _number = _x * 10;
                break;
            case 'heal':
                _number = _x * 12;
                break;
        }
        return _number;
    }
    /* 红球防御 */
    Task_Red_Defend(mission) {
        if ((Game.time - global.Gtime[this.name]) % 5)
            return;
        if (!this.Check_Lab(mission, 'transport', 'complex'))
            return;
        if ((Game.time - global.Gtime[this.name]) % 20)
            return;
        var enemys = this.find(FIND_HOSTILE_CREEPS, {
            filter: (creep) => {
                return !isInArray(Memory.whitesheet, creep.owner.username) && (creep.owner.username != 'Invader' && deserveDefend(creep));
            }
        });
        if (enemys.length <= 0) {
            mission.CreepBind['defend-attack'].num = 0; /*标记归零操作 待命*/
            //清理待孵化的列表
            if (mission.CreepBind['defend-attack'].bind.length < 1) {
                this.DeleteMission(mission.id);
            }
        }
    }
    /* 蓝球防御 */
    Task_Blue_Defend(mission) {
        if ((Game.time - global.Gtime[this.name]) % 5)
            return;
        if (!this.Check_Lab(mission, 'transport', 'complex'))
            return;
        if ((Game.time - global.Gtime[this.name]) % 20)
            return;
        var enemys = this.find(FIND_HOSTILE_CREEPS, {
            filter: (creep) => {
                return !isInArray(Memory.whitesheet, creep.owner.username) && (creep.owner.username != 'Invader' && deserveDefend(creep));
            }
        });
        if (enemys.length <= 0) {
            mission.CreepBind['defend-range'].num = 0; /*标记归零操作 待命*/
            if (mission.CreepBind['defend-range'].bind.length < 1) {
                this.DeleteMission(mission.id);
            }
        }
    }
    /* 双人防御 */
    Task_Double_Defend(mission) {
        if ((Game.time - global.Gtime[this.name]) % 5)
            return;
        if (mission.CreepBind['defend-douAttack'].num > 0 && mission.CreepBind['defend-douHeal'].num > 0) {
            if (!this.Check_Lab(mission, 'transport', 'complex'))
                return;
        }
        if ((Game.time - global.Gtime[this.name]) % 20)
            return;
        /*开始进行列表的纳入操作*/
        if (!mission.warlist)
            mission.warlist = {};
        if (mission.CreepBind['defend-douAttack'].bind.length > 0) {
            for (let creep_name of mission.CreepBind['defend-douAttack'].bind) {
                let creep_data = Game.creeps[creep_name];
                if (creep_data && !mission.warlist[creep_name]) {
                    let s_time = Game.time - creep_data.ticksToLive + 1500;
                    mission.warlist[creep_name] = s_time;
                }
            }
        }
        if (mission.CreepBind['defend-douHeal'].bind.length > 0) {
            for (let creep_name of mission.CreepBind['defend-douHeal'].bind) {
                let creep_data = Game.creeps[creep_name];
                if (creep_data && !mission.warlist[creep_name]) {
                    let s_time = Game.time - creep_data.ticksToLive + 1500;
                    mission.warlist[creep_name] = s_time;
                }
            }
        }
        /*检测已有爬的存活信息*/
        let system_time = 1500;
        let system_creep_number = 8;
        for (let creep_n in mission.warlist) {
            let creep_t = mission.warlist[creep_n];
            if (Game.time - system_time > creep_t) {
                delete mission.warlist[creep_n];
            }
        }
        if (Object.keys(mission.warlist).length > system_creep_number) {
            mission.warstop = true; /*终止出兵操作*/
        }
        if (mission.warstop) {
            mission.CreepBind['defend-douAttack'].num = 0;
            mission.CreepBind['defend-douHeal'].num = 0;
        }
        var enemys = this.find(FIND_HOSTILE_CREEPS, {
            filter: (creep) => {
                return !isInArray(Memory.whitesheet, creep.owner.username) && (creep.owner.username != 'Invader' && deserveDefend(creep));
            }
        });
        if (enemys.length <= 0) {
            mission.CreepBind['defend-douAttack'].num = 0;
            mission.CreepBind['defend-douHeal'].num = 0;
            if (mission.CreepBind['defend-douAttack'].bind.length < 1 && mission.CreepBind['defend-douHeal'].bind.length < 1) {
                this.DeleteMission(mission.id);
            }
        }
    }
}

/* power操作常量 */
// queen类型buff是否加持
function isOPWR(stru) {
    if (!stru.effects || stru.effects.length <= 0)
        return false;
    else {
        if (stru.structureType == 'tower') {
            if (!isInArray(getAllEffects(stru), PWR_OPERATE_TOWER))
                return false;
        }
        else if (stru.structureType == 'spawn') {
            if (!isInArray(getAllEffects(stru), PWR_OPERATE_SPAWN))
                return false;
        }
        else if (stru.structureType == 'extension') {
            if (!isInArray(getAllEffects(stru), PWR_OPERATE_EXTENSION))
                return false;
        }
        else if (stru.structureType == 'terminal') {
            if (!isInArray(getAllEffects(stru), PWR_OPERATE_TERMINAL))
                return false;
        }
        else if (stru.structureType == 'storage') {
            if (!isInArray(getAllEffects(stru), PWR_OPERATE_STORAGE))
                return false;
        }
        else if (stru.structureType == 'factory') {
            if (!isInArray(getAllEffects(stru), PWR_OPERATE_FACTORY))
                return false;
        }
        else if (stru.structureType == 'lab') {
            if (!isInArray(getAllEffects(stru), PWR_OPERATE_LAB))
                return false;
        }
        else if (stru.structureType == 'powerSpawn') {
            if (!isInArray(getAllEffects(stru), PWR_OPERATE_POWER))
                return false;
        }
    }
    return true;
}
function getAllEffects(stru) {
    if (!stru.effects || stru.effects.length <= 0)
        return [];
    var eff_list = [];
    for (var effect_ of stru.effects) {
        eff_list.push(effect_.effect);
    }
    return eff_list;
}

/* 超能powercreep相关任务 */
class PowerCreepMisson extends Room {
    /* Pc任务管理器 */
    PowerCreep_TaskManager() {
        if (this.controller.level < 8)
            return;
        var storage_ = this.storage;
        if (!storage_)
            return;
        var pc = Game.powerCreeps[`${this.name}/queen/${Game.shard.name}`];
        // console.log(this.name,`${this.name}/queen/${Game.shard.name}`,JSON.stringify(pc))
        if (!pc)
            return;
        else {
            /* 看看是否存活，没存活就孵化 */
            if (!pc.ticksToLive) {
                var pcspawn = Game.rooms[this.name].GetStructData('powerspawn');
                if (pcspawn) {
                    pc.spawn(pcspawn);
                    return;
                }
            }
        }
        this.enhance_storage(pc);
        this.enhance_lab(pc);
        this.enhance_extension(pc);
        this.enhance_spawn(pc);
        this.enhance_tower(pc);
        // this.enhance_factory()
        this.enhance_powerspawn(pc);
        this.enhance_source(pc);
    }
    /* 挂载增强storage的任务 适用于queen类型pc */
    enhance_storage(pc) {
        if ((Game.time - global.Gtime[this.name]) % 7)
            return;
        if (this.memory.switch.StopEnhanceStorage)
            return;
        var storage_ = this.storage;
        if (!storage_)
            return;
        if (storage_.store.getUsedCapacity() < 900000)
            return;
        if (!pc.powers[PWR_OPERATE_STORAGE] || pc.powers[PWR_OPERATE_STORAGE].cooldown)
            return;
        if (!storage_.effects)
            storage_.effects = [];
        if (!isOPWR(storage_) && this.MissionNum('PowerCreep', '仓库扩容') <= 0) {
            /* 发布任务 */
            var thisTask = {
                name: "仓库扩容",
                delayTick: 40,
                range: 'PowerCreep',
            };
            thisTask.CreepBind = { 'queen': { num: 1, bind: [] } };
            this.AddMission(thisTask);
        }
    }
    /* 挂载增强lab的任务 适用于queen类型pc */
    enhance_lab(pc) {
        if ((Game.time - global.Gtime[this.name]) % 10)
            return;
        if (this.memory.switch.StopEnhanceLab)
            return;
        var storage_ = this.storage;
        if (!storage_)
            return;
        if (!pc.powers[PWR_OPERATE_LAB] || pc.powers[PWR_OPERATE_LAB].cooldown)
            return;
        let disTask = this.MissionName('Room', '资源合成');
        if (!disTask)
            return;
        if (this.MissionNum('PowerCreep', '合成加速') > 0)
            return;
        let list = [];
        for (let id in this.memory.RoomLabBind) {
            let lab_data = this.memory.RoomLabBind[id];
            if (lab_data.type == 'com') {
                var lab_ = Game.getObjectById(id);
                if (lab_ && !isOPWR(lab_))
                    list.push(id);
            }
        }
        if (list.length <= 0)
            return;
        var thisTask = {
            name: "合成加速",
            delayTick: 50,
            range: 'PowerCreep',
            Data: {
                lab: list
            }
        };
        thisTask.CreepBind = { 'queen': { num: 1, bind: [] } };
        this.AddMission(thisTask);
    }
    /* 挂载防御塔任务 适用于queen类型pc 配合主动防御 */
    enhance_tower(pc) {
        if ((Game.time - global.Gtime[this.name]) % 11)
            return;
        if (this.memory.switch.StopEnhanceTower)
            return;
        var storage_ = this.storage;
        if (!storage_)
            return;
        if (!pc.powers[PWR_OPERATE_TOWER] || pc.powers[PWR_OPERATE_TOWER].cooldown)
            return;
        if (this.memory.state == 'war' && this.memory.switch.AutoDefend) {
            let towers_list = [];
            if (this.memory.StructureIdData.AtowerID.length > 0)
                for (var o of this.memory.StructureIdData.AtowerID) {
                    var otower = Game.getObjectById(o);
                    if (otower && !isOPWR(otower)) {
                        towers_list.push(otower.id);
                    }
                }
            if (towers_list.length <= 0 || this.MissionNum('PowerCreep', '塔防增强') > 0)
                return;
            /* 发布任务 */
            var thisTask = {
                name: "塔防增强",
                delayTick: 70,
                range: 'PowerCreep',
                Data: {
                    tower: towers_list
                }
            };
            thisTask.CreepBind = { 'queen': { num: 1, bind: [] } };
            this.AddMission(thisTask);
        }
    }
    /* 挂载填充拓展任务 适用于queen类型pc */
    enhance_extension(pc) {
        if ((Game.time - global.Gtime[this.name]) % 25)
            return;
        if (this.memory.switch.StopEnhanceExtension)
            return;
        var storage_ = this.storage;
        if (!storage_ || storage_.store.getUsedCapacity('energy') < 20000)
            return;
        if (!pc.powers[PWR_OPERATE_EXTENSION] || pc.powers[PWR_OPERATE_EXTENSION].cooldown)
            return;
        if (this.energyAvailable < this.energyCapacityAvailable * 0.5 && this.MissionNum('PowerCreep', '拓展填充') <= 0) {
            var thisTask = {
                name: "扩展填充",
                delayTick: 30,
                range: 'PowerCreep',
                Data: {}
            };
            thisTask.CreepBind = { 'queen': { num: 1, bind: [] } };
            this.AddMission(thisTask);
        }
    }
    /* 挂载spawn加速任务 适用于queen类型pc */
    enhance_spawn(pc) {
        if ((Game.time - global.Gtime[this.name]) % 13)
            return;
        if (this.memory.switch.StopEnhanceSpawn)
            return;
        var storage_ = this.storage;
        if (!storage_)
            return;
        if (!pc.powers[PWR_OPERATE_SPAWN] || pc.powers[PWR_OPERATE_SPAWN].cooldown)
            return;
        // 在战争时期、对外战争时期，启动
        var ssss = false;
        let list = ['攻防一体', '双人小队', '四人小队', '紧急支援'];
        for (let i of list)
            if (this.MissionNum('Creep', i) > 0)
                ssss = true;
        if (this.memory.state == 'war' && this.memory.switch.AutoDefend)
            ssss = true;
        if (ssss) {
            var thisTask = {
                name: "虫卵强化",
                delayTick: 50,
                range: 'PowerCreep',
                Data: {}
            };
            thisTask.CreepBind = { 'queen': { num: 1, bind: [] } };
            this.AddMission(thisTask);
        }
    }
    /* 挂载升级工厂任务 适用于queen类型pc */
    enhance_factory(force = false) {
        if ((Game.time - global.Gtime[this.name]) % 15 && !force)
            return;
        if (this.memory.switch.StopEnhanceFactory)
            return;
        var storage_ = this.storage;
        if (!storage_)
            return;
        let pc = Game.powerCreeps[`${this.name}/queen/${Game.shard.name}`];
        if (!pc || !pc.powers[PWR_OPERATE_FACTORY] || pc.powers[PWR_OPERATE_FACTORY].cooldown)
            return;
        if (this.MissionNum("PowerCreep", '工厂强化') > 0)
            return;
        var thisTask = {
            name: "工厂强化",
            delayTick: 50,
            range: 'PowerCreep',
            Data: {}
        };
        thisTask.CreepBind = { 'queen': { num: 1, bind: [] } };
        this.AddMission(thisTask);
    }
    /* 挂载powerspawn增强任务 适用于queen类型pc */
    enhance_powerspawn(pc) {
        if ((Game.time - global.Gtime[this.name]) % 13)
            return;
        if (this.memory.switch.StopEnhancePowerSpawn)
            return;
        var storage_ = this.storage;
        if (!storage_)
            return;
        if (!pc.powers[PWR_OPERATE_POWER] || pc.powers[PWR_OPERATE_POWER].cooldown)
            return;
        if (this.MissionNum("PowerCreep", 'power升级') > 0)
            return;
        var thisTask = {
            name: "power强化",
            delayTick: 50,
            range: 'PowerCreep',
            Data: {}
        };
        thisTask.CreepBind = { 'queen': { num: 1, bind: [] } };
        this.AddMission(thisTask);
    }
    /*挂载source再生任务 适用于queen类型pc */
    enhance_source(pc) {
        if ((Game.time - global.Gtime[this.name]) % 6)
            return;
        if (this.memory.switch.StopEnhanceSource)
            return;
        if (!this.memory.StructureIdData.source)
            return;
        if (!pc.powers[PWR_REGEN_SOURCE] || pc.powers[PWR_REGEN_SOURCE].cooldown)
            return;
        if (this.MissionNum("PowerCreep", 'source强化') > 0)
            return;
        for (let i in this.memory.StructureIdData.source) {
            let _source_data = Game.getObjectById(this.memory.StructureIdData.source[i]);
            if (!_source_data) {
                continue;
            }
            if (_source_data.effects) {
                if (_source_data.effects.length > 0) {
                    continue;
                }
            }
            var thisTask = {
                name: "source强化",
                delayTick: 50,
                range: 'PowerCreep',
                Data: {
                    source_id: _source_data.id
                },
                maxTime: 2
            };
            thisTask.CreepBind = { 'queen': { num: 1, bind: [] } };
            this.AddMission(thisTask);
        }
    }
}

// 定义好挂载顺序
const plugins$2 = [
    RoomCoreInitExtension,
    RoomFunctionFindExtension,
    RoomCoreSpawnExtension,
    RoomCoreEcosphereExtension,
    RoomMissonFrameExtension,
    RoomMissonPublish,
    RoomFunctionTowerExtension,
    RoomMissonBehaviourExtension,
    RoomMissonTransportExtension,
    RoomMissonVindicateExtension,
    NormalWarExtension$1,
    NormalWarExtension,
    RoomMissonManageExtension,
    RoomMissonDefendExtension$1,
    RoomMissonMineExtension,
    RoomMissonDefendExtension,
    DefendWarExtension,
    PowerCreepMisson,
];
/**
* 依次挂载所有的拓展
*/
var mountRoom = () => plugins$2.forEach(plugin => assignPrototype(Room, plugin));

const signConstant = [
    '人声鼎沸怅，寂寥无人嗅。弱冠铭难忘，镜湖难泛舟。',
    '少年不识愁滋味，爱上层楼。爱上层楼，为赋新词强说愁。',
    '抽刀断水水更流，举杯销愁愁更愁。',
    '最是人间留不住，朱颜辞镜花辞树。',
    '君埋泉下泥销骨，我寄人间雪满头。',
    '赠你一绸星河 错落人间烟火',
    '遇见你那天，樱花开满南山。',
    '终有弱水替沧海，再无相思寄巫山。',
    '太阳可维修，月亮可更换，星星不好包退换。',
    '火车飞驰去往远方，两边黄灿灿的庄稼徐徐退后，我离家一百里又一百里。',
    '小舟从此逝，江海寄馀生。',
    '人间百年，忽如一梦。',
    '岁月涌入人潮 而我只敢问今朝。',
    '明天会有好天气和好运气。',
    '人们拒绝了这种悲哀，向天空举起彩色的盾牌。',
    '一杯杰克·威尔斯，我请。',
    '不要走进那温顺的良夜。',
    '三月的最后一天，我最喜欢的月份即将过去了，希望明年三月我带你们去看城南花开！城南花已开，花开花落时！',
    '是继续走下去，还是停止在现在？',
    '对花对酒，落梅成愁。十里长亭水悠悠。',
    '揽月入怀，醉酒溺江，骑鲸化仙。',
    '我与春风皆过客，她携秋月揽星河。',
    '噩梦并不受逻辑的控制，而且如果噩梦能够解释，反会失去原有的趣味，因为噩梦和恐惧的艺术是相互对立的。',
    '谁都不希望原地踏步，困在过去。他们想要改变，他们，还有这个世界。可改变个屁，“全新的交互方式，全新的高果糖糖浆，还带不同的水果口味"',
    '老实说，蟑螂披萨的味道还挺香的。呃，我是指，你们有钱人从来没吃过的那种。',
    '夜之城没有活着的传奇！',
    '我们的征途是星辰大海！',
    '那不朽的并非逝者，亘古中连死亡也会湮灭。',
    '有朝一日，利剑出鞘，锋芒毕露。',
    '世界属于三体！',
    '无名小卒，还是名扬天下？',
    '致命错误......',
    'mofeng说:来丶二次元。'
];
function randomRange(lowerValue, upperValue) {
    let total = upperValue - lowerValue + 1;
    return Math.floor(Math.random() * total + lowerValue);
}
function randomSign() {
    let length = signConstant.length;
    let index = randomRange(0, length - 1);
    if (index < 0)
        index = 0;
    if (index >= signConstant.length)
        index = signConstant.length - 1;
    return signConstant[index];
}

var actionExtension = {
    /* 修墙 */
    repair: {
        set(roomName, rtype, num, boost, level, maxhit, retain) {
            let thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[repair] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Creep'])
                if (i.name == '墙体维护' && i.Data.RepairType == rtype) {
                    return `[repair] 房间${roomName}已经存在类型为${rtype}的刷墙任务了`;
                }
            var thisTask = thisRoom.public_repair(rtype, num, boost, level ? level : 'T0', maxhit ? maxhit : 300000000, retain ? retain : false);
            if (thisRoom.AddMission(thisTask))
                return `[repair] 房间${roomName}挂载类型为${rtype}刷墙任务成功`;
            return `[repair] 房间${roomName}挂载类型为${rtype}刷墙任务失败`;
        },
        remove(roomName, Rtype) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[repair] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Creep'])
                if (i.name == '墙体维护' && i.Data.RepairType == Rtype) {
                    if (thisRoom.DeleteMission(i.id))
                        return `[repair] 房间${roomName}删除类型为${Rtype}刷墙任务成功`;
                }
            return `[repair] 房间${roomName}删除类型为${Rtype}刷墙任务失败!`;
        },
        removeall(Rtype) {
            return `[repair] 删除类型为${Rtype}刷墙任务失败!`;
        }
    },
    /* 特殊计划 不在manual里显示 */
    plan: {
        // C计划
        C(roomName, disRoom, Cnum, Unum, shard = Game.shard.name) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[plan] 不存在房间${roomName}`;
            let task = thisRoom.public_planC(disRoom, Cnum, Unum, shard);
            if (thisRoom.AddMission(task))
                return Colorful$1(`[plan] 房间${roomName}挂载C计划成功 -> ${disRoom}`, 'green');
            return Colorful$1(`[plan] 房间${roomName}挂载C计划失败 -> ${disRoom}`, 'red');
        },
        CC(roomName) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[plan] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Creep'])
                if (i.name == 'C计划') {
                    if (thisRoom.DeleteMission(i.id))
                        return Colorful$1(`[plan] 房间${roomName}删除C计划成功`, 'green');
                }
            return Colorful$1(`[plan] 房间${roomName}删除C计划失败`, 'red');
        },
        // Z计划 
        Z(roomName, disRoom, num) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[plan] 不存在房间${roomName}`;
            var thisTask = thisRoom.public_Send(disRoom, 'Z', num);
            /* 查看资源是否足够 */
            var terminal_ = thisRoom.terminal;
            var storage_ = thisRoom.storage;
            if (!terminal_ || !storage_) {
                return Colorful$1(`[terminal] 房间${roomName}不存在终端/仓房或记忆未更新！`, 'red', true);
            }
            /* 查询其他资源传送任务中是否有一样的资源 */
            var Num = 0;
            if (!thisRoom.memory.Misson['Structure'])
                thisRoom.memory.Misson['Structure'] = [];
            for (var tM of thisRoom.memory.Misson['Structure']) {
                if (tM.name == '资源传送' && tM.Data.rType == 'Z')
                    Num += tM.Data.num;
            }
            /* 计算资源是否满足 */
            if (terminal_.store.getUsedCapacity('Z') + storage_.store.getUsedCapacity('Z') - Num < num)
                return Colorful$1(`[plan] 房间${roomName} 资源${'Z'} 数量总合少于 ${num},Z计划挂载失败!`, 'yellow', true);
            /* 计算路费 */
            var cost = Game.market.calcTransactionCost(num, roomName, disRoom);
            if (terminal_.store.getUsedCapacity('energy') + storage_.store.getUsedCapacity('energy') < cost || cost > 150000)
                return Colorful$1(`[plan] 房间${roomName}-->${disRoom}资源${'Z'}所需路费少于 ${cost}或大于150000, 传送任务挂载失败！`, 'yellow', true);
            if (thisRoom.AddMission(thisTask))
                return Colorful$1(`[plan] 房间${roomName}-->${disRoom}资源${'Z'}传送挂载成功！数量：${num}；路费：${cost}`, 'green', true);
            return Colorful$1(`[plan] 房间${roomName}-->${disRoom}资源${'Z'}传送 不明原因挂载失败！`, 'red', true);
        }
    },
    /* 扩张 */
    expand: {
        set(roomName, disRoom, shard, num, Cnum = 1, level, shardData) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[expand] 不存在房间${roomName}`;
            let task = thisRoom.public_expand(disRoom, shard, num, Cnum, level);
            if (task) {
                if (shardData)
                    task.Data.shardData = shardData;
                if (thisRoom.AddMission(task))
                    return Colorful$1(`[expand] 房间${roomName}挂载扩张援建计划成功 -(${shard})-> ${disRoom}`, 'green');
            }
            return Colorful$1(`[expand] 房间${roomName}挂载扩张援建计划失败 -(${shard})-> ${disRoom}`, 'red');
        },
        remove(roomName, disRoom, shard) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[expand] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Creep'])
                if (i.name == '扩张援建' && i.Data.disRoom == disRoom) {
                    if (thisRoom.DeleteMission(i.id))
                        return Colorful$1(`[expand] 房间${roomName}删除去往${disRoom}(${shard})的扩张援建任务成功`, 'green');
                }
            return Colorful$1(`[expand] 房间${roomName}删除去往${disRoom}(${shard})的扩张援建任务失败`, 'red');
        },
    },
    /* 战争 */
    war: {
        dismantle(roomName, disRoom, shard, num, interval, boost, shardData) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[war] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Creep'])
                if (i.name == '黄球拆迁' && i.Data.disRoom == disRoom && i.Data.shard == shard) {
                    return `[war] 房间${roomName}已经存在去往${disRoom}(${shard})的该类型任务了!`;
                }
            let interval_ = interval ? interval : 1000;
            let task = thisRoom.public_dismantle(disRoom, shard, num, interval_, boost);
            if (task) {
                if (shardData)
                    task.Data.shardData = shardData;
                if (thisRoom.AddMission(task))
                    return Colorful$1(`[war] 房间${roomName}挂载拆迁任务成功 -> ${disRoom}`, 'green');
            }
            return Colorful$1(`[war] 房间${roomName}挂载拆迁任务失败 -> ${disRoom}`, 'red');
        },
        Cdismantle(roomName, disRoom, shard = Game.shard.name) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[war] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Creep']) {
                if (i.name == '黄球拆迁' && i.Data.disRoom == disRoom && i.Data.shard == shard) {
                    if (thisRoom.DeleteMission(i.id))
                        return Colorful$1(`[plan] 房间${roomName}删除拆迁任务成功`, 'green');
                }
            }
            return Colorful$1(`[war] 房间${roomName}删除拆迁任务失败`, 'red');
        },
        support(roomName, disRoom, shard, sType, num, interval = 1000, boost = true, shardData) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[war] 不存在房间${roomName}`;
            if (thisRoom.controller.level < 8)
                return `[war] 房间${roomName}控制器等级过低,请在8级后使用`;
            for (var oi of thisRoom.memory.Misson['Creep'])
                if (oi.name == '紧急支援' && oi.Data.disRoom == disRoom && oi.Data.shard == shard) {
                    return `[war] 房间${roomName}已经存在去往${disRoom}(${shard})的该类型任务了!`;
                }
            let task = thisRoom.public_support(disRoom, sType, shard, num, boost);
            if (task) {
                if (shardData)
                    task.Data.shardData = shardData;
                for (var i in task.CreepBind)
                    task.CreepBind[i].interval = interval;
            }
            if (thisRoom.AddMission(task))
                return Colorful$1(`[war] 房间${roomName}挂载紧急支援任务成功 -(${shard})-> ${disRoom},类型为${sType},数量为${num},间隔时间${interval}`, 'green');
            return Colorful$1(`[war] 房间${roomName}挂载紧急支援任务失败 -(${shard})-> ${disRoom}`, 'red');
        },
        Csupport(roomName, disRoom, shard, rType) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[war] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Creep']) {
                if (i.name == '紧急支援' && i.Data.disRoom == disRoom && i.Data.sType == rType && i.Data.shard == shard) {
                    if (thisRoom.DeleteMission(i.id))
                        return Colorful$1(`[war] 房间${roomName}-(${shard})->${disRoom}|[${rType}]紧急支援任务删除成功`, 'green');
                }
            }
            return Colorful$1(`[war] 房间${roomName}-(${shard})->${disRoom}|[${rType}]紧急支援任务删除失败`, 'red');
        },
        control(roomName, disRoom, shard = Game.shard.name, interval, shardData) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[war] 不存在房间${roomName}`;
            if (thisRoom.controller.level < 8)
                return `[war] 房间${roomName}控制器等级过低,请在8级后使用`;
            for (var oi of thisRoom.memory.Misson['Creep'])
                if (oi.name == '控制攻击' && oi.Data.disRoom == disRoom && oi.Data.shard == shard) {
                    return `[war] 房间${roomName}已经存在去往${disRoom}(${shard})的该类型任务了!`;
                }
            let task = thisRoom.public_control(disRoom, shard, interval);
            if (task) {
                if (shardData)
                    task.Data.shardData = shardData;
                if (thisRoom.AddMission(task))
                    return Colorful$1(`[war] 房间${roomName}挂载控制攻击任务成功 -> ${disRoom}`, 'green');
            }
            return Colorful$1(`[war] 房间${roomName}挂载控制攻击任务失败 -> ${disRoom}`, 'red');
        },
        Ccontrol(roomName, disRoom, shard = Game.shard.name) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[war] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Creep']) {
                if (i.name == '控制攻击' && i.Data.disRoom == disRoom && i.Data.shard == shard) {
                    if (thisRoom.DeleteMission(i.id))
                        return Colorful$1(`[war] 房间${roomName}控制攻击任务删除成功`, 'green');
                }
            }
            return Colorful$1(`[war] 房间${roomName}控制攻击任务删除失败`, 'red');
        },
        aio(roomName, disRoom, shard, CreepNum, time = 1000, boost = true, bodylevel = "T0", shardData) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[war] 未找到房间${roomName},请确认房间!`;
            if (myRoom.controller.level < 6)
                return `[war] 房间${roomName}控制器等级过低,请在6级后使用`;
            for (var oi of myRoom.memory.Misson['Creep'])
                if (oi.name == '攻防一体' && oi.Data.disRoom == disRoom && oi.Data.shard == shard) {
                    return `[war] 房间${roomName}已经存在去往${disRoom}(${shard})的该类型任务了!`;
                }
            var thisTask = myRoom.public_aio(disRoom, shard, CreepNum, time, boost, bodylevel);
            if (thisTask) {
                if (shardData)
                    thisTask.Data.shardData = shardData;
                if (myRoom.AddMission(thisTask))
                    return `[war] 攻防一体任务挂载成功! ${Game.shard.name}/${roomName} -> ${shard}/${disRoom} 体型等级:${bodylevel}`;
            }
            return `[war] 攻防一体挂载失败!`;
        },
        Caio(roomName, disRoom, shard) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[support] 未找到房间${roomName},请确认房间!`;
            for (var i of myRoom.memory.Misson['Creep']) {
                if (i.name == '攻防一体' && i.Data.disRoom == disRoom && i.Data.shard == shard) {
                    if (myRoom.DeleteMission(i.id))
                        return `[war] 删除去往${shard}/${disRoom}的攻防一体任务成功!`;
                }
            }
            return `[war] 删除去往${shard}/${disRoom}的攻防一体任务失败!`;
        },
        squad(roomName, disRoom, shard, mtype, time = 1000, shardData) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[war] 未找到房间${roomName},请确认房间!`;
            if (myRoom.controller.level < 8)
                return `[war] 房间${roomName}控制器等级过低,请在8级后使用`;
            for (var oi of myRoom.memory.Misson['Creep'])
                if (oi.name == '四人小队' && oi.Data.disRoom == disRoom && oi.Data.shard == shard && oi.Data.flag == mtype) {
                    return `[war] 房间${roomName}已经存在去往${disRoom}(${shard})的<${mtype}>四人小队任务了!`;
                }
            let thisTask;
            if (mtype == 'R') {
                thisTask = myRoom.public_squad(disRoom, shard, time, 2, 0, 0, 2, 0, mtype);
            }
            else if (mtype == 'A') {
                thisTask = myRoom.public_squad(disRoom, shard, time, 0, 2, 0, 2, 0, mtype);
            }
            else if (mtype == 'D') {
                thisTask = myRoom.public_squad(disRoom, shard, time, 0, 0, 2, 2, 0, mtype);
            }
            else if (mtype == 'Aio') {
                thisTask = myRoom.public_squad(disRoom, shard, time, 0, 0, 0, 0, 4, mtype);
            }
            else if (mtype == 'RA') {
                thisTask = myRoom.public_squad(disRoom, shard, time, 1, 1, 0, 2, 0, mtype);
            }
            else if (mtype == 'DA') {
                thisTask = myRoom.public_squad(disRoom, shard, time, 0, 1, 1, 2, 0, mtype);
            }
            else if (mtype == 'DR') {
                thisTask = myRoom.public_squad(disRoom, shard, time, 1, 0, 1, 2, 0, mtype);
            }
            if (thisTask) {
                if (shardData)
                    thisTask.Data.shardData = shardData;
                if (myRoom.AddMission(thisTask))
                    return `[war] 四人小队任务挂载成功! ${Game.shard.name}/${roomName} -> ${shard}/${disRoom}`;
            }
            return `[war] 四人小队挂载失败!`;
        },
        Csquad(roomName, disRoom, shard, mtype) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[war] 未找到房间${roomName},请确认房间!`;
            for (var i of myRoom.memory.Misson['Creep']) {
                if (i.name == '四人小队' && i.Data.disRoom == disRoom && i.Data.shard == shard && i.Data.flag == mtype) {
                    if (myRoom.DeleteMission(i.id))
                        return `[war] 删除去往${shard}/${disRoom}的四人小队任务成功!`;
                }
            }
            return `[war] 删除去往${shard}/${disRoom}的四人小队任务失败!`;
        },
        double(roomName, disRoom, shard = Game.shard.name, mType, num, interval, shardData) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[war] 不存在房间${roomName}`;
            if (thisRoom.controller.level < 6)
                return `[war] 房间${roomName}控制器等级过低,请在6级后使用`;
            for (var oi of thisRoom.memory.Misson['Creep'])
                if (oi.name == '双人小队' && oi.Data.disRoom == disRoom && oi.Data.shard == shard) {
                    return `[war] 房间${roomName}已经存在去往${disRoom}(${shard})的该类型任务了!`;
                }
            var thisTask = thisRoom.public_Double(disRoom, shard, num, mType, interval);
            if (thisTask) {
                if (shardData)
                    thisTask.Data.shardData = shardData;
                thisTask.maxTime = 2;
                if (thisRoom.AddMission(thisTask))
                    return `[war] 双人小队 ${roomName} -> ${disRoom} 的 ${mType}任务挂载成功！`;
            }
            return `[war] 双人小队 ${roomName} -(${shard})-> ${disRoom} 的 ${mType}任务挂载失败！`;
        },
        Cdouble(roomName, disRoom, shard, mType) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[war] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Creep']) {
                if (i.name == "双人小队" && i.Data.disRoom == disRoom && i.Data.teamType == mType && i.Data.shard == shard) {
                    if (thisRoom.DeleteMission(i.id))
                        return `[war] 双人小队 ${roomName} -(${shard})-> ${disRoom} 的 ${mType}任务删除成功！`;
                }
            }
            return `[war] 双人小队 ${roomName} -(${shard})-> ${disRoom} 的 ${mType}任务删除失败！`;
        },
        site(roomName, disRoom, shard, CreepNum, time = 1000, boost = true, bodylevel = "T0", shardData) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[war] 未找到房间${roomName},请确认房间!`;
            for (var oi of myRoom.memory.Misson['Creep'])
                if (oi.name == '踩工地' && oi.Data.disRoom == disRoom && oi.Data.shard == shard) {
                    return `[war] 房间${roomName}已经存在去往${disRoom}(${shard})的该类型任务了!`;
                }
            var thisTask = myRoom.public_cconstruction(disRoom, shard, CreepNum, time, boost, bodylevel);
            if (thisTask) {
                if (shardData)
                    thisTask.Data.shardData = shardData;
                if (myRoom.AddMission(thisTask))
                    return `[war] 踩工地任务挂载成功! ${Game.shard.name}/${roomName} -> ${shard}/${disRoom} 体型等级:${bodylevel}`;
            }
            return `[war] 踩工地挂载失败!`;
        },
        Csite(roomName, disRoom, shard) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[support] 未找到房间${roomName},请确认房间!`;
            for (var i of myRoom.memory.Misson['Creep']) {
                if (i.name == '踩工地' && i.Data.disRoom == disRoom && i.Data.shard == shard) {
                    if (myRoom.DeleteMission(i.id))
                        return `[war] 删除去往${shard}/${disRoom}的踩工地任务成功!`;
                }
            }
            return `[war] 删除去往${shard}/${disRoom}的踩工地任务失败!`;
        },
    },
    /* 升级 */
    upgrade: {
        quick(roomName, num, boostType) {
            let thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[upgrade] 不存在房间${roomName}`;
            var thisTask = thisRoom.public_quick(num, boostType);
            if (thisTask && thisRoom.AddMission(thisTask))
                return `[upgrade] 房间${roomName}挂载急速冲级任务成功`;
            return `[upgrade] 房间${roomName}挂载急速冲级任务失败`;
        },
        Cquick(roomName) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[repair] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Creep'])
                if (i.name == '急速冲级') {
                    if (thisRoom.DeleteMission(i.id))
                        return `[upgrade] 房间${roomName}删除急速冲级任务成功`;
                }
            return `[upgrade] 房间${roomName}删除急速冲级任务失败!`;
        },
        Nquick(roomName, num) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[repair] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Creep'])
                if (i.name == '急速冲级') {
                    i.CreepBind['rush'].num = num;
                    return `[upgrade] 房间${roomName}急速冲级任务数量修改为${num}`;
                }
            return `[upgrade] 房间${roomName}修改急速冲级任务数量失败!`;
        },
        normal(roomName, num, boostType) {
            let thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[upgrade] 不存在房间${roomName}`;
            var thisTask = thisRoom.public_normal(num, boostType);
            if (thisTask && thisRoom.AddMission(thisTask))
                return `[upgrade] 房间${roomName}挂载普通冲级任务成功`;
            return `[upgrade] 房间${roomName}挂载普通冲级任务失败`;
        },
        Cnormal(roomName) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[repair] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Creep'])
                if (i.name == '普通冲级') {
                    if (thisRoom.DeleteMission(i.id))
                        return `[upgrade] 房间${roomName}删除普通冲级任务成功`;
                }
            return `[upgrade] 房间${roomName}删除普通冲级任务失败!`;
        },
        adaptive(roomName, boolean) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[repair] 不存在房间${roomName}`;
            thisRoom.memory.DynamicConfig.Dynamicupgrade = boolean;
            if (boolean) {
                return `[upgrade] 房间${roomName}启用动态升级!`;
            }
            return `[upgrade] 房间${roomName}关闭动态升级!`;
        },
    },
    /* 搬运 */
    carry: {
        special(roomName, res, sPF, dPF, CreepNum, ResNum) {
            let thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[carry] 不存在房间${roomName}`;
            if (!Game.flags[sPF] || !Game.flags[dPF])
                return `[carry] 旗帜错误,请检查是否有相应旗帜`;
            let sP = Game.flags[sPF].pos;
            let dP = Game.flags[dPF].pos;
            let time = 99999;
            if (!ResNum)
                time = 30000;
            var thisTask = thisRoom.public_Carry({ 'truck': { num: CreepNum ? CreepNum : 1, bind: [] } }, time, sP.roomName, sP.x, sP.y, dP.roomName, dP.x, dP.y, res, ResNum ? ResNum : undefined);
            if (thisRoom.AddMission(thisTask))
                return `[carry] 房间${roomName}挂载special搬运任务成功`;
            return `[carry] 房间${roomName}挂载special搬运任务失败`;
        },
        all(roomName, sPF, dPF, CreepNum, st) {
            let thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[carry] 不存在房间${roomName}`;
            if (!Game.flags[sPF] || !Game.flags[dPF])
                return `[carry] 旗帜错误,请检查是否有相应旗帜`;
            let sP = Game.flags[sPF].pos;
            let dP = Game.flags[dPF].pos;
            var thisTask = thisRoom.public_Carry({ 'truck': { num: CreepNum ? CreepNum : 1, bind: [] } }, 50000, sP.roomName, sP.x, sP.y, dP.roomName, dP.x, dP.y);
            if (st)
                thisTask.Data.st = st;
            if (thisRoom.AddMission(thisTask))
                return `[carry] 房间${roomName}挂载all搬运任务成功`;
            return `[carry] 房间${roomName}挂载all搬运任务失败`;
        },
        cancel(roomName) {
            let thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[carry] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Creep'])
                if (i.name == '物流运输' && i.CreepBind['truck']) {
                    if (thisRoom.DeleteMission(i.id))
                        return `[carry] 房间${roomName}删除搬运任务成功`;
                }
            return `[carry] 房间${roomName}删除搬运任务失败`;
        },
        shard(roomName, disRoom, shard = Game.shard.name, res, CreepNum, interval, level, shardData) {
            let thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[carry] 不存在房间${roomName}`;
            var thisTask = thisRoom.public_Carryshard(disRoom, CreepNum, shard, res, interval, level);
            if (shardData)
                thisTask.Data.shardData = shardData;
            if (thisRoom.AddMission(thisTask))
                return `[carry] 房间${roomName}挂载位面搬运任务成功`;
            return `[carry] 房间${roomName}挂载位面搬运任务失败`;
        },
        Cshard(roomName, disRoom, shard = Game.shard.name) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[carry] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Creep']) {
                if (i.name == '位面运输' && i.Data.disRoom == disRoom && i.Data.shard == shard) {
                    if (thisRoom.DeleteMission(i.id))
                        return Colorful$1(`[carry] 房间${roomName}位面搬运删除成功`, 'green');
                }
            }
            return Colorful$1(`[carry] 房间${roomName}位面搬运任务删除失败`, 'red');
        },
        gleaner(roomName, disRoom, CreepNum, suicide, interval, level) {
            let thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[carry] 不存在房间${roomName}`;
            var thisTask = thisRoom.public_Carrygleaner(disRoom, CreepNum, suicide, interval, level);
            if (thisRoom.AddMission(thisTask))
                return `[carry] 房间${roomName}挂载拾荒者任务成功`;
            return `[carry] 房间${roomName}挂载拾荒者任务失败`;
        },
        Cgleaner(roomName) {
            let thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[carry] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Creep'])
                if (i.name == '拾荒者') {
                    if (thisRoom.DeleteMission(i.id))
                        return `[upgrade] 房间${roomName}删除拾荒者任务成功`;
                }
            return `[carry] 房间${roomName}删除拾荒者任务失败`;
        },
        mine(roomName, disRoom, creepNum, level) {
            let thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[carry] 不存在房间${roomName}`;
            var thisTask = thisRoom.public_Carrymine(disRoom, (creepNum ? creepNum : 1), level);
            if (thisRoom.AddMission(thisTask))
                return `[carry] 房间${roomName}挂载外矿偷取任务成功`;
            return `[carry] 房间${roomName}挂载外矿偷取任务失败`;
        },
        Cmine(roomName) {
            let thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[carry] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Creep'])
                if (i.name == '外矿偷取') {
                    if (thisRoom.DeleteMission(i.id))
                        return `[upgrade] 房间${roomName}删除外矿偷取任务成功`;
                }
            return `[carry] 房间${roomName}删除外矿偷取任务失败`;
        },
    },
    /* 支援 */
    support: {
        // 紧急援建
        build(roomName, disRoom, shard = Game.shard.name, num, interval, defend = false, shardData) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[support] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Creep']) {
                if (i.name == '紧急援建' && i.Data.disRoom == disRoom && i.Data.shard == shard) {
                    return Colorful$1(`[support] 房间${roomName}紧急援建任务存在重复任务`, 'green');
                }
            }
            let task = thisRoom.public_helpBuild(disRoom, num, shard, interval, defend);
            if (task) {
                if (shardData)
                    task.Data.shardData = shardData;
                if (thisRoom.AddMission(task))
                    return Colorful$1(`[support] 房间${roomName}挂载紧急援建任务成功 -> ${disRoom}`, 'green');
            }
            return Colorful$1(`[support] 房间${roomName}挂载紧急援建任务失败 -> ${disRoom}`, 'red');
        },
        Cbuild(roomName, disRoom, shard = Game.shard.name) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[support] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Creep']) {
                if (i.name == '紧急援建' && i.Data.disRoom == disRoom && i.Data.shard == shard) {
                    if (thisRoom.DeleteMission(i.id))
                        return Colorful$1(`[support] 房间${roomName}紧急援建任务删除成功`, 'green');
                }
            }
            return Colorful$1(`[support] 房间${roomName}紧急援建任务删除失败`, 'red');
        },
        upgrade(roomName, disRoom, shard = Game.shard.name, num, interval, defend = false, shardData) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[support] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Creep']) {
                if (i.name == '紧急升级' && i.Data.disRoom == disRoom && i.Data.shard == shard) {
                    return Colorful$1(`[support] 房间${roomName}紧急升级存在重复任务`, 'green');
                }
            }
            let task = thisRoom.public_helpUpgrade(disRoom, num, shard, interval, defend);
            if (task) {
                if (shardData)
                    task.Data.shardData = shardData;
                if (thisRoom.AddMission(task))
                    return Colorful$1(`[support] 房间${roomName}挂载紧急升级任务成功 -> ${disRoom}`, 'green');
            }
            return Colorful$1(`[support] 房间${roomName}挂载紧急升级任务失败 -> ${disRoom}`, 'red');
        },
        Cupgrade(roomName, disRoom, shard = Game.shard.name) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[support] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Creep']) {
                if (i.name == '紧急升级' && i.Data.disRoom == disRoom && i.Data.shard == shard) {
                    if (thisRoom.DeleteMission(i.id))
                        return Colorful$1(`[support] 房间${roomName}紧急升级任务删除成功`, 'green');
                }
            }
            return Colorful$1(`[support] 房间${roomName}紧急升级任务删除失败`, 'red');
        },
        repair(roomName, disRoom, shard = Game.shard.name, num, interval, defend = false, shardData) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[support] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Creep']) {
                if (i.name == '紧急墙体' && i.Data.disRoom == disRoom && i.Data.shard == shard) {
                    return Colorful$1(`[support] 房间${roomName}紧急墙体存在重复任务`, 'green');
                }
            }
            let task = thisRoom.public_helpRepair(disRoom, num, shard, interval, 'XLH2O', 'T3');
            if (task) {
                if (shardData)
                    task.Data.shardData = shardData;
                if (thisRoom.AddMission(task))
                    return Colorful$1(`[support] 房间${roomName}挂载紧急墙体任务成功 -> ${disRoom}`, 'green');
            }
            return Colorful$1(`[support] 房间${roomName}挂载紧急墙体任务失败 -> ${disRoom}`, 'red');
        },
        Crepair(roomName, disRoom, shard = Game.shard.name) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[support] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Creep']) {
                if (i.name == '紧急墙体' && i.Data.disRoom == disRoom && i.Data.shard == shard) {
                    if (thisRoom.DeleteMission(i.id))
                        return Colorful$1(`[support] 房间${roomName}紧急墙体任务删除成功`, 'green');
                }
            }
            return Colorful$1(`[support] 房间${roomName}紧急墙体任务删除失败`, 'red');
        },
    },
    /* 核弹相关 */
    nuke: {
        /* 发射核弹 */
        launch(roomName, disRoom, x_, y_) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[nuke]房间错误, 请确认房间${roomName}！`;
            var nuke_ = Game.getObjectById(myRoom.memory.StructureIdData.NukerID);
            if (!nuke_)
                return `[nuke]核弹查询错误!`;
            if (nuke_.launchNuke(new RoomPosition(x_, y_, disRoom)) == OK)
                return Colorful$1(`[nuke]${roomName}->${disRoom}的核弹发射成功!预计---500000---ticks后着陆!`, 'yellow', true);
            else
                return Colorful$1(`[nuke]${roomName}->${disRoom}的核弹发射失败!`, 'yellow', true);
        },
        /* 自动填充核弹开关 */
        switch(roomName) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[nuke]房间错误, 请确认房间${roomName}！`;
            if (myRoom.memory.switch.StopFillNuker)
                myRoom.memory.switch.StopFillNuker = false;
            else
                myRoom.memory.switch.StopFillNuker = true;
            if (myRoom.memory.switch.StopFillNuker)
                return `[nuke] 房间${roomName}停止自动核弹填充!`;
            return `[nuke] 房间${roomName}开启自动核弹填充!`;
        },
        switchprotect(roomName) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[nuke]房间错误, 请确认房间${roomName}！`;
            if (myRoom.memory.switch.Stopnukeprotect)
                myRoom.memory.switch.Stopnukeprotect = false;
            else
                myRoom.memory.switch.Stopnukeprotect = true;
            if (myRoom.memory.switch.Stopnukeprotect)
                return `[nuke] 房间${roomName}停止自动核弹防护!`;
            return `[nuke] 房间${roomName}开启自动核弹防护!`;
        }
    },
    /* 斥候 签名 侦察 */
    scout: {
        sign(roomName, disRoom, shard, str, shardData) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[scout] 不存在房间${roomName}`;
            let task = thisRoom.public_Sign(disRoom, shard, str);
            if (shardData)
                task.Data.shardData = shardData;
            if (!task)
                return '[scout] 任务对象生成失败';
            if (thisRoom.AddMission(task))
                return Colorful$1(`[scout] 房间${roomName}挂载房间签名任务成功 -> ${disRoom}`, 'green');
            return Colorful$1(`[scout] 房间${roomName}挂载房间签名任务失败 -> ${disRoom}`, 'red');
        },
        Csign(roomName, disRoom, shard) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[scout] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Creep']) {
                if (i.name == '房间签名' && i.Data.disRoom == disRoom && i.Data.shard == shard) {
                    if (thisRoom.DeleteMission(i.id))
                        return Colorful$1(`[scout] 房间${roomName}房间签名任务删除成功`, 'green');
                }
            }
            return Colorful$1(`[scout] 房间${roomName}房间签名任务删除失败`, 'red');
        },
        // 随机签名 手册不收录
        Rsign(roomName, disRoom, shard, shardData) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[scout] 不存在房间${roomName}`;
            let task = thisRoom.public_Sign(disRoom, shard, randomSign());
            if (shardData)
                task.Data.shardData = shardData;
            if (!task)
                return '[scout] 任务对象生成失败';
            if (thisRoom.AddMission(task))
                return Colorful$1(`[scout] 房间${roomName}挂载房间签名任务成功 -> ${disRoom}`, 'green');
            return Colorful$1(`[scout] 房间${roomName}挂载房间签名任务失败 -> ${disRoom}`, 'red');
        },
    },
};

/*AI 战争模块*/
var aiwarExtension = {
    Aiwar: {
        godestroy(roomName, disRoom, shard, boost, level = 'T0', shardData) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[Aiwar] 不存在房间${roomName}`;
            for (var oi of thisRoom.memory.Misson['Room'])
                if (oi.name == '智能战争') {
                    return `[Aiwar] 房间${roomName}已经存在Ai战争任务!`;
                }
            let task = thisRoom.public_Aidestroy(disRoom, shard, boost, level);
            if (task) {
                if (shardData)
                    task.Data.shardData = shardData;
            }
            if (thisRoom.AddMission(task))
                return Colorful$1(`[Aiwar] 房间${roomName}挂载Ai攻击任务 -(${shard})-> ${disRoom}`, 'green');
            return Colorful$1(`[Aiwar] 房间${roomName}挂载Ai攻击任务失败 -(${shard})-> ${disRoom}`, 'red');
        },
        Call(roomName, disRoom, shard) {
            /*清理全部智能战争*/
            this.Cgodestroy(roomName, disRoom, shard);
            this.Caisentry(roomName, disRoom, shard);
        },
        Cgodestroy(roomName, disRoom, shard) {
            /*卸载智能战争*/
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[Aiwar] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Room']) {
                if (i.name == "智能战争" && i.Data.disRoom == disRoom && i.Data.shard == shard) {
                    if (thisRoom.DeleteMission(i.id))
                        return `[Aiwar] 双人小队 ${roomName} -(${shard})-> ${disRoom} 的删除成功！`;
                }
            }
            return `[Aiwar] 智能战争 ${roomName} -(${shard})-> ${disRoom} 的任务删除失败！`;
        },
        Caisentry(roomName, disRoom, shard) {
            /*卸载智能哨兵*/
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[Aiwar] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Creep']) {
                if (i.name == "智能哨兵" && i.Data.disRoom == disRoom && i.Data.shard == shard) {
                    if (thisRoom.DeleteMission(i.id))
                        return `[Aiwar] 智能哨兵 ${roomName} -(${shard})-> ${disRoom} 的删除成功！`;
                }
            }
            return `[Aiwar] 智能哨兵 ${roomName} -(${shard})-> ${disRoom} 的任务删除失败！`;
        }
    }
};

/* 全局资源常量     轮子-非自己开发! */
const base = [
    RESOURCE_ENERGY,
    RESOURCE_UTRIUM,
    RESOURCE_LEMERGIUM,
    RESOURCE_KEANIUM,
    RESOURCE_ZYNTHIUM,
    RESOURCE_CATALYST,
    RESOURCE_OXYGEN,
    RESOURCE_HYDROGEN,
    RESOURCE_POWER,
    RESOURCE_OPS,
];
const bar = [
    RESOURCE_BATTERY,
    RESOURCE_UTRIUM_BAR,
    RESOURCE_LEMERGIUM_BAR,
    RESOURCE_KEANIUM_BAR,
    RESOURCE_ZYNTHIUM_BAR,
    RESOURCE_PURIFIER,
    RESOURCE_OXIDANT,
    RESOURCE_REDUCTANT,
    RESOURCE_GHODIUM_MELT,
];
const commodityBase = [RESOURCE_COMPOSITE, RESOURCE_CRYSTAL, RESOURCE_LIQUID];
const commodityMetal = [
    RESOURCE_METAL,
    RESOURCE_ALLOY,
    RESOURCE_TUBE,
    RESOURCE_FIXTURES,
    RESOURCE_FRAME,
    RESOURCE_HYDRAULICS,
    RESOURCE_MACHINE,
];
const commodityBiomass = [
    RESOURCE_BIOMASS,
    RESOURCE_CELL,
    RESOURCE_PHLEGM,
    RESOURCE_TISSUE,
    RESOURCE_MUSCLE,
    RESOURCE_ORGANOID,
    RESOURCE_ORGANISM,
];
const commoditySilicon = [
    RESOURCE_SILICON,
    RESOURCE_WIRE,
    RESOURCE_SWITCH,
    RESOURCE_TRANSISTOR,
    RESOURCE_MICROCHIP,
    RESOURCE_CIRCUIT,
    RESOURCE_DEVICE,
];
const commodityMist = [
    RESOURCE_MIST,
    RESOURCE_CONDENSATE,
    RESOURCE_CONCENTRATE,
    RESOURCE_EXTRACT,
    RESOURCE_SPIRIT,
    RESOURCE_EMANATION,
    RESOURCE_ESSENCE,
];
const boostBase = [RESOURCE_HYDROXIDE, RESOURCE_ZYNTHIUM_KEANITE, RESOURCE_UTRIUM_LEMERGITE, RESOURCE_GHODIUM];
const boostU = [
    RESOURCE_UTRIUM_HYDRIDE,
    RESOURCE_UTRIUM_ACID,
    RESOURCE_CATALYZED_UTRIUM_ACID,
    RESOURCE_UTRIUM_OXIDE,
    RESOURCE_UTRIUM_ALKALIDE,
    RESOURCE_CATALYZED_UTRIUM_ALKALIDE,
];
const boostK = [
    RESOURCE_KEANIUM_HYDRIDE,
    RESOURCE_KEANIUM_ACID,
    RESOURCE_CATALYZED_KEANIUM_ACID,
    RESOURCE_KEANIUM_OXIDE,
    RESOURCE_KEANIUM_ALKALIDE,
    RESOURCE_CATALYZED_KEANIUM_ALKALIDE,
];
const boostL = [
    RESOURCE_LEMERGIUM_HYDRIDE,
    RESOURCE_LEMERGIUM_ACID,
    RESOURCE_CATALYZED_LEMERGIUM_ACID,
    RESOURCE_LEMERGIUM_OXIDE,
    RESOURCE_LEMERGIUM_ALKALIDE,
    RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE,
];
const boostZ = [
    RESOURCE_ZYNTHIUM_HYDRIDE,
    RESOURCE_ZYNTHIUM_ACID,
    RESOURCE_CATALYZED_ZYNTHIUM_ACID,
    RESOURCE_ZYNTHIUM_OXIDE,
    RESOURCE_ZYNTHIUM_ALKALIDE,
    RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE,
];
const boostG = [
    RESOURCE_GHODIUM_HYDRIDE,
    RESOURCE_GHODIUM_ACID,
    RESOURCE_CATALYZED_GHODIUM_ACID,
    RESOURCE_GHODIUM_OXIDE,
    RESOURCE_GHODIUM_ALKALIDE,
    RESOURCE_CATALYZED_GHODIUM_ALKALIDE,
];
const resourceList = {
    base,
    bar,
    commodityBase,
    commodityMetal,
    commodityBiomass,
    commoditySilicon,
    commodityMist,
    boostBase,
    boostU,
    boostK,
    boostL,
    boostZ,
    boostG,
};
const resourceColorMap = {
    [RESOURCE_ENERGY]: '#fff200',
    [RESOURCE_UTRIUM]: '#4ca7e5',
    [RESOURCE_KEANIUM]: '#da6Bf5',
    [RESOURCE_LEMERGIUM]: '#6cf0a9',
    [RESOURCE_ZYNTHIUM]: '#f7d492',
    [RESOURCE_CATALYST]: '#ffc0cb',
    [RESOURCE_GHODIUM]: '#fff',
    [RESOURCE_BATTERY]: '#fff200',
    [RESOURCE_ZYNTHIUM_BAR]: '#f7d492',
    [RESOURCE_LEMERGIUM_BAR]: '#6cf0a9',
    [RESOURCE_UTRIUM_BAR]: '#4ca7e5',
    [RESOURCE_KEANIUM_BAR]: '#da6bf5',
    [RESOURCE_PURIFIER]: '#ffc0cb',
    [RESOURCE_GHODIUM_MELT]: '#fff',
    [RESOURCE_POWER]: '#e05a5a',
    [RESOURCE_OPS]: '#e05a5a',
};

/* 展示全局资源相关     轮子-非自己开发! */
const addStore = (resource, store) => {
    for (const key in store) {
        if (store[key] > 0)
            resource[key] = (resource[key] || 0) + store[key];
    }
    return resource;
};
const addRoomList = (text, resType, allRes, roomRes) => {
    let str = text;
    if (allRes[resType]) {
        str += `<div class='resource-room' style='position: absolute; display: none; top: 100%; right: 0; padding: 5px; background: #333; color: #ccc; border: 1px solid #ccc; border-radius: 5px; z-index: 10;'>`;
        for (const key in roomRes) {
            if (roomRes[key][resType])
                str += `${_.padRight(key, 6)}: ${_.padLeft((roomRes[key][resType] || 0).toLocaleString(), 9)}<br/>`;
        }
        str += '</div>';
    }
    return str;
};
const addList = (list, allRes, roomRes, color) => {
    let str = `<div style='position: relative; color: ${color};'>`;
    list.forEach((res) => (str += uniqueColor(_.padLeft(res, 15), res)));
    str += '<br/>';
    list.forEach((res) => (str += uniqueColor(addRoomList(_.padLeft((allRes[res] || 0).toLocaleString(), 15), res, allRes, roomRes), res)));
    str += '<br/></div>';
    return str;
};
const getStr = (allRes, roomRes, labOnly) => {
    let str = '';
    if (!labOnly) {
        str += '<br/>基础资源:<br/>';
        str += addList(resourceList.base, allRes, roomRes);
        str += '<br/>压缩资源:<br/>';
        str += addList(resourceList.bar, allRes, roomRes);
        str += '<br/>商品资源:<br/>';
        str += addList(resourceList.commodityBase, allRes, roomRes);
        str += addList(resourceList.commodityMetal, allRes, roomRes, resourceColorMap[RESOURCE_ZYNTHIUM]);
        str += addList(resourceList.commodityBiomass, allRes, roomRes, resourceColorMap[RESOURCE_LEMERGIUM]);
        str += addList(resourceList.commoditySilicon, allRes, roomRes, resourceColorMap[RESOURCE_UTRIUM]);
        str += addList(resourceList.commodityMist, allRes, roomRes, resourceColorMap[RESOURCE_KEANIUM]);
        str += '<br/>LAB资源:<br/>';
    }
    str += addList(resourceList.boostBase, allRes, roomRes);
    str += addList(resourceList.boostU, allRes, roomRes, resourceColorMap[RESOURCE_UTRIUM]);
    str += addList(resourceList.boostK, allRes, roomRes, resourceColorMap[RESOURCE_KEANIUM]);
    str += addList(resourceList.boostL, allRes, roomRes, resourceColorMap[RESOURCE_LEMERGIUM]);
    str += addList(resourceList.boostZ, allRes, roomRes, resourceColorMap[RESOURCE_ZYNTHIUM]);
    str += addList(resourceList.boostG, allRes, roomRes, resourceColorMap[RESOURCE_GHODIUM_MELT]);
    str += `<script>$('.resource-name').hover(function() { $(this).find('.resource-room').show() }, function() { $(this).find('.resource-room').hide() })</script>`;
    return str;
};
const getCatteryResource = (room) => {
    const resource = {};
    if (room.storage)
        addStore(resource, room.storage.store);
    if (room.terminal)
        addStore(resource, room.terminal.store);
    return resource;
};
const getLabData = (room) => {
    const resource = {};
    let labData = room.memory.Labautomatic.automaticData;
    if (labData && labData.length > 0) {
        for (const data of labData) {
            resource[data.Type] = (resource[data.Type] || 0) + data.Num;
        }
    }
    return resource;
};
const uniqueColor = (str, resType) => {
    return `<span class='resource-name' style='position: relative; color: ${resourceColorMap[resType] || 'inherited'}'>${str}</span>`;
};
const allResource = (roomName) => {
    const time = Game.cpu.getUsed();
    const myRooms = (roomName) ? ([Game.rooms[roomName]]) : (Object.values(Game.rooms).filter((cattery) => { var _a; return (_a = cattery.controller) === null || _a === void 0 ? void 0 : _a.my; }));
    const roomRes = {};
    myRooms.forEach((cattery) => {
        roomRes[cattery.name] = getCatteryResource(cattery);
    });
    const allRes = myRooms.reduce((all, room) => addStore(all, roomRes[room.name]), {});
    let str = getStr(allRes, roomRes);
    console.log(str);
    console.log(`cpu: ${Game.cpu.getUsed() - time}`);
};
const allLabData = () => {
    const time = Game.cpu.getUsed();
    const myRooms = Object.values(Game.rooms).filter((room) => { var _a; return (_a = room.controller) === null || _a === void 0 ? void 0 : _a.my; });
    const labData = {};
    myRooms.forEach((room) => {
        labData[room.name] = getLabData(room);
    });
    const allRes = myRooms.reduce((all, room) => addStore(all, labData[room.name]), {});
    let str = getStr(allRes, labData, true);
    console.log(str);
    console.log(`cpu: ${Game.cpu.getUsed() - time}`);
};

const colors$1 = {
    red: '#ef9a9a',
    green: '#6b9955',
    yellow: '#c5c599',
    blue: '#8dc5e3'
};
function getColor(val) {
    if (val > 100)
        val = 100;
    //let 百分之一 = (单色值范围) / 50;  单颜色的变化范围只在50%之内
    let per = (255 + 255) / 100;
    let r = 0;
    let g = 0;
    let b = 0;
    if (val < 50) {
        // 比例小于50的时候红色是越来越多的,直到红色为255时(红+绿)变为黄色.
        r = per * val;
        g = 255;
    }
    if (val >= 50) {
        // 比例大于50的时候绿色是越来越少的,直到0 变为纯红
        g = 255 - ((val - 50) * per);
        r = 255;
    }
    r = Math.ceil(r); // 取整
    g = Math.ceil(g); // 取整
    b = Math.ceil(b); // 取整
    return "rgb(" + r + "," + g + "," + b + ")";
}
function colorHex(color) {
    let reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
    if (/^(rgb|RGB)/.test(color)) {
        let aColor = color.replace(/(?:\(|\)|rgb|RGB)*/g, "").split(",");
        let strHex = "#";
        for (let i = 0; i < aColor.length; i++) {
            let hex = Number(aColor[i]).toString(16);
            if (hex === "0") {
                hex += hex;
            }
            strHex += hex;
        }
        if (strHex.length !== 7) {
            strHex = color;
        }
        return strHex;
    }
    else if (reg.test(color)) {
        let aNum = color.replace(/#/, "").split("");
        if (aNum.length === 6) {
            return color;
        }
        else if (aNum.length === 3) {
            let numHex = "#";
            for (let i = 0; i < aNum.length; i++) {
                numHex += (aNum[i] + aNum[i]);
            }
            return numHex;
        }
    }
    else {
        return color;
    }
}
function Colorful(content, colorName = null, bolder = false) {
    const colorStyle = colorName ? `color: ${colors$1[colorName] ? colors$1[colorName] : colorName};` : '';
    const bolderStyle = bolder ? 'font-weight: bolder;' : '';
    return `<text style="${[colorStyle, bolderStyle].join(' ')}">${content}</text>`;
}
function getRooms() {
    let rooms = [];
    for (let name in Memory.RoomControlData) {
        if (Game.rooms[name])
            rooms.push(name);
    }
    return rooms;
}
function getStore(roomName) {
    if (roomName) {
        let storage = Game.rooms[roomName].storage;
        let terminal = Game.rooms[roomName].terminal;
        let factory = Game.rooms[roomName].GetStructData(STRUCTURE_FACTORY);
        let storageUsed = (storage === null || storage === void 0 ? void 0 : storage.store.getUsedCapacity()) || 0;
        let storeCapacity = (storage === null || storage === void 0 ? void 0 : storage.store.getCapacity()) || 1;
        let storageProportion = (storageUsed / storeCapacity * 100).toFixed(2) + '%';
        let storageColor = colorHex(getColor(Math.ceil(storageUsed / storeCapacity * 100)));
        let terminalUsed = (terminal === null || terminal === void 0 ? void 0 : terminal.store.getUsedCapacity()) || 0;
        let terminalCapacity = (terminal === null || terminal === void 0 ? void 0 : terminal.store.getCapacity()) || 1;
        let terminalProportion = (terminalUsed / terminalCapacity * 100).toFixed(2) + '%';
        let terminalColor = colorHex(getColor(Math.ceil(terminalUsed / terminalCapacity * 100)));
        let factoryUsed = (factory === null || factory === void 0 ? void 0 : factory.store.getUsedCapacity()) || 0;
        let factoryCapacity = (factory === null || factory === void 0 ? void 0 : factory.store.getCapacity()) || 1;
        let factoryProportion = (factoryUsed / factoryCapacity * 100).toFixed(2) + '%';
        let factoryColor = colorHex(getColor(Math.ceil(factoryUsed / factoryCapacity * 100)));
        console.log(Colorful(roomName, 'blue'), 'Storage:', Colorful(storageProportion, storageColor), ' ', 'Terminal', Colorful(terminalProportion, terminalColor), ' ', 'Factory', Colorful(factoryProportion, factoryColor));
    }
    else {
        let rooms = getRooms();
        for (let i = 0; i < rooms.length; i++) {
            let storage = Game.rooms[rooms[i]].storage;
            let terminal = Game.rooms[rooms[i]].terminal;
            let factory = Game.rooms[rooms[i]].GetStructData(STRUCTURE_FACTORY);
            let storageUsed = (storage === null || storage === void 0 ? void 0 : storage.store.getUsedCapacity()) || 0;
            let storeCapacity = (storage === null || storage === void 0 ? void 0 : storage.store.getCapacity()) || 1;
            let storageProportion = (storageUsed / storeCapacity * 100).toFixed(2) + '%';
            let storageColor = colorHex(getColor(Math.ceil(storageUsed / storeCapacity * 100)));
            let terminalUsed = (terminal === null || terminal === void 0 ? void 0 : terminal.store.getUsedCapacity()) || 0;
            let terminalCapacity = (terminal === null || terminal === void 0 ? void 0 : terminal.store.getCapacity()) || 1;
            let terminalProportion = (terminalUsed / terminalCapacity * 100).toFixed(2) + '%';
            let terminalColor = colorHex(getColor(Math.ceil(terminalUsed / terminalCapacity * 100)));
            let factoryUsed = (factory === null || factory === void 0 ? void 0 : factory.store.getUsedCapacity()) || 0;
            let factoryCapacity = (factory === null || factory === void 0 ? void 0 : factory.store.getCapacity()) || 1;
            let factoryProportion = (factoryUsed / factoryCapacity * 100).toFixed(2) + '%';
            let factoryColor = colorHex(getColor(Math.ceil(factoryUsed / factoryCapacity * 100)));
            console.log(Colorful(rooms[i], 'blue'), 'Storage', Colorful(storageProportion, storageColor), ' ', 'Terminal', Colorful(terminalProportion, terminalColor), ' ', 'Factory', Colorful(factoryProportion, factoryColor));
            // Colorful(string, colorHex(getColor(Math.ceil(storageUsed / storeCapacity * 100))))
        }
    }
}

/* 与资源相关的 */
var staticExtension = {
    resource: {
        all() {
            allResource();
            return `[resource] 全局资源统计完毕!`;
        },
        lab() {
            allLabData();
            return `[resource] lab合成信息统计完毕!`;
        },
        room(roomName) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[resource] 不存在房间${roomName}`;
            allResource(roomName);
            return `[resource] 房间${roomName}资源统计完毕!`;
        },
        com() {
            let result = '压缩商品资源:\n';
            result += 'battery(wn) utrium_bar(U) lemergium_bar(L) keanium_bar(K) zynthium_bar(Z) \n';
            result += 'ghodium_melt(G) oxidant(O) reductant(H) purifier(X)\n';
            result += '基础商品资源:\n';
            result += 'wire cell alloy condensate composite crystal liquid\n';
            result += Colorful$1('机械商品:\n', '#f7d492', true);
            result += Colorful$1('tube fixtures frame hydraulics machine\n', '#f7d492', false);
            result += Colorful$1('生物商品:\n', '#6cf0a9', true);
            result += Colorful$1('phlegm tissue muscle organoid organism\n', '#6cf0a9', false);
            result += Colorful$1('电子商品:\n', '#4ca7e5', true);
            result += Colorful$1('switch transistor microchip circuit device\n', '#4ca7e5', false);
            result += Colorful$1('奥秘商品:\n', '#da6bf5', true);
            result += Colorful$1('concentrate extract spirit emanation essence\n', '#da6bf5', false);
            return result;
        }
    },
    store: {
        all() {
            getStore();
            return `[store] 全局容量信息统计完毕!`;
        },
        room(roomName) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[store] 不存在房间${roomName}`;
            getStore(roomName);
            return `[store] 房间${roomName}容量信息统计完毕!`;
        }
    },
    /* 任务输出调试屏蔽 */
    missionInfo: {
        ignore(name) {
            if (!isInArray(Memory.ignoreMissonName, name))
                Memory.ignoreMissonName.push(name);
            return `[ignore] 已经将任务${name}添加进输出调试的忽略名单里!`;
        },
        remove(name) {
            if (isInArray(Memory.ignoreMissonName, name)) {
                var index = Memory.ignoreMissonName.indexOf(name);
                Memory.ignoreMissonName.splice(index, 1);
                return `[ignore] 已经将任务${name}删除出输出调试的忽略名单里!`;
            }
            return `[ignore] 删除 ${name} 出调试输出忽略名单失败!`;
        },
        lab(ignore) {
            Memory.ignoreLab = ignore;
            if (ignore)
                return `[ignore] 已经禁用控制台lab输出!`;
            else
                return `[ignore] 已经启用控制台lab输出!`;
        },
    },
    /*左上角显示操作*/
    visual: {
        toggle(roomName) {
            let thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[Visual] 不存在房间${roomName}`;
            thisRoom.memory.Visualdisplay = !thisRoom.memory.Visualdisplay;
            return `[Visual] ${thisRoom} 可视化显示${thisRoom.memory.Visualdisplay}`;
        },
    },
    flag: {
        clear() {
            for (let flags_key in Game.flags) {
                Game.flags[flags_key].remove();
            }
            return `[Visual] 完成旗帜清理`;
        }
    },
    /*房间维护开销的计算*/
    maintain: {
        cost(roomName) {
            let thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[Visual] 不存在房间${roomName}`;
            /*筛选出所有的道路*/
            let structures_list = thisRoom.find(FIND_STRUCTURES, {
                filter: (i) => i.structureType == STRUCTURE_ROAD
            });
            let road_maintain_energy = 0;
            let role_maintain_energy = 0;
            if (structures_list.length > 0) {
                let getNtowerID = Game.getObjectById(thisRoom.memory.StructureIdData.NtowerID);
                if (!getNtowerID) {
                    return `[Maintain]  ${thisRoom} 没有对应的维修单位!`;
                }
                let from_pos = `W${getNtowerID.pos.x}N${getNtowerID.pos.y}`;
                for (let Data_ of structures_list) {
                    let to_pos = `W${Data_.pos.x}N${Data_.pos.y}`;
                    let _number = Game.map.getRoomLinearDistance(from_pos, to_pos);
                    /*计算healnumber*/
                    let _heal_number = 800;
                    if (_number > 5) {
                        _heal_number -= (_number - 5) * 40;
                    }
                    _heal_number = _heal_number < 200 ? 200 : _heal_number;
                    /*获取偏差数值*/
                    let _loss_number = 110;
                    if (Data_.hitsMax > 20000) {
                        _loss_number = 550;
                    }
                    if (Data_.hitsMax > 700000) {
                        _loss_number = 16500;
                    }
                    let _heal = Math.ceil(_loss_number / _heal_number);
                    road_maintain_energy += _heal * 10 * 1.5;
                }
            }
            /*开始统计孵化开销*/
            for (let cof in thisRoom.memory.SpawnConfig) {
                let role = thisRoom.memory.SpawnConfig[cof];
                if (role.num === 0)
                    continue;
                let bd = global.CreepBodyData[thisRoom.name][cof];
                let body = GenerateAbility(bd[0], bd[1], bd[2], bd[3], bd[4], bd[5], bd[6], bd[7]);
                let energy_ = CalculateEnergy(body);
                role_maintain_energy += energy_ * role.num;
            }
            /*筛选出维护塔*/
            /*计算 基于塔的维修效果*/
            return `[Maintain]  ${thisRoom} 道路维护 ${road_maintain_energy},基础孵化 ${role_maintain_energy} 300tick ${(road_maintain_energy + role_maintain_energy) / 5}`;
        }
    },
    pixel: {
        //开关搓像素
        switch() {
            Memory.StopPixel = !Memory.StopPixel;
            return `[pixel] 自动搓像素改为${!Memory.StopPixel}`;
        },
        //自动买像素
        buy(num, price, unit = 1, floor) {
            //查找现有订单
            let buyOrder;
            for (let i in Game.market.orders) {
                let order = Game.market.getOrderById(i);
                if (order.resourceType === PIXEL && order.type === ORDER_BUY) {
                    buyOrder = order.id;
                    break;
                }
            }
            Memory.pixelInfo.buy.price = price;
            Memory.pixelInfo.buy.unit = unit;
            Memory.pixelInfo.buy.floor = floor ? floor : 0;
            if (!Game.market.getOrderById(buyOrder)) {
                //创建新订单
                Memory.pixelInfo.buy.num = num - unit;
                Game.market.createOrder({ type: ORDER_BUY, resourceType: PIXEL, price: price, totalAmount: unit });
                return `[Pixel] 创建像素购买订单!数量${num},价格${price},单位${unit},下限${floor}`;
            }
            else {
                //更改现有订单
                Memory.pixelInfo.buy.num += num - unit;
                Game.market.changeOrderPrice(buyOrder, price);
                return `[Pixel] 追加像素购买订单!数量${num},价格${price},单位${unit},下限${floor}`;
            }
        },
        //自动卖像素
        sell(num, price, unit = 1, ceil) {
            //查找现有订单
            let sellOrder;
            for (let i in Game.market.orders) {
                let order = Game.market.getOrderById(i);
                if (order.resourceType === PIXEL && order.type === ORDER_SELL) {
                    sellOrder = order.id;
                    break;
                }
            }
            Memory.pixelInfo.sell.price = price;
            Memory.pixelInfo.sell.unit = unit;
            Memory.pixelInfo.sell.ceil = ceil ? ceil : 0;
            if (!Game.market.getOrderById(sellOrder)) {
                //创建新订单
                Memory.pixelInfo.sell.num = num - unit;
                Game.market.createOrder({ type: ORDER_SELL, resourceType: PIXEL, price: price, totalAmount: 1 });
                return `[Pixel] 创建像素出售订单!数量${num},价格${price},单位${unit},上限${ceil}`;
            }
            else {
                //更改现有订单
                Memory.pixelInfo.sell.num += num - unit;
                Game.market.changeOrderPrice(sellOrder, price);
                return `[Pixel] 追加像素出售订单!数量${num},价格${price},单位${unit},上限${ceil}`;
            }
        },
        cancel(type) {
            let cancelAmount = 0;
            for (let i in Game.market.orders) {
                let order = Game.market.getOrderById(i);
                if (order.resourceType === PIXEL && order.type === type) {
                    if (Game.market.cancelOrder(order.id) === OK) {
                        cancelAmount++;
                    }
                }
            }
            if (type === 'buy') {
                Memory.pixelInfo.buy.num = 0;
            }
            else {
                Memory.pixelInfo.sell.num = 0;
            }
            return `[Pixel] 已取消${cancelAmount}个${type}订单!`;
        }
    },
};

var behaviourExtension = {
    /* 终端行为 */
    terminal: {
        // 默认最多8个传送任务
        send(roomName, disRoom, rType, num) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[terminal] 不存在房间${roomName}`;
            var thisTask = thisRoom.public_Send(disRoom, rType, num);
            /* 查看资源是否足够 */
            var terminal_ = thisRoom.terminal;
            var storage_ = thisRoom.storage;
            if (!terminal_ || !storage_) {
                return Colorful$1(`[terminal] 房间${roomName}不存在终端/仓房或记忆未更新!`, 'red', true);
            }
            /* 查询其他资源传送任务中是否有一样的资源 */
            var Num = 0;
            if (!thisRoom.memory.Misson['Structure'])
                thisRoom.memory.Misson['Structure'] = [];
            for (var tM of thisRoom.memory.Misson['Structure']) {
                if (tM.name == '资源传送' && tM.Data.rType == rType)
                    Num += tM.Data.num;
            }
            /* 计算资源是否满足 */
            if (terminal_.store.getUsedCapacity(rType) + storage_.store.getUsedCapacity(rType) - Num < num)
                return Colorful$1(`[terminal] 房间${roomName} 资源${rType} 数量总合少于 ${num}, 传送任务挂载失败!`, 'yellow', true);
            /* 计算路费 */
            var cost = Game.market.calcTransactionCost(num, roomName, disRoom);
            if (terminal_.store.getUsedCapacity('energy') + storage_.store.getUsedCapacity('energy') < cost || cost > 150000)
                return Colorful$1(`[terminal] 房间${roomName}-->${disRoom}资源${rType}所需路费少于 ${cost}或大于150000, 传送任务挂载失败!`, 'yellow', true);
            if (thisRoom.AddMission(thisTask))
                return Colorful$1(`[terminal] 房间${roomName}-->${disRoom}资源${rType}传送挂载成功! 数量：${num}；路费：${cost}`, 'green', true);
            return Colorful$1(`[terminal] 房间${roomName}-->${disRoom}资源${rType}传送 不明原因挂载失败!`, 'red', true);
        },
        Csend(roomName, disRoom, rType) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[terminal] 不存在房间${roomName}`;
            for (var tM of thisRoom.memory.Misson['Structure']) {
                if (tM.name == '资源传送' && tM.Data.rType == rType && tM.Data.disRoom == disRoom) {
                    if (thisRoom.DeleteMission(tM.id))
                        return Colorful$1(`[terminal] 房间${roomName}-->${disRoom}资源${rType}传送任务删除成功!`, 'blue', true);
                }
            }
            return Colorful$1(`[terminal] 房间${roomName}-->${disRoom}资源${rType}传送 不明原因删除失败!`, 'red', true);
        },
        /* 查看目前房间/全局的资源传送任务 */
        show(roomName) {
            var roomList = [];
            if (roomName)
                roomList = [roomName];
            else {
                if (!Memory.RoomControlData)
                    Memory.RoomControlData = {};
                for (var rN in Memory.RoomControlData) {
                    roomList.push(rN);
                }
            }
            if (roomList.length <= 0)
                return `[terminal] 未发现房间!`;
            for (var rN of roomList) {
                if (!Game.rooms[rN])
                    return `[terminal] 不存在房间${rN}!`;
            }
            var str = '';
            for (var rN of roomList) {
                if (!Game.rooms[rN].memory.Misson['Structure'])
                    Game.rooms[rN].memory.Misson['Structure'] = [];
                if (Game.rooms[rN].MissionNum('Structure', '资源传送') <= 0)
                    continue;
                str += '房间 ' + Colorful$1(`${rN}`, 'yellow', true) + '：\n';
                for (var m of Game.rooms[rN].memory.Misson['Structure']) {
                    if (m.name == '资源传送') {
                        str += '    ' + `-->${m.Data.disRoom} | 资源：${m.Data.rType} | 数量：` + m.Data.num + ' \n';
                    }
                }
            }
            if (str == '')
                return `[terminal] 未发现资源传送任务!`;
            return str;
        },
    },
    /* 全局资源传送 */
    give: {
        set(roomName, rType, num, pass) {
            if (num > 200000)
                return `[give] 资源数量太多!不能挂载全局资源传送任务!`;
            if (!Game.rooms[roomName] && !pass) {
                // 不是自己房间需要确认
                return `[give] 未授权的传送命令,目标房间非自己房间!`;
            }
            for (var i of Memory.ResourceDispatchData) {
                if (i.sourceRoom == roomName && i.rType == rType)
                    return `[give] 已经存在全局资源传送任务了!`;
            }
            let dispatchTask = {
                sourceRoom: roomName,
                rType: rType,
                num: num,
                delayTick: 1500,
                conditionTick: 500,
                buy: false,
                mtype: 'deal' // 可以删了
            };
            Memory.ResourceDispatchData.push(dispatchTask);
            return `[give] 全局资源传送任务发布,房间${roomName},资源类型${rType},数量${num}`;
        },
        remove(roomName, rType) {
            for (var i of Memory.ResourceDispatchData) {
                if (i.sourceRoom == roomName && i.rType == rType) {
                    let index = Memory.ResourceDispatchData.indexOf(i);
                    Memory.ResourceDispatchData.splice(index, 1);
                    return `[give] 成功删除房间${roomName}[${rType}]全局资源传送任务!`;
                }
            }
            return `[give] 未发现房间${roomName}[${rType}]全局资源传送任务!`;
        }
    },
    /* 物流 */
    logistic: {
        send(roomName, disRoom, rType, num, whitelist) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[logistic] 不存在房间${roomName}`;
            let thisTask = thisRoom.public_resource_transfer(disRoom, rType ? rType : null, num ? num : null, whitelist ? whitelist : null);
            if (thisTask && thisRoom.AddMission(thisTask))
                return Colorful$1(`[logistic] 房间${roomName} --> ${disRoom}资源转移任务已经下达, 资源类型:${rType ? rType : "所有资源"} | 数量:${num ? num : "所有"}`, 'green');
            return Colorful$1(`[logistic] 房间${roomName} --> ${disRoom}资源转移任务已经下达失败!`, 'red');
        },
        Csend(roomName, disRoom) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[logistic] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Room']) {
                if (i.name == '资源转移' && thisRoom.DeleteMission(i.id))
                    return Colorful$1(`[logistic] 房间${roomName} --(${i.Data.rType})--> ${disRoom}资源转移任务删除成功!`, 'green');
            }
            return Colorful$1(`[logistic] 房间${roomName} --> ${disRoom}资源转移任务删除失败!`, 'red');
        },
        // 查询所有房间的资源转移相关的物流信息
        show() {
            let result = `[logisitic] 资源转移物流信息:\n`;
            for (var i in Memory.RoomControlData) {
                if (Game.rooms[i] && Game.rooms[i].controller && Game.rooms[i].controller.my) {
                    let room_ = Game.rooms[i];
                    let task = room_.MissionName('Room', '资源转移');
                    if (task) {
                        result += `${room_.name}->${task.Data.disRoom}: 资源类型:${task.Data.rType ? task.Data.rType : "所有资源"},数量:${task.Data.num ? task.Data.num : '所有'}\n`;
                    }
                }
            }
            if (result == `[logisitic] 资源转移物流信息:\n`)
                return `[logisitic] 未发现资源转移物流信息`;
            return result;
        },
    },
    /* 外矿 */
    mine: {
        // 采集外矿
        harvest(roomName, x, y, disRoom, central = false) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[mine] 不存在房间${roomName}`;
            if (!thisRoom.storage)
                return `[mine] 房间${roomName}不存在storage`;
            var thisTask = thisRoom.public_OutMine(roomName, x, y, disRoom, central);
            thisTask.maxTime = 8;
            if (thisRoom.AddMission(thisTask))
                return `[mine] ${roomName} -> ${disRoom} 的外矿任务挂载成功!`;
            return `[mine] ${roomName} -> ${disRoom} 的外矿任务挂载失败!`;
        },
        // 取消采集
        Charvest(roomName, disRoom) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[mine] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Creep']) {
                if (i.name == '外矿开采' && i.Data.disRoom == disRoom) {
                    if (thisRoom.DeleteMission(i.id)) {
                        if (Memory.outMineData[disRoom])
                            delete Memory.outMineData[disRoom];
                        return `[mine] ${roomName} -> ${disRoom} 的外矿任务删除成功!`;
                    }
                }
            }
            return `[mine] ${roomName} -> ${disRoom} 的外矿任务删除失败!`;
        },
        // 更新外矿road信息
        update(roomName, disRoom) {
            if (!Game.rooms[disRoom])
                return `[mine] 不存在相应视野`;
            let roads = Game.rooms[disRoom].find(FIND_STRUCTURES, {
                filter: (stru) => {
                    return stru.structureType == 'road';
                }
            });
            let cons = Game.rooms[disRoom].find(FIND_CONSTRUCTION_SITES, {
                filter: (cons) => {
                    return cons.structureType == 'road';
                }
            });
            // 去除road记忆
            for (var i of Memory.outMineData[roomName].road) {
                let pos_ = unzipPosition(i);
                if (pos_.roomName == roomName && !pos_.GetStructure('road')) {
                    let index = Memory.outMineData[roomName].road.indexOf(i);
                    Memory.outMineData[roomName].road.splice(index, 1);
                }
            }
            let posList = [];
            for (let r of roads)
                posList.push(zipPosition(r.pos));
            for (let c of cons)
                posList.push(zipPosition(c.pos));
            for (let p of posList) {
                if (!isInArray(Memory.outMineData[roomName].road, p))
                    Memory.outMineData[roomName].road.push(p);
            }
            return `[mine] 已经更新房间${disRoom}的外矿信息!`;
        },
        forceUpdate(roomName, disRoom, roadUpdatedforce) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[mine] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Creep']) {
                if (i.name == '外矿开采' && i.Data.disRoom == disRoom) {
                    i.Data.roadUpdatedforce = roadUpdatedforce ? true : false;
                    i.Data.roadUpdated = false;
                    i.Data.state = 1;
                    return `[mine] ${roomName} -> ${disRoom} 的外矿任务更新成功!`;
                }
            }
            return `[mine] ${roomName} -> ${disRoom} 的外矿任务更新失败!`;
        },
        delRoad(roomName, x, y) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[mine] 不存在房间${roomName}`;
            let road_t = `${x}/${y}/${roomName}`;
            if (!isInArray(Memory.outMineData[roomName].road, road_t))
                return `[mine] 已经没有${road_t}路径信息!`;
            let index = Memory.outMineData[roomName].road.indexOf(road_t);
            Memory.outMineData[roomName].road.splice(index, 1);
            var thisPosition = new RoomPosition(x, y, roomName);
            var result = [];
            for (var looki of thisPosition.lookFor(LOOK_STRUCTURES))
                result.push(looki);
            for (var lookj of thisPosition.lookFor(LOOK_CONSTRUCTION_SITES))
                result.push(lookj);
            for (var sample of result) {
                if (sample.destroy)
                    sample.destroy();
                else if (sample.remove)
                    sample.remove();
            }
            return `[mine] 已经更新房间路径信息!`;
        }
    },
    /* 市场 */
    market: {
        // 交易订单
        deal(roomName, id, amount) {
            return Game.market.deal(id, amount, roomName);
        },
        // 查询订单
        look(rType, marType) {
            var HistoryList = Game.market.getHistory(rType);
            var allNum = 0;
            for (var ii of HistoryList) {
                allNum += ii.avgPrice;
            }
            var avePrice = allNum / HistoryList.length;
            var list = Game.market.getAllOrders({ type: marType, resourceType: rType });
            /* 按照价格从上到下 */
            var newList = list.sort(compare$1('price'));
            var result = `当前市场上资源${rType}的${marType}订单如下:\n`;
            if (isInArray(['pixel', 'access_key', 'cpu_unlock'], rType)) {
                for (var i of list) {
                    result += `\tID:${i.id} 数量:${i.amount} 价格:${i.price} 坐标:${i.roomName} \n`;
                }
                return result;
            }
            for (var i of newList) {
                var priceColor = 'green';
                var roomColor = 'green';
                if (i.price > avePrice && i.price - avePrice > 10)
                    priceColor = 'red';
                if (i.price > avePrice && i.price - avePrice <= 10)
                    priceColor = 'yellow';
                if (i.price <= avePrice)
                    priceColor = 'green';
                LoopB: for (var roomName in Memory.RoomControlData) {
                    var cost = Game.market.calcTransactionCost(1000, roomName, i.roomName);
                    if (cost >= 7000) {
                        roomColor = 'red';
                        break LoopB;
                    }
                    else if (cost < 700 && cost >= 500) {
                        roomColor = 'yellow';
                        break LoopB;
                    }
                    roomColor = 'green';
                }
                result += `\tID:${i.id} ` + `数量:${i.amount} 价格:` + Colorful$1(`${i.price}`, priceColor ? priceColor : 'blue', true) + ` 坐标: ` + Colorful$1(`${i.roomName}`, roomColor ? roomColor : 'blue', true) + ' \n';
            }
            return result;
        },
        // 下买订单
        buy(roomName, rType, mType, num, price, unit = 2000, confirm, retain, autotrade, autoData) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[support] 不存在房间${roomName}`;
            if (!mType)
                return `[market] 未指定交易类型`;
            if (num * price > 10000000 && !confirm)
                return `[market] 大额购买(单价:${price},总价:${num * price})需手动确认!`;
            if (confirm === false)
                return `[market] 交易未确认!`;
            if (!thisRoom.memory.market)
                thisRoom.memory.market = {};
            if (mType == 'order') {
                if (!thisRoom.memory.market['order'])
                    thisRoom.memory.market['order'] = [];
                var bR = true;
                for (var od of thisRoom.memory.market['order']) {
                    if (od.rType == rType)
                        bR = false;
                }
                if (bR) {
                    let _addbR = { rType: rType, num: num, unit: unit, price: price, mTyep: 'buy', retain: retain };
                    if (autotrade) {
                        _addbR['autotrade'] = autotrade;
                        if (!autoData.autoatype)
                            return `[market][auto] 参数Atype未定义!`;
                        for (let key in autoData) {
                            _addbR[key] = autoData[key];
                        }
                    }
                    thisRoom.memory.market['order'].push(_addbR);
                    return `[market] 房间${roomName}成功下达order的资源采购指令,类型:buy,资源:${rType},数量:${num},单位:${unit},单价:${price},总价:${num * price}`;
                }
                else
                    return `[market] 房间${roomName}已经存在${rType}的订单了`;
            }
            else if (mType == 'deal') {
                if (!thisRoom.memory.market['deal'])
                    thisRoom.memory.market['deal'] = [];
                var bR = true;
                for (var od of thisRoom.memory.market['deal']) {
                    if (od.rType == rType)
                        bR = false;
                }
                if (bR) {
                    thisRoom.memory.market['deal'].push({ rType: rType, num: num, price: price, unit: unit, mTyep: 'buy', retain: retain });
                    return `[market] 房间${roomName}成功下达deal的资源采购指令,类型:buy,资源:${rType},数量:${num},单位:${unit},单价:${price},总价:${num * price}`;
                }
                else
                    return `[market] 房间${roomName}已经存在${rType}的订单了`;
            }
        },
        // 查询平均价格
        ave(rType, day = 1) {
            return `[market] 资源${rType}在近${day}天内的平均价格为${avePrice(rType, day)}`;
        },
        // 查询是否有订单
        have(roomName, res, mtype, p = null, r = null) {
            let result = haveOrder(roomName, res, mtype, p, r);
            if (p)
                return `[market] 房间:${roomName};资源:${res};类型:${mtype}[价格:${p + r}以上]的单子--->${result ? "有" : "没有"}`;
            else
                return `[market] 房间:${roomName};资源:${res};类型:${mtype}的单子--->${result ? "有" : "没有"}`;
        },
        // 查询市场上的最高价格
        highest(rType, mtype, mprice = 0) {
            let result = highestPrice(rType, mtype, mprice);
            if (mprice)
                return `[market] 资源:${rType};类型:${mtype} 最高价格${result}[低于${mprice}]`;
            else
                return `[market] 资源:${rType};类型:${mtype} 最高价格${result}`;
        },
        // 查询市场上的最低价格
        lowest(rType, mtype, mprice = 0) {
            let result = lowestPrice(rType, mtype, mprice);
            if (mprice)
                return `[market] 资源:${rType};类型:${mtype} 最低价格${result}[高于${mprice}]`;
            else
                return `[market] 资源:${rType};类型:${mtype} 最低价格${result}`;
        },
        // 卖资源
        sell(roomName, rType, mType, num, price, unit = 2000, confirm, retain, autoprice) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[support] 不存在房间${roomName}`;
            if (!thisRoom.memory.market)
                thisRoom.memory.market = {};
            if (num * price > 10000000 && !confirm)
                return `[market] 大额购买(单价:${price},总价:${num * price})需手动确认!`;
            if (confirm === false)
                return `[market] 交易未确认!`;
            if (mType == 'order') {
                if (!thisRoom.memory.market['order'])
                    thisRoom.memory.market['order'] = [];
                var bR = true;
                for (var od of thisRoom.memory.market['order']) {
                    if (od.rType == rType)
                        bR = false;
                }
                if (bR) {
                    thisRoom.memory.market['order'].push({ rType: rType, num: num, unit: unit, price: price, mTyep: 'sell', retain: retain });
                    return `[market] 房间${roomName}成功下达order的资源卖出指令,type:sell,rType:${rType},num:${num},unit:${unit},price:${price}`;
                }
                else
                    return `[market] 房间${roomName}已经存在${rType}的sell订单了`;
            }
            else if (mType == 'deal') {
                if (!thisRoom.memory.market['deal'])
                    thisRoom.memory.market['deal'] = [];
                var bR = true;
                for (var od of thisRoom.memory.market['deal']) {
                    if (od.rType == rType)
                        bR = false;
                }
                if (bR) {
                    thisRoom.memory.market['deal'].push({ rType: rType, num: num, price: price, unit: unit, mTyep: 'sell', retain: retain });
                    return `[market] 房间${roomName}成功下达deal的资源卖出指令,type:sell,rType:${rType},num:${num},price:${price},unit:${unit}`;
                }
                else
                    return `[market] 房间${roomName}已经存在${rType}的sell订单了`;
            }
        },
        // 查询正在卖的资源
        query(roomName) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[support] 不存在房间${roomName}`;
            let result = `[market] 目前房间${roomName}存在如下资源卖出订单:\n`;
            for (var mtype in thisRoom.memory.market)
                for (var i of thisRoom.memory.market[mtype])
                    result += `[${mtype}] 资源:${i.rType} 数量:${i.num}\n`;
            return result;
        },
        // 取消卖资源
        cancel(roomName, rType, mtype) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[support] 不存在房间${roomName}`;
            for (let i of thisRoom.memory.market[mtype]) {
                if (i.rType == rType) {
                    if (mtype == 'order') {
                        if (i.rType != 'energy')
                            delete thisRoom.memory.TerminalData[i.rType];
                        let order = Game.market.getOrderById(i.id);
                        if (order)
                            Game.market.cancelOrder(order.id);
                        var index = thisRoom.memory.market['order'].indexOf(i);
                        thisRoom.memory.market['order'].splice(index, 1);
                        return Colorful$1(`[market] 房间${roomName}取消资源[${rType}----${mtype}]卖出配置成功`, 'blue');
                    }
                    else {
                        if (i.rType != 'energy')
                            delete thisRoom.memory.TerminalData[i.rType];
                        var index = thisRoom.memory.market['deal'].indexOf(i);
                        thisRoom.memory.market['deal'].splice(index, 1);
                        return Colorful$1(`[market] 房间${roomName}取消资源[${rType}----${mtype}]卖出配置成功`, 'blue');
                    }
                }
            }
            return Colorful$1(`[market] 房间${roomName}取消资源[${rType}----${mtype}]卖出配置失败`, 'red');
        },
        revise(roomName, rType, mtype, mType, price) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[support] 不存在房间${roomName}`;
            for (let i of thisRoom.memory.market[mtype]) {
                if (i.rType == rType && i.mTyep == mType) {
                    i.price = price;
                    i.changePrice = true;
                    return Colorful$1(`[market] 房间${roomName}资源[${rType}-${mtype}-${mType}]改价成功-${price}`, 'blue');
                }
            }
            return Colorful$1(`[market] 房间${roomName}资源[${rType}-${mtype}-${mType}]改价失败`, 'red');
        },
        resetEnergyPrice(roomName) {
            if (roomName === "all") {
                let res = "";
                for (const name in Memory.RoomControlData) {
                    if (!Memory.rooms[name].MarketPrice) {
                        res += Colorful$1(`[market] 房间${name}能量价格重置失败\n`, 'red');
                        continue;
                    }
                    Memory.rooms[name].MarketPrice.buy = { low: 0, high: 0 };
                    Memory.rooms[name].MarketPrice.sell = { low: 0, high: 0 };
                    res += Colorful$1(`[market] 房间${name}能量价格重置成功\n`, 'green');
                }
                return res;
            }
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[support] 不存在房间${roomName}`;
            if (!thisRoom.memory.MarketPrice) {
                return Colorful$1(`[market] 房间${roomName}能量价格重置失败`, 'red');
            }
            thisRoom.memory.MarketPrice.buy = { low: 0, high: 0 };
            thisRoom.memory.MarketPrice.sell = { low: 0, high: 0 };
            return `[market] 房间${roomName}能量价格重置成功`;
        },
        addAutoBasic(roomName, rType, number, pricemax) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[market] 不存在房间${roomName}`;
            if (thisRoom.memory.AutoBasicmarket[rType]) {
                thisRoom.memory.AutoBasicmarket[rType].number = number;
                if (pricemax)
                    thisRoom.memory.AutoBasicmarket[rType].pricemax = pricemax;
            }
            let _data = {
                number: number
            };
            if (pricemax)
                _data.pricemax = pricemax;
            thisRoom.memory.AutoBasicmarket[rType] = _data;
            if (pricemax)
                return `[market][Auto] 房间${roomName},rType:${rType} ,number:${number} ,pricemax:${pricemax} 添加成功`;
            else
                return `[market][Auto] 房间${roomName},rType:${rType} ,number:${number} 添加成功  `;
        },
        CaddAutoBasic(roomName, rType) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[market] 不存在房间${roomName}`;
            if (!thisRoom.memory.AutoBasicmarket[rType])
                return `[market][Auto] 房间${roomName},rType:${rType} 查询失败`;
            delete thisRoom.memory.AutoBasicmarket[rType];
            return `[market][Auto] 房间${roomName},rType:${rType} 移除成功`;
        }
    },
    /* lab */
    lab: {
        // 初始化lab
        init(roomName) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[lab] 未找到房间${roomName},请确认房间!`;
            /* 初始化 原先配置清零 */
            myRoom.memory.StructureIdData.labInspect = {};
            let result = RecognizeLab(roomName);
            if (result == null)
                return `[lab] 房间${roomName}初始化合成lab信息失败!`;
            myRoom.memory.StructureIdData.labInspect['raw1'] = result.raw1;
            myRoom.memory.StructureIdData.labInspect['raw2'] = result.raw2;
            myRoom.memory.StructureIdData.labInspect['com'] = result.com;
            let str = '';
            str += `[lab] 房间${roomName}初始化lab信息成功!\n`;
            str += `底物lab:\n${result.raw1}\n${result.raw2}\n`;
            str += "合成lab:\n";
            for (let i of result.com)
                str += `${i}\n`;
            return str;
        },
        // 挂载具体合成任务
        compound(roomName, res, num) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[lab] 未找到房间${roomName},请确认房间`;
            var thisTask = myRoom.public_Compound(num, res);
            if (thisTask === null)
                return `[lab] 挂载合成任务失败!`;
            if (myRoom.AddMission(thisTask))
                return `[lab] 房间${roomName}合成${res}任务挂载成功! ${thisTask.Data.raw1} + ${thisTask.Data.raw2} = ${res}`;
            else
                return `[lab] 房间${roomName}挂载合成任务失败!`;
        },
        // 取消具体合成任务
        Ccompound(roomName) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[lab] 未找到房间${roomName},请确认房间`;
            for (var i of myRoom.memory.Misson['Room']) {
                if (i.name == '资源合成') {
                    if (myRoom.DeleteMission(i.id))
                        return `[lab] 房间${roomName}合成任务删除成功!`;
                }
            }
            return Colorful$1(`[lab] 房间${roomName}删除合成任务失败!`, 'red');
        },
        // lab合成规划 (自动执行具体合成任务 无需挂载)
        dispatch(roomName, res, num) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[lab] 未找到房间${roomName},请确认房间!`;
            if (!resourceComDispatch[res])
                return `不存在资源${res}!`;
            if (Object.keys(myRoom.memory.ComDispatchData).length > 0)
                return `[lab] 房间${roomName} 已经存在资源合成调度数据`;
            myRoom.memory.ComDispatchData = {};
            for (var i of resourceComDispatch[res]) {
                myRoom.memory.ComDispatchData[i] = { res: i, dispatch_num: num };
            }
            return `[lab] 已经修改房间${roomName}的合成规划数据, 为${resourceComDispatch[res]}, 数量：${num}`;
        },
        // 取消lab合成规划
        Cdispatch(roomName) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[lab] 未找到房间${roomName},请确认房间!`;
            myRoom.memory.ComDispatchData = {};
            return `[lab] 已经修改房间${roomName}的合成规划数据, 为{}.本房见现已无资源合成调度`;
        },
        /*增加lab合成保持任务*/
        addAuto(roomName, res, num) {
            if (num < 10000)
                return `[lab] 自动任务挂载不少于10000,请重新确认数量!`;
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[lab] 未找到房间${roomName},请确认房间!`;
            for (var i in myRoom.memory.Labautomatic.automaticData) {
                let Data = myRoom.memory.Labautomatic.automaticData[i];
                if (Data.Type == res) {
                    if (Data.Num != num) {
                        myRoom.memory.Labautomatic.automaticData[i].Num = num;
                        return `[lab] 房间${roomName}的自动合成调整, 已调整${res}自动合成, 数量：${num}`;
                    }
                    return `[lab] 房间${roomName}的自动合成调整, 已有${res}自动合成`;
                }
            }
            let Level = LabLevel[res];
            if (!Level)
                return `不存在资源${res} Level!`;
            myRoom.memory.Labautomatic.automaticData.push({ Type: res, Num: num, Level: Level });
            myRoom.memory.Labautomatic.automaticData.sort(compare$1('Level'));
            myRoom.memory.Labautomatic.automaticState = true;
            /*清空自动规划任务*/
            myRoom.memory.ComDispatchData = {};
            return `[lab] 房间${roomName}的自动合成调整, 新增${res}自动合成`;
        },
        /*删除lab合成保持任务*/
        delAuto(roomName, res) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[lab] 未找到房间${roomName},请确认房间!`;
            for (var i in myRoom.memory.Labautomatic.automaticData) {
                let Data = myRoom.memory.Labautomatic.automaticData[i];
                if (Data.Type == res) {
                    delete myRoom.memory.Labautomatic.automaticData[i];
                    var filtered = myRoom.memory.Labautomatic.automaticData.filter(function (el) {
                        return el != null;
                    });
                    myRoom.memory.Labautomatic.automaticData = filtered;
                    return `[lab] 房间${roomName}的自动合成调整, 已删除${res}自动合成`;
                }
            }
            return `[lab] 房间${roomName}的自动合成调整失败`;
        },
        /*清空lab合成保持任务*/
        cancelAuto(roomName) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[lab] 未找到房间${roomName},请确认房间!`;
            myRoom.memory.Labautomatic.automaticData = [];
            myRoom.memory.Labautomatic.automaticState = false;
            return `[lab] 已经清空房间${roomName}的自动合成数据, 已关闭Lab自动合成`;
        }
    },
    /* power */
    power: {
        // 开始、停止升级gpl
        switch(roomName) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[power] 未找到房间${roomName},请确认房间!`;
            if (!myRoom.memory.switch.StartPower)
                myRoom.memory.switch.StartPower = true;
            else
                myRoom.memory.switch.StartPower = false;
            return `[power] 房间${roomName}的power升级已经设置为${myRoom.memory.switch.StartPower}`;
        },
        // 节省能量和Power的模式
        save(roomName) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[power] 未找到房间${roomName},请确认房间!`;
            if (!myRoom.memory.switch.SavePower)
                myRoom.memory.switch.SavePower = true;
            else
                myRoom.memory.switch.SavePower = false;
            return `[power] 房间${roomName}的power升级的SavePower选项已经设置为${myRoom.memory.switch.SavePower}`;
        },
        stoppower() {
            if (!Memory.Systemswitch.SystemStopPower)
                Memory.Systemswitch.SystemStopPower = true;
            else
                Memory.Systemswitch.SystemStopPower = false;
            return `[power] 全局停止的power升级已经设置为${Memory.Systemswitch.SystemStopPower}`;
        },
        // 限制pc的技能
        option(roomName, stru) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[power] 未找到房间${roomName},请确认房间!`;
            let switch_;
            switch (stru) {
                case 'storage': {
                    switch_ = 'StopEnhanceStorage';
                    break;
                }
                case 'tower': {
                    switch_ = 'StopEnhanceTower';
                    break;
                }
                case 'lab': {
                    switch_ = 'StopEnhanceLab';
                    break;
                }
                case 'extension': {
                    switch_ = 'StopEnhanceExtension';
                    break;
                }
                case 'spawn': {
                    switch_ = 'StopEnhanceSpawn';
                    break;
                }
                case 'factory': {
                    switch_ = 'StopEnhanceFactory';
                    break;
                }
                case 'powerspawn': {
                    switch_ = 'StopEnhancePowerSpawn';
                    break;
                }
                default: {
                    return `[power] stru数据错误!`;
                }
            }
            if (!myRoom.memory.switch[switch_]) {
                myRoom.memory.switch[switch_] = true;
                return `[power] 房间${roomName}的${switch_}选项调整为true! 将不执行对应的power操作`;
            }
            else {
                delete myRoom.memory.switch[switch_];
                return `[power] 房间${roomName}的${switch_}选项调整为false! 将执行对应的power操作`;
            }
        },
        // 输出pc的技能限制清单
        show(roomName) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[power] 未找到房间${roomName},请确认房间!`;
            let list = [
                'StopEnhanceStorage',
                'StopEnhanceTower',
                'StopEnhanceLab',
                'StopEnhanceExtension',
                'StopEnhanceFactory',
                'StopEnhancePowerSpawn'
            ];
            let result = `[power] 房间${roomName}的power操作开关:\n`;
            for (var i of list) {
                if (myRoom.memory.switch[i])
                    result += Colorful$1(`${i}:true\n`, 'red', true);
                else
                    result += Colorful$1(`${i}:false\n`, 'green', true);
            }
            return result;
        },
        // 创建pc
        create(roomName, pcType) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[power] 未找到房间${roomName},请确认房间!`;
            if (!['queen'].includes(pcType))
                return `[power] 不存在该类型pc!`;
            if (Game.powerCreeps[`${roomName}/${pcType}/${Game.shard.name}`])
                return `[power] 已经存在名为${roomName}/${pcType}/${Game.shard.name}的pc了!`;
            let result;
            if (pcType == 'queen')
                result = PowerCreep.create(`${roomName}/${pcType}/${Game.shard.name}`, POWER_CLASS.OPERATOR);
            if (result == 0) {
                return `[power] 房间${roomName}成功创建${pcType}类型pc!`;
            }
            else
                return `[power] 创建失败,错误码:${result}`;
        },
        // 删除pc
        del(name, pass) {
            if (!Game.powerCreeps[name])
                return `[power] 不存在名称为${name}的pc!`;
            if (!pass)
                return `[power] 未确认,验证不通过!`;
            Game.powerCreeps[name].suicide();
            Game.powerCreeps[name].delete();
            return `[power] 名称为${name}的pc已经删除! 如非测试模式,可能未立即删除!请等候24小时!`;
        }
    },
    /* 过道行为 */
    cross: {
        // 初始化过道任务
        init(roomName, relateRoom) {
            relateRoom = relateRoom; // ['start'].concat(relateRoom)
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[cross] 不存在房间${roomName}`;
            if (thisRoom.controller.level < 8)
                return `[cross] 房间${roomName}控制器等级不足!`;
            var thisTask = {
                name: "过道采集",
                range: 'Room',
                delayTick: 99999,
                Data: {
                    power: false,
                    deposit: false,
                    relateRooms: relateRoom
                }
            };
            if (thisRoom.AddMission(thisTask))
                return `[cross] 房间${roomName}初始化过道采集任务成功! 房间：${relateRoom}`;
            else
                return `[cross] 房间${roomName}初始化过道采集任务失败! 请检查房间内是否已经存在该任务!`;
        },
        switch(roomName) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[cross] 不存在房间${roomName}`;
            thisRoom.memory.switch.StopCross = !thisRoom.memory.switch.StopCross;
            if (thisRoom.memory.switch.StopCross)
                return `[cross] 房间${roomName}关闭过道!`;
            return `[cross] 房间${roomName}开启过道!`;
        },
        // active power
        power(roomName) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[cross] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Room']) {
                if (i.name == '过道采集') {
                    i.Data.power = !i.Data.power;
                    if (i.Data.power)
                        return Colorful$1(`[cross] 房间${roomName}过道采集任务的power属性已经更改为${i.Data.power}`, 'blue');
                    else
                        return Colorful$1(`[cross] 房间${roomName}过道采集任务的power属性已经更改为${i.Data.power}`, 'yellow');
                }
            }
            return `[cross] 房间${roomName}更改过道采集任务power属性失败! 请检查房间内是否已经存在该任务!`;
        },
        deposit(roomName) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[cross] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Room']) {
                if (i.name == '过道采集') {
                    i.Data.deposit = !i.Data.deposit;
                    if (i.Data.deposit)
                        return Colorful$1(`[cross] 房间${roomName}过道采集任务的deposit属性已经更改为${i.Data.deposit}`, 'blue');
                    else
                        return Colorful$1(`[cross] 房间${roomName}过道采集任务的deposit属性已经更改为${i.Data.deposit}`, 'yellow');
                }
            }
            return `[cross] 房间${roomName}更改过道采集任务deposit属性失败! 请检查房间内是否已经存在该任务!`;
        },
        room(roomName, roomData) {
            roomData = roomData;
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[cross] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Room']) {
                if (i.name == '过道采集') {
                    i.Data.relateRooms = roomData;
                    return `[cross] 房间${roomName}过道采集任务的房间已经更改为${roomData}`;
                }
            }
            return `[cross] 房间${roomName}更改过道采集任务deposit属性失败! 请检查房间内是否已经存在该任务!`;
        },
        /* 删除某个房间 */
        remove(roomName, delRoomName) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[cross] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Room']) {
                if (i.name == '过道采集') {
                    /* 进行删除 */
                    for (var j of i.Data.relateRooms) {
                        if (j == delRoomName) {
                            var list = i.Data.relateRooms;
                            var index = list.indexOf(j);
                            list.splice(index, 1);
                            return `[cross] 房间${roomName}的过道采集清单里已经删除房间${j}! 现有房间列表为${i.Data.relateRooms}`;
                        }
                    }
                    return `[cross] 房间${roomName}过道采集任务的房间清单未找到房间${delRoomName}`;
                }
            }
            return `[cross] 房间${roomName}更改过道采集任务房间清单失败! 请检查房间内是否已经存在该任务!`;
        },
        /* 增加某个房间 */
        add(roomName, addRoomName) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[cross] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Room']) {
                if (i.name == '过道采集') {
                    /* 进行删除 */
                    if (isInArray(i.Data.relateRooms, addRoomName))
                        return `[cross] 房间${roomName}过道采集任务的房间清单已经存在房间${addRoomName}`;
                    else {
                        i.Data.relateRooms.push(addRoomName);
                        return `[cross] 房间${roomName}过道采集任务的房间清单已经添加房间${addRoomName}! 以下为房间清单：${i.Data.relateRooms}`;
                    }
                }
            }
            return `[cross] 房间${roomName}更改过道采集任务房间清单失败! 请检查房间内是否已经存在该任务!`;
        },
        /* 删除某个具体power任务 */
        delPower(roomName, disRoom) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[cross] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Creep']) {
                if (i.name == 'power采集' && i.Data.room == disRoom) {
                    if (thisRoom.DeleteMission(i.id))
                        return `[cross] 删除${roomName}-->${disRoom}的power采集任务成功!`;
                    else
                        return `[cross] 删除${roomName}-->${disRoom}的power采集任务失败!`;
                }
            }
            return `[cross] 未找到${roomName}-->${disRoom}的power采集任务`;
        },
        // 输出过道详细信息
        show(roomName) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[cross] 不存在房间${roomName}`;
            var str = '';
            for (var i of thisRoom.memory.Misson['Room']) {
                if (i.name == '过道采集') {
                    str += `[cross] 房间${roomName}的过道采集任务详情配置如下：\n`;
                    str += `     房间：${i.Data.relateRooms}\n`;
                    str += `     power:${i.Data.power}\n`;
                    str += `     deposit:${i.Data.deposit}\n`;
                    str += `     目前存在如下任务：`;
                    /* 寻找目前存在的过道采集任务 */
                    for (var j of thisRoom.memory.Misson['Creep']) {
                        if (j.name == 'power采集')
                            str += `power采集任务 ${roomName}-->${j.Data.room}  state:${j.Data.state}\n`;
                        if (j.name == 'deposit采集')
                            str += `deposit采集任务 ${roomName}-->${j.Data.room}  state:${j.Data.state}\n`;
                    }
                    return str;
                }
            }
            return `[cross] 房间${roomName}展示过道采集任务失败! 请检查房间内是否已经存在该任务!`;
        },
        /* 取消过道采集开关 */
        cancel(roomName) {
            var thisRoom = Game.rooms[roomName];
            if (!thisRoom)
                return `[cross] 不存在房间${roomName}`;
            for (var i of thisRoom.memory.Misson['Room']) {
                if (i.name == '过道采集') {
                    thisRoom.DeleteMission(i.id);
                    return `[cross] 房间${roomName}已经取消过道采集任务!`;
                }
            }
            return `[cross] 房间${roomName}取消过道采集任务失败! 请检查房间内是否已经存在该任务!`;
        },
    },
    /* 工厂行为 */
    factory: {
        // 启动、关闭工厂
        switch(roomName) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[factory] 未找到房间${roomName},请确认房间!`;
            if (!myRoom.memory.switch.StopFactory)
                myRoom.memory.switch.StopFactory = true;
            else
                myRoom.memory.switch.StopFactory = false;
            if (myRoom.memory.switch.StopFactory)
                return `[factory] 房间${roomName}的工厂加工已经停止!`;
            return `[factory] 房间${roomName}的工厂加工已经启动!`;
        },
        // 输出工厂状态
        show(roomName) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[factory] 未找到房间${roomName},请确认房间!`;
            if (myRoom.memory.switch.StopFactory)
                return `[factory] 房间${roomName}工厂停工中`;
            let result = `[factory] 房间${roomName}的工厂加工信息如下:\n`;
            result += `工厂等级:${myRoom.memory.productData.level}\n`;
            result += `工厂状态:${myRoom.memory.productData.state}\n`;
            result += `基本加工资源列表:\n`;
            for (var i in myRoom.memory.productData.baseList) {
                result += `\t${i}:${myRoom.memory.productData.baseList[i].num}\n`;
            }
            result += `流水线商品:${myRoom.memory.productData.flowCom}\n`;
            if (myRoom.memory.productData.producing)
                result += `正在合成的资源:${myRoom.memory.productData.producing.com ? myRoom.memory.productData.producing.com : '无'},数量：${myRoom.memory.productData.producing.num ? myRoom.memory.productData.producing.num : '无'}\n`;
            return result;
        },
        // 初始化等级
        level(roomName) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[factory] 未找到房间${roomName},请确认房间!`;
            if (!Game.powerCreeps[`${myRoom.name}/queen/${Game.shard.name}`])
                return `[factory] ${myRoom.name}此房间无pc请先孵化pc!`;
            myRoom.enhance_factory(true);
            return `[factory] 房间${roomName}发布pc确定工厂等级任务成功!`;
        },
        // 添加工厂基本物资合成清单
        add(roomName, cType, num) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[factory] 未找到房间${roomName},请确认房间!`;
            let factory_ = myRoom.GetStructData(STRUCTURE_FACTORY);
            if (!factory_)
                return Colorful$1(`[factory] 未找到房间${roomName}的工厂!`, 'red', true);
            return factory_.add(cType, num);
        },
        // 删除工厂基本物资合成
        remove(roomName, cType) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[factory] 未找到房间${roomName},请确认房间!`;
            let factory_ = myRoom.GetStructData(STRUCTURE_FACTORY);
            if (!factory_)
                return Colorful$1(`[factory] 未找到房间${roomName}的工厂!`, 'red', true);
            return factory_.remove(cType);
        },
        // 设置工厂流水线生产物资
        set(roomName, cType) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[factory] 未找到房间${roomName},请确认房间!`;
            let factory_ = myRoom.GetStructData(STRUCTURE_FACTORY);
            if (!factory_)
                return Colorful$1(`[factory] 未找到房间${roomName}的工厂!`, 'red', true);
            return factory_.set(cType);
        },
        // 取消工厂流水线生产物资
        del(roomName, cType) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[factory] 未找到房间${roomName},请确认房间!`;
            let factory_ = myRoom.GetStructData(STRUCTURE_FACTORY);
            if (!factory_)
                return Colorful$1(`[factory] 未找到房间${roomName}的工厂!`, 'red', true);
            return factory_.del(cType);
        },
        decompress(roomName, cType, num) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[factory] 未找到房间${roomName},请确认房间!`;
            let factory_ = myRoom.GetStructData(STRUCTURE_FACTORY);
            if (!factory_)
                return Colorful$1(`[factory] 未找到房间${roomName}的工厂!`, 'red', true);
            if (myRoom.memory.productData.unzip[cType])
                return Colorful$1(`[factory] 房间${roomName}已经存在${cType}的解压缩任务!`, 'red', true);
            myRoom.memory.productData.unzip[cType] = { num: num };
            return Colorful$1(`[factory] 房间${roomName}已经设置${cType}的解压缩任务, 数量:${num}!`, 'blue', true);
        },
        Cdecompress(roomName, cType) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[factory] 未找到房间${roomName},请确认房间!`;
            let factory_ = myRoom.GetStructData(STRUCTURE_FACTORY);
            if (!factory_)
                return Colorful$1(`[factory] 未找到房间${roomName}的工厂!`, 'red', true);
            if (!myRoom.memory.productData.unzip[cType])
                return Colorful$1(`[factory] 房间${roomName}不存在${cType}的解压缩任务!`, 'red', true);
            delete myRoom.memory.productData.unzip[cType];
            return Colorful$1(`[factory] 房间${roomName} ${cType}的解压缩任务已经删除!`, 'blue', true);
        },
        autoDecompress(roomName) {
            var myRoom = Game.rooms[roomName];
            if (!myRoom)
                return `[factory] 未找到房间${roomName},请确认房间!`;
            let factory_ = myRoom.GetStructData(STRUCTURE_FACTORY);
            if (!factory_)
                return Colorful$1(`[factory] 未找到房间${roomName}的工厂!`, 'red', true);
            if (!myRoom.memory.DynamicConfig)
                myRoom.memory.DynamicConfig = {};
            if (myRoom.memory.DynamicConfig.Dynamicfactoryuncondense) {
                myRoom.memory.DynamicConfig.Dynamicfactoryuncondense = false;
                return Colorful$1(`[factory] 房间${roomName} 的bar自动解压关闭!`, 'red', true);
            }
            myRoom.memory.DynamicConfig.Dynamicfactoryuncondense = true;
            return Colorful$1(`[factory] 房间${roomName} 的bar自动解压启动!`, 'blue', true);
        }
    }
};

// 定义好挂载顺序
const plugins$1 = [
    frameExtension,
    actionExtension,
    staticExtension,
    behaviourExtension,
    aiwarExtension,
];
/**
* 依次挂载所有的拓展
*/
var mountConsole = () => plugins$1.forEach(plugin => _.assign(global, plugin));

class linkExtension extends StructureLink {
    ManageMission() {
        if (this.cooldown && this.cooldown > 0)
            return; /*唯一任务当前只需优先检测CD*/
        if (!this.room.memory.Misson['Structure'])
            this.room.memory.Misson['Structure'] = [];
        var allmyTask = [];
        for (var task of this.room.memory.Misson['Structure']) {
            if (!task.structure)
                continue;
            if (isInArray(task.structure, this.id)) {
                allmyTask.push(task);
            }
        }
        /* 按照优先级排序 */
        if (allmyTask.length <= 0)
            return;
        else if (allmyTask.length >= 1)
            allmyTask.sort(compare$1('level'));
        /* 处理任务 */
        let thisTask = allmyTask[0];
        if (thisTask.delayTick < 99995)
            thisTask.delayTick--;
        switch (thisTask.name) {
            case "链传送能": {
                this.Handle_Link(thisTask);
                break;
            }
        }
    }
    /* 链传送能 */
    Handle_Link(task) {
        if (this.cooldown && this.cooldown > 0)
            return;
        /* 执行任务 */
        if (!task.Data || !task.Data.disStructure) {
            this.room.DeleteMission(task.id);
        }
        if (this.store.getUsedCapacity('energy') < 700) {
            /* 如果有传送任务但是没有足够能量，只要是centerlink就下达搬运任务 */
            if (this.room.memory.StructureIdData.center_link == this.id) {
                let storage = this.room.storage;
                if (!storage)
                    return;
                if (storage.store.getUsedCapacity('energy') < 1000)
                    return;
                if (this.room.Check_Carry('manage', storage.pos, this.pos, 'energy')) {
                    var thisTask = this.room.public_Carry({ 'manage': { num: 1, bind: [] } }, 20, this.room.name, storage.pos.x, storage.pos.y, this.room.name, this.pos.x, this.pos.y, 'energy', this.store.getFreeCapacity());
                    this.room.AddMission(thisTask);
                }
            }
            return;
        }
        var dis = Game.getObjectById(task.Data.disStructure);
        if (!dis || dis.store.getUsedCapacity('energy') >= 790) {
            /* 如果未找到link 或者 对方link满了，就删除任务 */
            this.room.DeleteMission(task.id);
            return;
        }
        /* 传完就删除任务 */
        this.transferEnergy(dis);
        this.room.DeleteMission(task.id);
    }
}

// terminal 扩展
class terminalExtension extends StructureTerminal {
    ManageMission() {
        // if (this.room.MissionNum('Creep', '急速冲级') > 0) return   // 急速冲级状态下停止terminal功能
        if (this.room.controller.level < 6)
            return;
        if (Game.cpu.bucket < 1000 && Memory.StopPixel)
            return;
        var allmyTask = [];
        for (var task of this.room.memory.Misson['Structure']) {
            if (!task.structure)
                continue;
            if (isInArray(task.structure, this.id)) {
                allmyTask.push(task);
            }
        }
        let thisTask = null;
        /* 按照优先级排序 */
        if (allmyTask.length >= 1)
            allmyTask.sort(compare$1('level'));
        thisTask = allmyTask[0];
        this.ModifypriceMarket(); /*价格调整工具*/
        this.EnergyreplenishMarket(); /*动态报价工具*/
        if (!thisTask || !isInArray(['资源传送'], thisTask.name)) {
            /* terminal默认操作*/
            this.ResourceBalance(); // 资源平衡
            this.ResourceMarket(); // 资源买卖
            if (!thisTask)
                return;
        }
        if (thisTask.delayTick < 99995)
            thisTask.processing = true;
        switch (thisTask.name) {
            case "资源传送": {
                this.ResourceSend(thisTask);
                break;
            }
            case "资源购买": {
                this.ResourceDeal(thisTask);
                break;
            }
        }
    }
    /**
     * 资源平衡函数,用于平衡房间中资源数量以及资源在terminal和storage中的分布,尤其是能量和原矿
     */
    ResourceBalance() {
        this.RsourceMemory();
        // terminal资源平衡
        if ((Game.time - global.Gtime[this.room.name]) % 7)
            return;
        let storage_ = this.room.storage;
        if (!this.room.storage) {
            console.log(`找不到global.Stru['${this.room.name}']['storage]!`);
            return;
        }
        for (var i in this.store) {
            if (this.room.RoleMissionNum('manage', '物流运输') >= 1)
                return;
            let num = this.store[i]; // 数量
            if (!this.room.memory.TerminalData[i] || !this.room.memory.TerminalData[i].num) // terminalData里没有该数据
             {
                if (storage_.store.getFreeCapacity() < 40000)
                    continue;
                let thisTask = this.room.public_Carry({ 'manage': { num: 1, bind: [] } }, 20, this.room.name, this.pos.x, this.pos.y, this.room.name, storage_.pos.x, storage_.pos.y, i, num);
                this.room.AddMission(thisTask);
            }
            else {
                if (num > this.room.memory.TerminalData[i].num) {
                    if (storage_.store.getFreeCapacity() < 40000)
                        continue;
                    let thisTask = this.room.public_Carry({ 'manage': { num: 1, bind: [] } }, 20, this.room.name, this.pos.x, this.pos.y, this.room.name, storage_.pos.x, storage_.pos.y, i, num - this.room.memory.TerminalData[i].num);
                    this.room.AddMission(thisTask);
                }
            }
        }
        for (var i in this.room.memory.TerminalData) {
            if (this.room.RoleMissionNum('manage', '物流运输') >= 1)
                return;
            if (!this.room.memory.TerminalData[i].fill)
                continue;
            let num = this.store.getUsedCapacity(i);
            if (num < this.room.memory.TerminalData[i].num) {
                if (this.store.getFreeCapacity() < 5000)
                    continue;
                if (i == 'energy') {
                    if (storage_.store.getUsedCapacity('energy') <= 20000)
                        continue;
                }
                else {
                    if (storage_.store.getUsedCapacity(i) <= 0 && storage_.store.getUsedCapacity(i) + num < this.room.memory.TerminalData[i].num)
                        continue;
                }
                let thisTask = this.room.public_Carry({ 'manage': { num: 1, bind: [] } }, 20, this.room.name, storage_.pos.x, storage_.pos.y, this.room.name, this.pos.x, this.pos.y, i, this.room.memory.TerminalData[i].num - num > 0 ? this.room.memory.TerminalData[i].num - num : 100);
                this.room.AddMission(thisTask);
            }
        }
    }
    /**
     * 资源记忆更新函数
     * */
    RsourceMemory() {
        /* terminal自身资源管理 */
        var terminalData = this.room.memory.TerminalData;
        for (var i in terminalData) {
            /* 数量小于0就删除数据，节省memory */
            if (terminalData[i].num <= 0)
                delete terminalData[i];
        }
    }
    /**
     * 负责各种情况下能量不足的市场调度操作
     */
    EnergyreplenishMarket() {
        switch (Game.shard.name) {
            case 'shard3':
                if ((Game.time - global.Gtime[this.room.name]) % 27)
                    return;
                break;
            default:
                if ((Game.time - global.Gtime[this.room.name]) % 15)
                    return;
                break;
        }
        // 确定当前的能量数量信息
        let storeNum = this.room.storage.store.getUsedCapacity('energy') + this.store.getUsedCapacity('energy');
        if (storeNum >= 250000)
            return;
        if (!this.room.storage.my && storeNum > 150000)
            return;
        let Demandlevel = 0;
        let addnumber = 30000;
        if (this.room.controller.level < 8) {
            addnumber = 100000;
            let lastDayAve = avePrice('energy', 1);
            let threeDayAve = avePrice('energy', 3);
            let lastWeekAve = avePrice('energy', 7);
            addnumber -= Math.floor(75000 / (1 + Math.exp(-3 * (lastDayAve - threeDayAve))));
            addnumber -= Math.floor(25000 / (1 + Math.exp(-1 * (lastDayAve - lastWeekAve))));
        }
        addnumber = (addnumber < 20000) ? 20000 : addnumber;
        if (this.store.getFreeCapacity('energy') < addnumber) {
            addnumber = this.store.getFreeCapacity('energy');
        }
        /*急需进行能量的补充操作*/
        if (storeNum < 100000) {
            Demandlevel = 1; /*紧急*/
        }
        else if (storeNum < 250000) {
            Demandlevel = 2; /*普通*/
        }
        if (Demandlevel > 0) {
            if (!Game.cpu.generatePixel) {
                let dispatchTask = {
                    sourceRoom: this.room.name,
                    rType: 'energy',
                    num: addnumber,
                    delayTick: 300,
                    conditionTick: 20,
                    buy: true,
                    mtype: "deal"
                };
                Memory.ResourceDispatchData.push(dispatchTask);
                // Game.market.deal('62643960d8dac7fd5f21810b', 100000, this.room.name);
                return;
            }
            else {
                if (Game.market.credits && Game.market.credits < 1e6) {
                    return;
                }
            }
            /*检索房间内的所有订单，同时进行匹配,*/
            /*取出当前类型的基准价格*/
            let price_ = 0;
            Demandlevel = 1;
            if (this.room.memory.MarketPrice.Dynamicprice) {
                switch (Demandlevel) {
                    case 1:
                        price_ = this.room.memory.MarketPrice.buy.high;
                        break;
                    case 2:
                        price_ = this.room.memory.MarketPrice.buy.low;
                        break;
                }
            }
            // price_ = this.room.memory.MarketPrice.buy.low;
            if (price_ <= 0) {
                price_ = avePrice('energy', 1) - 0.5;
            }
            price_ = Math.floor(price_ * 1000) / 1000;
            /*判定是否有对应价格区间的订单信息*/
            let order_ = gethaveOrder(this.room.name, 'energy', 'buy', price_, -0.5);
            // console.log(this.room.name, JSON.stringify(order_), price_, price_ - 0.5)
            // return;
            if (!order_) {
                // console.log(this.room.name, '发起动态报价')
                let result = Game.market.createOrder({
                    type: ORDER_BUY,
                    resourceType: 'energy',
                    price: price_,
                    totalAmount: addnumber,
                    roomName: this.room.name
                });
                if (result != OK) {
                    console.log("创建能量订单出错,房间", this.room.name);
                    return;
                }
                if (this.room.memory.MarketPrice.order_list.length < 1) {
                    this.room.memory.MarketPrice.order_list = [];
                }
                this.room.memory.MarketPrice.order_list.push({
                    _time: Game.time,
                    Demandlevel: Demandlevel,
                    type: ORDER_BUY,
                    resourceType: 'energy',
                    price: price_,
                    totalAmount: addnumber,
                    roomName: this.room.name,
                    ignore: false
                });
                switch (Demandlevel) {
                    case 1:
                        if (this.room.memory.MarketPrice.buy.high == 0) {
                            this.room.memory.MarketPrice.buy.high = price_;
                        }
                        break;
                    case 2:
                        if (this.room.memory.MarketPrice.buy.low == 0) {
                            this.room.memory.MarketPrice.buy.low = price_;
                        }
                        break;
                }
                console.log(Colorful$1(`[补充]房间${this.room.name}创建energy订单,价格:${price_};数量:${addnumber}`, 'green', true));
            }
        }
    }
    ModifypriceMarket() {
        switch (Game.shard.name) {
            case 'shard3':
                if ((Game.time - global.Gtime[this.room.name]) % 5)
                    return;
                break;
            default:
                if ((Game.time - global.Gtime[this.room.name]) % 2)
                    return;
                break;
        }
        /**
         * 存在订单进行订单检查
         * [普通] 300 tick 减少报价  600 tick 自动涨价
         * [紧急] 200 tick 减少报价  400 tick 自动涨价
         * 订单如果已经完结则自动根据当前价格进行标记下次的报价，本模块只处理实时涨价操作，不处理实时降价操作
         * 操作涨价的订单，需要进行订单重新备份进程，需要其他模块介入帮助进行过期订单的清理操作
         * */
        if (Object.keys(global.Marketorder).length < 1) {
            /*需要对已有的订单进行初始化操作*/
            for (let j in Game.market.orders) {
                let order = Game.market.orders[j];
                if (order.roomName) {
                    if (!global.Marketorder[order.roomName]) {
                        global.Marketorder[order.roomName] = [];
                    }
                    global.Marketorder[order.roomName][order.id] = order;
                }
            }
        }
        if (this.room.memory.MarketPrice.order_list.length > 0) {
            for (let j in this.room.memory.MarketPrice.order_list) {
                // console.log(this.room.name, '订单进入检测')
                let order_data = this.room.memory.MarketPrice.order_list[j];
                if (!order_data.order_id) {
                    /*在已有的订单中进行检索操作*/
                    for (let o_i in global.Marketorder[this.room.name]) {
                        let o_d = global.Marketorder[this.room.name][o_i];
                        if (order_data._time >= o_d.created && order_data.resourceType == o_d.resourceType && order_data.price == o_d.price && order_data.totalAmount == o_d.totalAmount) {
                            this.room.memory.MarketPrice.order_list[j].order_id = o_d.id; /*寻找到有效订单信息*/
                            this.room.memory.MarketPrice.order_list[j]._time = o_d.created; /*复制一级定价参数*/
                            order_data = this.room.memory.MarketPrice.order_list[j]; /*重新进行赋值*/
                            break;
                        }
                    }
                }
                /**
                 * 开始进行报价检测，根据类型来判定对应的tick间隔信息
                */
                let up_tick = 500;
                let drop_tick = 300;
                if (this.room.controller.level >= 8) {
                    switch (order_data.Demandlevel) {
                        case 1:
                            up_tick = 100;
                            drop_tick = 75;
                            break;
                        case 2:
                            up_tick = 200;
                            drop_tick = 150;
                            break;
                    }
                }
                else {
                    up_tick = 40;
                    drop_tick = 30;
                }
                if (!global.Marketorder[this.room.name]) {
                    break;
                }
                let Gatorder = global.Marketorder[this.room.name][order_data.order_id];
                if (!Gatorder) {
                    /*错误的订单信息，移除当前信息*/
                    console.log(JSON.stringify(global.Marketorder[this.room.name]));
                    console.log(JSON.stringify(this.room.memory.MarketPrice.order_list[j]));
                    console.log(Colorful$1(`[订单异常]房间${this.room.name}订单异常,异常完结`, 'red', true));
                    delete this.room.memory.MarketPrice.order_list[j];
                    continue; /*当前订单解除*/
                }
                // console.log(JSON.stringify(Gatorder))
                /*检测订单现在的状态信息*/
                let order_time = Game.time - order_data._time;
                if (Gatorder.remainingAmount <= 0) {
                    // console.log(this.room.name, '订单已完结', order_time, drop_tick)
                    /*检查订单是否已经完结，如果完结进行降价检测操作*/
                    let end_time = Game.time - Gatorder.created;
                    let over_price = order_data.price;
                    if (end_time < drop_tick) {
                        // console.log(this.room.name, '订单触发调价')
                        if (!order_data.ignore) {
                            /*非忽略订单。执行价格更新*/
                            let reduceprice = 0.1;
                            reduceprice += Math.min((Math.floor(drop_tick / order_time) * 0.05), 0.90); //最多下调1cr
                            order_data.price = (Number(order_data.price) - reduceprice).toFixed(3).toString();
                            console.log(Colorful$1(`[调价下跌]房间${this.room.name}订单已完结,调价:${order_data.price}已存储`, 'gold', true));
                            switch (order_data.Demandlevel) {
                                case 1:
                                    if (this.room.memory.MarketPrice.buy.high > order_data.price) {
                                        this.room.memory.MarketPrice.buy.high = order_data.price;
                                    }
                                    break;
                                case 2:
                                    if (this.room.memory.MarketPrice.buy.low > order_data.price) {
                                        this.room.memory.MarketPrice.buy.low = order_data.price;
                                    }
                                    break;
                            }
                        }
                    }
                    console.log(Colorful$1(`[订单完结]房间${this.room.name}订单已完结,价格:${over_price},耗时${end_time}`, 'green', true));
                    /*执行降价操作，同时当前订单完结以及关闭*/
                    Game.market.cancelOrder(order_data.order_id);
                    delete this.room.memory.MarketPrice.order_list[j];
                }
                else {
                    /*订单当前可用检测是否符合操作要求*/
                    if (order_data.ignore && Gatorder.active) {
                        /*重新标记订单有效性*/
                        this.room.memory.MarketPrice.order_list[j].ignore = true;
                        this.room.memory.MarketPrice.order_list[j]._time = Game.time;
                        order_data = this.room.memory.MarketPrice.order_list[j]; /*重新进行赋值*/
                    }
                    if (!order_data.ignore && !Gatorder.active) {
                        /*忽略当前订单信息*/
                        this.room.memory.MarketPrice.order_list[j].ignore = false;
                        order_data = this.room.memory.MarketPrice.order_list[j]; /*重新进行赋值*/
                    }
                    /*进行正常的检测序列*/
                    if (order_time > up_tick) {
                        /*检查一个提价倍率信息*/
                        let _x_p = Math.floor((Math.floor(Game.time) - Math.floor(Gatorder.created)) / drop_tick);
                        /*超时额定的间隔-进行涨价处理*/
                        let increase = 0.05;
                        let Salesmargin = (Number(Gatorder.remainingAmount) / Number(order_data.totalAmount));
                        let _add_p = increase * Salesmargin;
                        order_data.price = (Number(order_data.price) + _add_p).toFixed(3);
                        Game.market.changeOrderPrice(order_data.order_id, order_data.price); /*订单进行价格更新*/
                        this.room.memory.MarketPrice.order_list[j]._time = Game.time - Math.ceil(drop_tick / _x_p); /*涨价后价格重新赋值-这个价格被采纳将不会触发降价*/
                        this.room.memory.MarketPrice.order_list[j].price = order_data.price; /*价格赋值*/
                        console.log(Colorful$1(`[调价上涨]房间${this.room.name}调整energy,订单${order_data.order_id},价格:${order_data.price};`, 'yellow', true));
                        switch (order_data.Demandlevel) {
                            case 1:
                                if (this.room.memory.MarketPrice.buy.high < order_data.price) {
                                    this.room.memory.MarketPrice.buy.high = order_data.price;
                                }
                                break;
                            case 2:
                                if (this.room.memory.MarketPrice.buy.low < order_data.price) {
                                    this.room.memory.MarketPrice.buy.low = order_data.price;
                                }
                                break;
                        }
                    }
                }
            }
        }
        // if (this.room.memory.MarketPrice.order_list.length < 1) {
        //     /* 没有标记订单的情况下 清理过期订单 */
        //     for (let j in Game.market.orders) {
        //         let order = Game.market.getOrderById(j);
        //         if (!order.remainingAmount) Game.market.cancelOrder(j);
        //     }
        //     return
        // }
        this.room.memory.MarketPrice.order_list = this.room.memory.MarketPrice.order_list.filter(n => n);
    }
    /**
     * 资源买卖订单价格自助排序
    */
    ResourceMarketdeal(market_deal, toll = 1) {
        var orders = Game.market.getAllOrders({ type: ORDER_BUY, resourceType: market_deal.rType });
        let a = 100;
        (COMMODITIES[market_deal.rType] && COMMODITIES[market_deal.rType].level) ? a = 0 : a;
        if (COMMODITIES[market_deal.rType] && COMMODITIES[market_deal.rType].level)
            ;
        if (market_deal.price)
            ;
        let order_ = [];
        for (let orders_data of orders) {
            if (Object.keys(Game.rooms).includes(orders_data.roomName))
                continue; /*过滤自己房间的订单*/
            if (orders_data.price < market_deal.price)
                continue; /*价格不满足*/
            if (orders_data.amount < a && market_deal.num >= a)
                continue; /*订单数量过少*/
            let cost = Game.market.calcTransactionCost(1000, orders_data.roomName, this.room.name);
            if (cost / 1000 > toll && market_deal.num >= a)
                continue; /*运费过高*/
            let energy_cr = avePrice('energy', 1);
            order_.push({
                id: orders_data.id,
                amount: orders_data.amount,
                price: orders_data.price - energy_cr * (cost / 1000)
            });
        }
        if (order_.length > 0) {
            /*存在有效订单进行排序操作*/
            var newOrderList = order_.sort(compare$1('price'));
            let OrderData = newOrderList[newOrderList.length - 1];
            // console.log(JSON.stringify(OrderData))
            return OrderData;
        }
        return null;
        // var orders = Game.market.getAllOrders(order => order.resourceType == i.rType &&
        //     price <= order.price && order.type == ORDER_BUY && order.amount > a && order.amount <= b)
    }
    /**
     * 资源买卖函数 买卖资源(不deal购买)
     */
    ResourceMarket() {
        if (Game.cpu.bucket < 7000 && Memory.StopPixel)
            return;
        let v_market = 1;
        if (!Memory.Systemswitch.SystemValidmarket) {
            if (Game.shard.name == 'shard3') {
                v_market = 23;
            }
            else {
                v_market = 2;
            }
            if ((Game.time - global.Gtime[this.room.name]) % v_market)
                return;
        }
        // 能量自动购买区 [与MarketData无关] storage内能量小于200000时自动购买
        /* 清理过期订单 */
        // if (Object.keys(Game.market.orders).length > 80) {
        //     for (let j in Game.market.orders) {
        //         let order = Game.market.getOrderById(j);
        //         if (!order.remainingAmount) Game.market.cancelOrder(j);
        //     }
        // }
        if (!this.room.storage) {
            console.log(`['${this.room.name}]不存在storage!`);
            return;
        }
        let storage_ = this.room.storage;
        /* 仓库资源过于饱和就卖掉能量 超出则不卖(考虑到pc技能间隔) */
        if (this.room.controller.level >= 8 && storage_.store.getCapacity() >= storage_.store.getUsedCapacity() && (storage_.store.getFreeCapacity() < 50000 || storage_.store.getUsedCapacity(RESOURCE_ENERGY) > 1000000)) {
            /* 如果仓库饱和(小于200k空间)，而且仓库能量超过400K,就卖能量 */
            if (storage_.store.getUsedCapacity('energy') > 350000) {
                if (!this.room.memory.market)
                    this.room.memory.market = {};
                if (!this.room.memory.market['deal'])
                    this.room.memory.market['deal'] = [];
                var bR = true;
                for (var od of this.room.memory.market['deal']) {
                    if (od.rType == 'energy')
                        bR = false;
                }
                if (bR) {
                    /* 下达自动deal的任务 */
                    this.room.memory.market['deal'].push({ rType: 'energy', num: 100000, mTyep: 'sell' });
                }
            }
        }
        // 其他类型资源的交易 【考虑到已经有了资源调度模块的存在，这里主要是卖】
        for (var t in this.room.memory.market) {
            // deal类型
            if (t == 'deal') {
                if (this.cooldown)
                    continue; // 冷却模式下进行不了其他deal了
                if (this.store.getUsedCapacity('energy') < 50000)
                    continue; // terminal空闲资源过少便不会继续
                for (var i of this.room.memory.market['deal']) {
                    if (i.mTyep == 'buy') {
                        continue; /*deal资源购买不在此处处理*/
                    }
                    if (i.rType != 'energy') {
                        this.room.memory.TerminalData[i.rType] = { num: i.unit ? i.unit : 5000, fill: true };
                    }
                    let _store_type_used = this.store.getUsedCapacity(i.rType);
                    if (_store_type_used <= 100 && i.num >= 100 && i.unit >= 100)
                        continue; // terminal空闲资源过少便不会继续
                    if (storage_.store.getUsedCapacity(i.rType) <= 0 && this.room.RoleMissionNum('manage', '物流运输') <= 0) {
                        if (!i.retain) {
                            if (i.rType != 'energy')
                                delete this.room.memory.TerminalData[i.rType];
                            var index = this.room.memory.market['deal'].indexOf(i);
                            this.room.memory.market['deal'].splice(index, 1);
                        }
                        continue;
                    }
                    /* 数量少了就删除 */
                    if (i.num <= 0) {
                        if (i.rType != 'energy')
                            delete this.room.memory.TerminalData[i.rType];
                        var index = this.room.memory.market['deal'].indexOf(i);
                        this.room.memory.market['deal'].splice(index, 1);
                        continue;
                    }
                    let Marketdeal = this.ResourceMarketdeal(i);
                    if (!Marketdeal)
                        continue;
                    let _market_x = 1;
                    if (i.rType == 'energy') {
                        _market_x = 0.5;
                    }
                    let _mex_market_number = Math.trunc(_store_type_used * _market_x);
                    let _deal_number = _mex_market_number;
                    if (Marketdeal.amount < _mex_market_number) {
                        _deal_number = Marketdeal.amount;
                    }
                    if (_deal_number > 0) {
                        let _market_state = Game.market.deal(Marketdeal.id, _deal_number, this.room.name);
                        if (_market_state == OK) {
                            i.num -= _deal_number;
                        }
                    }
                }
            }
            // order类型
            else if (t == 'order') {
                for (var l of this.room.memory.market['order']) {
                    if (!l.mTyep) {
                        continue; /*无方向定义订单终止*/
                    }
                    if (l.rType != 'energy' && l.mTyep == 'sell') {
                        this.room.memory.TerminalData[l.rType] = { num: l.unit ? l.unit : 5000, fill: true };
                    }
                    // 查询有无订单
                    if (!l.id) {
                        let myOrder = haveOrder(this.room.name, l.rType, l.mTyep);
                        if (!myOrder) {
                            console.log(Colorful$1(`[market] 房间${this.room.name}-rType:${l.rType}创建订单!`, 'yellow'));
                            // 没有就创建订单
                            var price = 0;
                            if (l.price) {
                                price = l.price;
                            }
                            else {
                                price = avePrice(l.rType, 1);
                                if (!price) {
                                    var index = this.room.memory.market['order'].indexOf(l);
                                    this.room.memory.market['order'].splice(index, 1);
                                }
                            }
                            // let price_ave = avePrice(l.rType, 1)
                            let result = Game.market.createOrder({
                                type: l.mTyep || 'buy',
                                resourceType: l.rType,
                                price: price,
                                totalAmount: l.unit ? l.unit : 5000,
                                roomName: this.room.name
                            });
                            // console.log(result)
                            switch (result) {
                                case OK:
                                    l.num -= l.unit ? l.unit : 5000;
                                    break;
                                default:
                                    continue;
                            }
                        }
                        for (let o in Game.market.orders) {
                            let order = Game.market.getOrderById(o);
                            if (order.roomName == this.room.name && order.resourceType == l.rType && order.type == l.mTyep)
                                l.id = o;
                        }
                        continue;
                    }
                    else {
                        let order = Game.market.getOrderById(l.id);
                        if (!order || (!(order === null || order === void 0 ? void 0 : order.remainingAmount) && l.num < 1)) // 取消订单信息
                         {
                            if (l.rType != 'energy')
                                delete this.room.memory.TerminalData[l.rType];
                            console.log(Colorful$1(`[market] 房间${this.room.name}订单ID:${l.id},rType:${l.rType}的删除订单!`, 'blue'));
                            var index = this.room.memory.market['order'].indexOf(l);
                            this.room.memory.market['order'].splice(index, 1);
                            Game.market.cancelOrder(l.id);
                            continue;
                        }
                        let _add_number = l.unit ? l.unit : 5000;
                        if (_add_number > l.num) {
                            _add_number = l.num;
                        }
                        if (order && (order.remainingAmount < _add_number) && l.num > 0) {
                            let add_order_number = _add_number;
                            if (order.remainingAmount) {
                                add_order_number = _add_number - order.remainingAmount;
                            }
                            /*操作补充订单*/
                            let result = Game.market.extendOrder(l.id, add_order_number);
                            if (result == OK) {
                                l.num -= add_order_number;
                                /*刷新采购的时间戳*/
                                // l.refreshtime = Game.time;
                                console.log(Colorful$1(`[market] 房间${this.room.name}-rType:${l.rType}补充订单 ${add_order_number}!`, 'yellow'));
                                // continue
                            }
                            else {
                                console.log(Colorful$1(`[market] 房间${this.room.name}订单ID:${l.id},rType:${l.rType}补充订单失败!`, 'blue'));
                            }
                        }
                        // 价格
                        if (order && l.changePrice) {
                            // 收到改变价格指令，也会改变订单价格
                            Game.market.changeOrderPrice(l.id, l.price);
                            console.log(`[market] 房间${this.room.name}改变订单ID:${l.id},type:${l.rType}的价格为${l.price}`);
                            l.changePrice = false;
                            /*刷新采购的时间戳*/
                            // l.refreshtime = Game.time;
                            continue;
                        }
                        /*进行价格调整器*/
                        if (l.autotrade) {
                            if (!l.refreshtime)
                                l.refreshtime = Game.time; /*初始化一个时间戳*/
                            // if (!l.autorefreshtime) l.autorefreshtime = Game.time;/*初始化一个时间戳*/
                            /*检查订单的方向信息,然后检查是否存在限价*/
                            /*订单检查是否满足调价要求*/
                            let Automarketdata = AutomarketBuydata[order.resourceType];
                            if (!Automarketdata) {
                                console.log(Colorful$1(`[market][Auto]房间${this.room.name}订单ID:${l.id},type:${l.rType}没有调价配置`, 'red'));
                                continue;
                            }
                            if (!Automarketdata.max)
                                continue;
                            let autotime = 200;
                            if (Automarketdata.time)
                                autotime = Automarketdata.time; /*硬编码默认间隔*/
                            if (l.autotime)
                                autotime = l.autotime; /*订单包含的间隔-最高优先级*/
                            /*检查是否满足了调价的要求时间*/
                            if (Game.time - l.refreshtime < autotime)
                                continue;
                            switch (order.type) {
                                case ORDER_SELL:
                                    break;
                                case ORDER_BUY:
                                    /*检查是否已经达到最近价格*/
                                    let pricemax = Automarketdata.max;
                                    if (l.automax)
                                        pricemax = l.automax;
                                    // if (l.price >= pricemax) {
                                    //     l.refreshtime = Game.time;
                                    //     break;
                                    // }
                                    let Atype = 0;
                                    if (Automarketdata.Atype)
                                        Atype = Automarketdata.Atype;
                                    if (l.autoatype)
                                        Atype = l.autoatype;
                                    switch (Atype) {
                                        case 1: /*进行最高价格竞价*/
                                            let highest = notmehighestPrice(order.resourceType, 'buy', l.autofilteraisle);
                                            /*当前处于最高价则不进行处理*/
                                            // if (highest <= l.price) l.refreshtime = Game.time;
                                            let newprice = Number(highest) + 0.001;
                                            newprice = newprice > pricemax ? pricemax : newprice;
                                            l.refreshtime = Game.time;
                                            if (newprice == l.price)
                                                continue;
                                            l.price = newprice;
                                            Game.market.changeOrderPrice(l.id, newprice);
                                            console.log(Colorful$1(`[market][Auto]房间${this.room.name}改变订单ID:${l.id},type:${l.rType}的价格为${newprice}`, '#0099FF'));
                                            break;
                                        case 2:
                                            if (!Automarketdata.Aincrease)
                                                break;
                                            break;
                                    }
                                    break;
                            }
                        }
                    }
                }
            }
        }
    }
    /**
     * 资源传送
     */
    ResourceSend(task) {
        if (this.cooldown && this.cooldown > 0)
            return;
        if (!task.Data || !task.Data.disRoom) // 任务数据有问题
         {
            this.room.DeleteMission(task.id);
            return;
        }
        if (!task.state)
            task.state = 1; // 1状态下，搜集资源
        if (task.state == 1) {
            if (this.room.controller.level < 8) {
                if (Game.time % 5)
                    return; /* 每10tick监测一次 */
            }
            else {
                if (Game.time % 10)
                    return; /* 每10tick监测一次 */
            }
            if (task.Data.num <= 0 || task.Data.num == undefined)
                this.room.DeleteMission(task.id);
            if (this.room.RoleMissionNum('manage', '物流运输') > 0)
                return; // manage爬虫有任务时就不管
            // 路费
            var wastage = Game.market.calcTransactionCost(task.Data.num, this.room.name, task.Data.disRoom);
            /* 如果非能量资源且路费不够，发布资源搬运任务，优先寻找storage */
            var storage_ = this.room.storage;
            // terminal的剩余资源
            var remain = this.store.getFreeCapacity();
            /* 路费判断 */
            if (wastage > this.store.getUsedCapacity('energy')) {
                /* 只有在能量富裕的情况下才会允许进入下一阶段 */
                if (storage_ && (storage_.store.getUsedCapacity('energy') + this.store.getUsedCapacity('energy') - 5000) > wastage && remain > (wastage - this.store.getUsedCapacity('energy'))) {
                    /* 下布搬运任务 */
                    var thisTask = this.room.public_Carry({ 'manage': { num: 1, bind: [] } }, 40, this.room.name, storage_.pos.x, storage_.pos.y, this.room.name, this.pos.x, this.pos.y, 'energy', wastage - this.store.getUsedCapacity('energy'));
                    this.room.AddMission(thisTask);
                    return;
                }
                /* 条件不满足就自动删除任务 */
                this.room.DeleteMission(task.id);
                return;
            }
            console.log('资源传送任务监控中: ###########################\n 房间:', this.room.name, '--->', task.Data.disRoom, ' 运送资源：', task.Data.rType);
            console.log('路费:', Colorful$1(`${wastage}`, 'yellow'), 'energy  ', '终端拥有能量:', Colorful$1(`${this.store.getUsedCapacity('energy')}`, 'yellow'), 'energy');
            /* 资源判断 */
            var cargoNum = task.Data.rType == 'energy' ? this.store.getUsedCapacity(task.Data.rType) - wastage : this.store.getUsedCapacity(task.Data.rType);
            console.log('终端拥有资源量:', Colorful$1(`${cargoNum}`, 'blue'), ' 仓库拥有资源量:', storage_.store.getUsedCapacity(task.Data.rType), ' 任务所需资源量:', task.Data.num);
            if (task.Data.num > cargoNum) {
                if (storage_.store.getUsedCapacity(task.Data.rType) <= 0) {
                    /* 条件不满足就自动删除任务 */
                    this.room.DeleteMission(task.id);
                    return;
                }
                if (storage_ && (storage_.store.getUsedCapacity(task.Data.rType) + this.store.getUsedCapacity(task.Data.rType)) >= (task.Data.num - 1600) && remain > task.Data.num - cargoNum) {
                    /* 下布搬运任务 */
                    var thisTask = this.room.public_Carry({ 'manage': { num: 1, bind: [] } }, 40, this.room.name, storage_.pos.x, storage_.pos.y, this.room.name, this.pos.x, this.pos.y, task.Data.rType, task.Data.num - cargoNum);
                    this.room.AddMission(thisTask);
                    return;
                }
                /* 条件不满足就自动删除任务 */
                this.room.DeleteMission(task.id);
                return;
            }
            /* 都满足条件了就进入状态2 */
            task.state = 2;
        }
        else if (task.state == 2) {
            let result = this.send(task.Data.rType, task.Data.num, task.Data.disRoom);
            if (result == -6) /* 能量不够就重新返回状态1 */ {
                console.log(Colorful$1(`房间${this.room.name}发送资源${task.Data.rType}失败!`, 'read', true));
                task.state = 1;
                return;
            }
            else if (result == OK) {
                /* 如果传送成功，就删除任务 */
                this.room.DeleteMission(task.id);
                return;
            }
        }
    }
    /**
     * 资源购买 (deal)
     */
    ResourceDeal(task) {
        if ((Game.time - global.Gtime[this.room.name]) % 10)
            return;
        if (this.cooldown || this.store.getUsedCapacity('energy') < 45000)
            return;
        if (!task.Data) {
            this.room.DeleteMission(task.id);
            return;
        }
        let money = Game.market.credits;
        if (money <= 0 || task.Data.num > 50000) {
            this.room.DeleteMission(task.id);
            return;
        }
        let rType = task.Data.rType;
        let num = task.Data.num;
        var HistoryList = Game.market.getHistory(rType);
        let HistoryLength = HistoryList.length;
        if (HistoryList.length < 3 && Game.cpu.generatePixel) {
            console.log(`资源${rType}的订单太少，无法购买!`);
            this.room.DeleteMission(task.id);
            return;
        } // 以防特殊情况
        var allNum = 0;
        for (var iii = HistoryLength - 3; iii < HistoryLength; iii++) {
            if (HistoryList[iii]) {
                allNum += HistoryList[iii].avgPrice;
            }
        }
        var avePrice = allNum / 3; // 平均价格 [近3天]
        // 获取该资源的平均价格
        var maxPrice = avePrice + (task.Data.range ? task.Data.range : 50); // 范围
        maxPrice = maxPrice < 1 ? 1 : maxPrice;
        if (task.Data.maxPrice) {
            maxPrice = maxPrice > task.Data.maxPrice ? task.Data.maxPrice : maxPrice;
        }
        // console.log(rType, '最大价格', maxPrice, task.Data.maxPrice)
        /* 在市场上寻找 */
        var orders = Game.market.getAllOrders(order => order.resourceType == rType &&
            order.type == ORDER_SELL && order.price <= maxPrice);
        if (orders.length <= 0)
            return;
        /* 寻找价格最低的 */
        var newOrderList = orders.sort(compare$1('price'));
        for (var ii of newOrderList) {
            if (ii.price > maxPrice)
                return;
            if (ii.amount >= num) {
                if (Game.market.deal(ii.id, num, this.room.name) == OK) {
                    this.room.DeleteMission(task.id);
                    return;
                }
                else
                    return;
            }
            else {
                if (Game.market.deal(ii.id, ii.amount, this.room.name) == OK)
                    task.Data.num -= ii.amount;
                return;
            }
        }
    }
}

class factoryExtension extends StructureFactory {
    ManageMission() {
        if (this.room.memory.switch.StopFactory)
            return;
        this.ResourceMemory();
        this.ResourceBalance();
        this.factoryUnzip();
        this.factoryProduce();
    }
    // 资源平衡
    ResourceBalance() {
        if ((Game.time - global.Gtime[this.room.name]) % 7)
            return;
        let terminal_ = this.room.terminal;
        let storage_ = this.room.storage;
        if (!terminal_ || !storage_)
            return;
        if (!this.room.memory.productData || !this.room.memory.productData.balanceData)
            return;
        // 找到manage爬虫
        var anytype = Object.keys(this.store);
        for (let i in this.room.memory.productData.balanceData)
            if (i)
                anytype = _.uniq([...anytype, i]); //把所有资源遍历一遍
        for (let i of anytype) {
            if (this.room.RoleMissionNum('manage', '物流运输') > 0)
                return;
            let num = this.store.getUsedCapacity(i); // 数量
            // 搬走资源
            if (!this.room.memory.productData.balanceData[i] || !this.room.memory.productData.balanceData[i].num) {
                if (storage_.store.getFreeCapacity() < 10000)
                    continue;
                let thisTask = this.room.public_Carry({ 'manage': { num: 1, bind: [] } }, 10, this.room.name, this.pos.x, this.pos.y, this.room.name, storage_.pos.x, storage_.pos.y, i, num);
                this.room.AddMission(thisTask);
                continue;
            }
            else {
                if (num > this.room.memory.productData.balanceData[i].num) {
                    if (storage_.store.getFreeCapacity() < 10000)
                        continue;
                    let thisTask = this.room.public_Carry({ 'manage': { num: 1, bind: [] } }, 10, this.room.name, this.pos.x, this.pos.y, this.room.name, storage_.pos.x, storage_.pos.y, i, num - this.room.memory.productData.balanceData[i]);
                    this.room.AddMission(thisTask);
                }
                // 少了就搬进
                else if (num < this.room.memory.productData.balanceData[i].num && this.room.memory.productData.balanceData[i].fill) {
                    if (this.store.getFreeCapacity() < 2000)
                        continue;
                    if (i == 'energy') {
                        // 能量特殊
                        if (this.room.memory.productData.balanceData[i].num - num > 50 && this.room.memory.productData.balanceData[i].num - num < 1000)
                            continue; // 相差太少就不搬了
                        if (storage_.store.getUsedCapacity('energy') <= 20000)
                            continue;
                        else {
                            let thisTask = this.room.public_Carry({ 'manage': { num: 1, bind: [] } }, 10, this.room.name, storage_.pos.x, storage_.pos.y, this.room.name, this.pos.x, this.pos.y, i, Math.abs(this.room.memory.productData.balanceData[i].num - num));
                            this.room.AddMission(thisTask);
                            continue;
                        }
                    }
                    else if (isInArray(['U', 'L', 'K', 'H', 'O', 'Z', 'X'], i)) {
                        if (storage_.store.getUsedCapacity(i) < this.room.memory.productData.balanceData[i].num - num) ;
                        else {
                            let thisTask = this.room.public_Carry({ 'manage': { num: 1, bind: [] } }, 10, this.room.name, storage_.pos.x, storage_.pos.y, this.room.name, this.pos.x, this.pos.y, i, Math.abs(this.room.memory.productData.balanceData[i].num - num));
                            this.room.AddMission(thisTask);
                            continue;
                        }
                        // 搬运
                        if (!storage_.store[i])
                            continue;
                    }
                    else {
                        if (storage_.store.getUsedCapacity(i) <= this.room.memory.productData.balanceData[i].num - num) {
                            if (storage_.store.getUsedCapacity(i) <= 0)
                                continue;
                            // 搬运
                            let thisTask = this.room.public_Carry({ 'manage': { num: 1, bind: [] } }, 10, this.room.name, storage_.pos.x, storage_.pos.y, this.room.name, this.pos.x, this.pos.y, i, storage_.store.getUsedCapacity(i));
                            this.room.AddMission(thisTask);
                            continue;
                        }
                        else {
                            // 搬运
                            let thisTask = this.room.public_Carry({ 'manage': { num: 1, bind: [] } }, 10, this.room.name, storage_.pos.x, storage_.pos.y, this.room.name, this.pos.x, this.pos.y, i, Math.abs(this.room.memory.productData.balanceData[i].num - num));
                            this.room.AddMission(thisTask);
                            continue;
                        }
                    }
                }
            }
        }
    }
    // 资源平衡记忆更新
    ResourceMemory() {
        /* factory自身资源管理 */
        var factoryData = this.room.memory.productData.balanceData;
        /* factory自身等级管理 */
        if (this.level) {
            if (this.level != this.room.memory.productData.level)
                this.room.memory.productData.level = this.level;
        }
        else
            this.room.memory.productData.level = 0;
        for (var i in factoryData) {
            /* 数量小于0就删除数据，节省memory */
            if (factoryData[i].num <= 0) {
                console.log(`[factory] 房间${this.room.name}删除balanceData数据${i}`);
                delete factoryData[i];
            }
        }
    }
    // 工厂生产
    factoryProduce() {
        if ((Game.time - global.Gtime[this.room.name]) % 5)
            return;
        if (this.cooldown)
            return;
        if (!this.room.memory.productData.state)
            this.room.memory.productData.state = 'sleep';
        if (!_.isEmpty(this.room.memory.productData.unzip))
            return; // 优先资源解压
        let state = this.room.memory.productData.state;
        let terminal_ = this.room.terminal;
        let storage_ = this.room.storage;
        if (!terminal_ || !storage_)
            return;
        if (state == 'sleep') {
            this.room.memory.productData.balanceData = {};
            if ((Game.time - global.Gtime[this.room.name]) % 85)
                return;
            delete this.room.memory.productData.producing;
            let disCom = this.room.memory.productData.flowCom;
            if (disCom) // 检测是否可以直接生产商品 是否可以资源调度
             {
                let disComNumber = this.store.getUsedCapacity(disCom) + storage_.store.getUsedCapacity(disCom);
                if (disComNumber < 500) {
                    // 初始化numList数据
                    let numList = {};
                    let flow = true;
                    // 判断合成资源是否足够
                    LoopA: for (var i in COMMODITIES[disCom].components) {
                        numList[i] = storage_.store.getUsedCapacity(i);
                        if (COMMODITIES[disCom].level >= 4) {
                            // 如果仓库内的底物少于规定量
                            if (numList[i] < COMMODITIES[disCom].components[i] * 5) {
                                flow = false;
                                // 判断一下能否调度 不能调度直接跳转到baseList相关合成判断
                                let identify = ResourceCanDispatch(this.room, i, COMMODITIES[disCom].components[i] * 5);
                                if (identify == "can") {
                                    console.log(`[dispatch]<factory> 房间${this.room.name}将进行资源为${i}的资源调度!`);
                                    let dispatchTask = {
                                        sourceRoom: this.room.name,
                                        rType: i,
                                        num: COMMODITIES[disCom].components[i] * 5,
                                        delayTick: 200,
                                        conditionTick: 35,
                                        buy: false,
                                    };
                                    Memory.ResourceDispatchData.push(dispatchTask);
                                }
                                else if (identify == 'running')
                                    return;
                                else
                                    break LoopA;
                            }
                            else {
                                continue;
                            }
                        }
                        else {
                            if (numList[i] < COMMODITIES[disCom].components[i] * 10) {
                                flow = false;
                                let identify = ResourceCanDispatch(this.room, i, COMMODITIES[disCom].components[i] * 10);
                                if (identify == "can") {
                                    console.log(`[dispatch]<factory> 房间${this.room.name}将进行资源为${i}的资源调度!`);
                                    let dispatchTask = {
                                        sourceRoom: this.room.name,
                                        rType: i,
                                        num: COMMODITIES[disCom].components[i] * 10,
                                        delayTick: 200,
                                        conditionTick: 35,
                                        buy: false,
                                    };
                                    Memory.ResourceDispatchData.push(dispatchTask);
                                }
                                else if (identify == 'running')
                                    return;
                                else
                                    break LoopA;
                            }
                            else {
                                continue;
                            }
                        }
                    }
                    if (flow) {
                        console.log(`[factory] 房间${this.room.name}转入flow生产模式,目标商品为${disCom}`);
                        this.room.memory.productData.state = 'flow';
                        this.room.memory.productData.producing = { com: disCom };
                        return;
                    }
                }
            }
            // 如果没有流水线商品或者商品不够生产流水线商品 就生产基本商品
            if (Object.keys(this.room.memory.productData.baseList).length <= 0)
                return;
            let zip = []; // 压缩商品 bar
            let low = []; // 低级商品 Wire Cell Alloy Condensate 
            let high = []; // 高等商品 Composite Crystal Liquid 
            let zipList = ['utrium_bar', 'lemergium_bar', 'keanium_bar', 'zynthium_bar', 'ghodium_melt', 'oxidant', 'reductant', 'purifier', 'battery'];
            let highlist = [
                'composite', 'crystal', 'liquid',
                'switch', 'transistor', 'microchip', 'circuit', 'device',
                'phlegm', 'tissue', 'muscle', 'organoid', 'organism',
                'tube', 'fixtures', 'frame', 'hydraulics', 'machine',
                'concentrate', 'extract', 'spirit', 'emanation', 'essence'
            ];
            for (var baseProduction in this.room.memory.productData.baseList) {
                if (isInArray(zipList, baseProduction))
                    zip.push(baseProduction);
                else if (isInArray(['wire', 'cell', 'alloy', 'condensate'], baseProduction))
                    low.push(baseProduction);
                else if (isInArray(highlist, baseProduction))
                    high.push(baseProduction);
            }
            // 检测基础商品是否满足
            for (let b of zip) {
                if (storage_.store.getUsedCapacity(b) < this.room.memory.productData.baseList[b].num - 3000) {
                    console.log(`[factory] 房间${this.room.name}转入base生产模式,目标商品为${b}`);
                    this.room.memory.productData.state = 'base';
                    this.room.memory.productData.producing = { com: b, num: this.room.memory.productData.baseList[b].num };
                    return;
                }
            }
            // 检测低级商品是否满足
            LoopJ: for (let l of low) {
                if (storage_.store.getUsedCapacity(l) < this.room.memory.productData.baseList[l].num - 300) {
                    // if (this.owner.username == 'ExtraDim') {
                    //     /* 测试用 */
                    let minList = ['energy', 'L', 'O', 'H', 'U', 'K', 'Z', 'X', 'G'];
                    //     // 判断一下是否有足够子资源
                    for (var i in COMMODITIES[l].components) {
                        if (!isInArray(minList, i) &&
                            storage_.store.getUsedCapacity(i) < COMMODITIES[l].components[i] &&
                            ResourceCanDispatch(this.room, i, COMMODITIES[l].components[i] * 100) == 'no') {
                            continue LoopJ;
                        }
                    }
                    // }
                    console.log(`[factory] 房间${this.room.name}转入base生产模式,目标商品为${l}`);
                    this.room.memory.productData.state = 'base';
                    this.room.memory.productData.producing = { com: l, num: this.room.memory.productData.baseList[l].num };
                    return;
                }
            }
            // 检测高级商品是否满足
            LoopJ: for (let h of high) {
                let _start_number = 300;
                let _comm = COMMODITIES[h];
                if (_comm.level && _comm.level > 3) {
                    _start_number = 10;
                }
                if (storage_.store.getUsedCapacity(h) < this.room.memory.productData.baseList[h].num - _start_number) {
                    if (!COMMODITIES[h])
                        continue;
                    if (COMMODITIES[h].level > 0) {
                        let frequency_number = Math.ceil(1000 / COMMODITIES[h].cooldown);
                        for (var i in COMMODITIES[h].components) {
                            let minList = ['energy', 'L', 'O', 'H', 'U', 'K', 'Z', 'X', 'G'];
                            let storage_number = storage_.store.getUsedCapacity(i);
                            let _need_number = COMMODITIES[h].components[i] * frequency_number;
                            if (!isInArray(minList, i)) {
                                if (storage_number > _need_number) { /*仓库有足够资源的情况下监测下一个资源*/
                                    continue;
                                }
                                if (ResourceCanDispatch(this.room, i, _need_number) == 'no') {
                                    // console.log(this.room.name, h, i, '监测调度错误', _need_number)
                                    continue LoopJ;
                                }
                            }
                        }
                    }
                    console.log(`[factory] 房间${this.room.name}转入base生产模式,目标商品为${h}`);
                    this.room.memory.productData.state = 'base';
                    this.room.memory.productData.producing = { com: h, num: this.room.memory.productData.baseList[h].num };
                    return;
                }
            }
        }
        else if (state == 'base') // 生产基础商品
         {
            let disCom = this.room.memory.productData.producing.com;
            let minList = ['energy', 'L', 'O', 'H', 'U', 'K', 'Z', 'X', 'G'];
            // 挂载资源平衡数据
            // 判定所需数量是否足够
            for (var i in COMMODITIES[disCom].components) {
                if (isInArray(minList, i)) {
                    this.room.memory.productData.balanceData[i] = { num: 5000, fill: true };
                    if (storage_.store.getUsedCapacity(i) < 10000) {
                        // 资源调度
                        if (identifyDispatch(this.room, i, 10000, 1, 'deal')) {
                            console.log(`[dispatch] 房间${this.room.name}将进行资源为${i}的资源调度!`);
                            let dispatchTask = {
                                sourceRoom: this.room.name,
                                rType: i,
                                num: 10000,
                                delayTick: 200,
                                conditionTick: 35,
                                buy: true,
                                mtype: 'deal'
                            };
                            Memory.ResourceDispatchData.push(dispatchTask);
                        }
                        break;
                    }
                }
                else {
                    // 其他资源的话，看看能不能调度
                    this.room.memory.productData.balanceData[i] = { num: COMMODITIES[disCom].components[i] * 10, fill: true };
                    if (this.room.RoleMissionNum('manage', '物流运输') <= 0) {
                        let _number_t = 100;
                        if (COMMODITIES[disCom].level > 0) {
                            _number_t = Math.ceil(1000 / COMMODITIES[disCom].cooldown);
                        }
                        if (this.store.getUsedCapacity(i) + storage_.store.getUsedCapacity(i) < COMMODITIES[disCom].components[i]) {
                            let identify = ResourceCanDispatch(this.room, i, COMMODITIES[disCom].components[i] * _number_t);
                            if (identify == 'can') {
                                console.log(`[dispatch]<factory> 房间${this.room.name}将进行资源为${i}的资源调度!`);
                                let dispatchTask = {
                                    sourceRoom: this.room.name,
                                    rType: i,
                                    num: COMMODITIES[disCom].components[i] * _number_t,
                                    delayTick: 200,
                                    conditionTick: 35,
                                    buy: false,
                                };
                                Memory.ResourceDispatchData.push(dispatchTask);
                            }
                            else if (identify == 'running')
                                break;
                            else {
                                console.log(`[资源调度]<factory> 商品${i}无法调度,工厂状态切换为sleep!`);
                                this.room.memory.productData.state = 'sleep';
                                return;
                            }
                        }
                    }
                }
            }
            // 合成
            let result = this.produce(disCom);
            if (result == 0) {
                this.room.memory.productData.producing.num -= COMMODITIES[disCom].amount;
            }
            else if (result == ERR_BUSY) {
                if (Game.powerCreeps[`${this.room.name}/queen/${Game.shard.name}`])
                    this.room.enhance_factory();
                else
                    console.log(`[factory] 房间${this.room.name}出现工厂等级错误,不能生产${disCom}`);
            }
            if (this.room.memory.productData.producing.num <= 0)
                this.room.memory.productData.state = 'sleep';
        }
        else if (state == 'flow') // 生产流水线商品
         {
            let disCom = this.room.memory.productData.producing.com;
            let disComNumber = this.store.getUsedCapacity(disCom) + storage_.store.getUsedCapacity(disCom);
            if (disComNumber > 1000) {
                this.room.memory.productData.state = 'sleep';
                return;
            }
            // 调度相关资源
            for (var i in COMMODITIES[disCom].components) {
                if (COMMODITIES[disCom].level < 4) {
                    if (isInArray(['energy'], i))
                        this.room.memory.productData.balanceData[i] = { num: 5000, fill: true };
                    else
                        this.room.memory.productData.balanceData[i] = { num: COMMODITIES[disCom].components[i] * 4, fill: true };
                    if (this.room.RoleMissionNum('manage', '物流运输') > 0)
                        break;
                    if (this.store.getUsedCapacity(i) + storage_.store.getUsedCapacity(i) < COMMODITIES[disCom].components[i]) {
                        console.log(`[factory] 房间${this.room.name}转入sleep生产模式`);
                        this.room.memory.productData.state = 'sleep';
                        return;
                    }
                }
                else {
                    if (isInArray(['energy'], i))
                        this.room.memory.productData.balanceData[i] = { num: 5000, fill: true };
                    else
                        this.room.memory.productData.balanceData[i] = { num: COMMODITIES[disCom].components[i], fill: true };
                    if (this.room.RoleMissionNum('manage', '物流运输') > 0)
                        break;
                    if (this.store.getUsedCapacity(i) + storage_.store.getUsedCapacity(i) < COMMODITIES[disCom].components[i]) {
                        console.log(`[factory] 房间${this.room.name}转入sleep生产模式`);
                        this.room.memory.productData.state = 'sleep';
                        return;
                    }
                }
            }
            // 合成
            let result = this.produce(disCom);
            if (result == 0) {
                this.room.memory.productData.producing.num -= COMMODITIES[disCom].amount;
            }
            else if (result == ERR_BUSY) {
                if (!this.room.memory.productData.flowCom) {
                    console.log(`[factory] 房间${this.room.name}转入sleep生产模式`);
                    this.room.memory.productData.state = 'sleep';
                }
                if (Game.powerCreeps[`${this.room.name}/queen/${Game.shard.name}`])
                    this.room.enhance_factory();
                else
                    console.log(`[factory] 房间${this.room.name}出现工厂等级错误,不能生产${disCom}`);
            }
        }
    }
    // 添加合成
    add(res, num) {
        if (!isInArray(Object.keys(COMMODITIES), res) || num <= 0 || !num)
            return `[factory] 错误参数`;
        this.room.memory.productData.baseList[res] = { num: num };
        let result = `[factory] 房间${this.room.name}成功添加基础资源${res};目前基础资源列表如下:\n`;
        for (var i in this.room.memory.productData.baseList)
            result += `${i}:${this.room.memory.productData.baseList[i].num}\n`;
        return result;
    }
    // 删除合成
    remove(res) {
        delete this.room.memory.productData.baseList[res];
        let result = `[factory] 房间${this.room.name}成功删除基础资源${res};目前基础资源列表如下:\n`;
        for (var i in this.room.memory.productData.baseList)
            result += `${i}:${this.room.memory.productData.baseList[i].num}\n`;
        return result;
    }
    // 设置生产线资源
    set(res) {
        this.room.memory.productData.flowCom = res;
        return `[factory] 房间${this.room.name}的流水线资源设置为${res}!`;
    }
    // 删除生产线资源
    del(res) {
        delete this.room.memory.productData.flowCom;
        return `[factory] 房间${this.room.name}的流水线资源已删除!`;
    }
    /**
     * 更新工厂等级
     */
    enhance_factory() {
        if (!Game.powerCreeps[`${this.room.name}/queen/${Game.shard.name}`])
            return `${this.room.name}此房间无pc请先孵化pc`;
        this.room.enhance_factory();
        return `发布pc确定工厂等级任务成功`;
    }
    factoryUnzip() {
        if (!this.room.memory.productData.unzip)
            this.room.memory.productData.unzip = {};
        if (this.cooldown)
            return;
        if ((Game.time - global.Gtime[this.room.name]) % 10)
            return;
        let unzipData = this.room.memory.productData.unzip;
        if (_.isEmpty(unzipData))
            return;
        let unzipResource = Object.keys(unzipData)[0];
        if (unzipData['battery'] && unzipResource != 'battery')
            unzipResource = 'battery'; // 优先解压电池
        if (!isInArray(Object.keys(unzipMap), unzipResource)) {
            delete unzipData[unzipResource];
            console.log(`房间${this.room.name}存在错误解压资源类型,为:${unzipResource}`);
            return;
        }
        let storage_ = this.room.storage;
        if (!storage_)
            return;
        if (storage_.store.getUsedCapacity(unzipResource) <= 0) {
            this.room.memory.productData.balanceData = {};
            delete unzipData[unzipResource];
            return;
        }
        // 判断是否有足够解压资源
        if (unzipResource == 'battery') {
            this.room.memory.productData.balanceData['battery'] = { num: 1000, fill: true };
            if (this.store.getUsedCapacity(unzipResource) >= 50) {
                let result = this.produce(unzipMap[unzipResource]);
                if (result == OK) {
                    unzipData['battery'].num -= 50;
                }
                if (result == -7 || result == -10 || unzipData['battery'].num <= 0) {
                    this.room.memory.productData.balanceData = {};
                    delete unzipData[unzipResource];
                    return;
                }
            }
        }
        else {
            if (storage_.store.getUsedCapacity('energy') < 25000)
                return; // 能量太少拒绝解压
            this.room.memory.productData.balanceData[unzipResource] = { num: 1000, fill: true };
            this.room.memory.productData.balanceData['energy'] = { num: 5000, fill: true };
            if (this.store.getUsedCapacity(unzipResource) >= 100) {
                let result = this.produce(unzipMap[unzipResource]);
                if (result == OK) {
                    unzipData[unzipResource].num -= 100;
                }
                if (result == -7 || result == -10 || unzipData[unzipResource].num <= 0) {
                    this.room.memory.productData.balanceData = {};
                    delete unzipData[unzipResource];
                    return;
                }
            }
        }
    }
}

// 定义好挂载顺序
var mountStructure = () => {
    assignPrototype(StructureLink, linkExtension);
    assignPrototype(StructureTerminal, terminalExtension);
    assignPrototype(StructureFactory, factoryExtension);
};

// import { RequestShard } from "@/shard/base"
/* 本地寻路移动 */
class PowerCreepMoveExtension extends PowerCreep {
    // 位置标准化
    standardizePos(pos) {
        return `${pos.roomName}/${pos.x}/${pos.y}/${Game.shard.name}`;
    }
    // 寻找不允许对穿的爬虫的位置
    getStandedPos() {
        var standedCreep = this.room.find(FIND_MY_CREEPS, {
            filter: (creep) => {
                return (creep.memory.standed == true || (creep.memory.crossLevel && this.memory.crossLevel && creep.memory.crossLevel > this.memory.crossLevel));
            }
        });
        if (standedCreep.length > 0) {
            var posList = [];
            for (var i of standedCreep) {
                posList.push(i.pos);
            }
            return posList;
        }
        return [];
    }
    // 通用寻路
    findPath(target, range) {
        /* 全局路线存储 */
        if (!global.routeCache)
            global.routeCache = {};
        if (!this.memory.moveData)
            this.memory.moveData = {};
        this.memory.moveData.index = 0;
        /* 查找全局中是否已经有预定路线，如果有了就直接返回路线 */
        const routeKey = `${this.standardizePos(this.pos)}|${this.standardizePos(target)}|pc`;
        var route = global.routeCache[routeKey];
        if (route && this.room.name != target.roomName) {
            return route;
        }
        /* 路线查找 */
        const result = PathFinder.search(this.pos, { pos: target, range: range }, {
            plainCost: 1,
            swampCost: 1,
            maxRooms: 2,
            maxOps: 1000,
            roomCallback: roomName => {
                // 在全局绕过房间列表的房间 false
                if (Memory.bypassRooms && Memory.bypassRooms.includes(roomName))
                    return false;
                // 在爬虫记忆绕过房间列表的房间 false
                if (this.memory.bypassRooms && this.memory.bypassRooms.includes(roomName))
                    return false;
                const room = Game.rooms[roomName];
                // 没有视野的房间只观察地形
                if (!room)
                    return;
                // 有视野的房间
                let costs = new PathFinder.CostMatrix;
                // 将道路的cost设置为1，无法行走的建筑设置为255
                room.find(FIND_STRUCTURES).forEach(struct => {
                    if (struct.structureType === STRUCTURE_ROAD) {
                        costs.set(struct.pos.x, struct.pos.y, 1);
                    }
                    else if (struct.structureType !== STRUCTURE_CONTAINER &&
                        (struct.structureType !== STRUCTURE_RAMPART || !struct.my))
                        costs.set(struct.pos.x, struct.pos.y, 0xff);
                });
                room.find(FIND_MY_CONSTRUCTION_SITES).forEach(cons => {
                    if (cons.structureType != 'road' && cons.structureType != 'rampart' && cons.structureType != 'container')
                        costs.set(cons.pos.x, cons.pos.y, 255);
                });
                /* 防止撞到其他虫子造成堵虫 */
                room.find(FIND_HOSTILE_CREEPS).forEach(creep => {
                    costs.set(creep.pos.x, creep.pos.y, 255);
                });
                room.find(FIND_MY_CREEPS).forEach(creep => {
                    if ((creep.memory.crossLevel && creep.memory.crossLevel > this.memory.crossLevel) || creep.memory.standed)
                        costs.set(creep.pos.x, creep.pos.y, 255);
                    else
                        costs.set(creep.pos.x, creep.pos.y, 3);
                });
                return costs;
            }
        });
        // 寻路异常返回null
        if (result.path.length <= 0)
            return null;
        // 寻路结果压缩
        route = this.serializeFarPath(result.path);
        if (!result.incomplete)
            global.routeCache[routeKey] = route;
        return route;
    }
    // 使用寻路结果移动
    goByPath() {
        if (!this.memory.moveData)
            return ERR_NO_PATH;
        const index = this.memory.moveData.index;
        // 移动索引超过数组上限代表到达目的地
        if (index >= this.memory.moveData.path.length) {
            delete this.memory.moveData.path;
            return OK;
        }
        // 获取方向，进行移动
        const direction = Number(this.memory.moveData.path[index]);
        const goResult = this.go(direction);
        // 移动成功，更新下次移动索引
        if (goResult == OK)
            this.memory.moveData.index++;
        return goResult;
    }
    // 通用移动 (配合findPath 和 goByPath)
    goTo(target, range = 1) {
        //  var a = Game.cpu.getUsed()
        if (this.memory.moveData == undefined)
            this.memory.moveData = {};
        // 确认目标没有变化，如果变化了就重新规划路线
        const targetPosTag = this.standardizePos(target);
        if (targetPosTag !== this.memory.moveData.targetPos) {
            this.memory.moveData.targetPos = targetPosTag;
            this.memory.moveData.path = this.findPath(target, range);
        }
        // 确认缓存有没有被清除
        if (!this.memory.moveData.path) {
            this.memory.moveData.path = this.findPath(target, range);
        }
        // 还为空的话就是没有找到路径
        if (!this.memory.moveData.path) {
            delete this.memory.moveData.path;
            return OK;
        }
        // 使用缓存进行移动
        const goResult = this.goByPath();
        // 如果发生撞停或者参数异常，说明缓存可能存在问题，移除缓存
        if (goResult === ERR_INVALID_TARGET) {
            delete this.memory.moveData;
        }
        else if (goResult != OK && goResult != ERR_TIRED) {
            this.say(`异常码:${goResult}`);
        }
        // var b = Game.cpu.getUsed()
        // this.say(`${b-a}`)
        return goResult;
    }
    // 请求对穿 按照对穿等级划分 等级高的可以任意对穿等级低的，等级低的无法请求等级高的对穿，等级相等则不影响
    requestCross(direction) {
        if (!this.memory.crossLevel)
            this.memory.crossLevel = 10; // 10为默认对穿等级
        // 获取目标方向一格的位置
        const fontPos = this.pos.directionToPos(direction);
        // 在出口、边界
        if (!fontPos)
            return ERR_NOT_FOUND;
        const fontCreep = (fontPos.lookFor(LOOK_CREEPS)[0] || fontPos.lookFor(LOOK_POWER_CREEPS)[0]);
        if (!fontCreep)
            return ERR_NOT_FOUND;
        if (fontCreep.owner.username != this.owner.username)
            return;
        this.say("👉");
        if (fontCreep.manageCross(getOppositeDirection(direction), this.memory.crossLevel))
            this.move(direction);
        return OK;
    }
    // 处理对穿
    manageCross(direction, crossLevel) {
        if (!this.memory.crossLevel)
            this.memory.crossLevel = 10;
        if (!this.memory)
            return true;
        if (this.memory.standed || this.memory.crossLevel > crossLevel) {
            if (!(Game.time % 5))
                this.say('👊');
            return false;
        }
        // 同意对穿
        this.say('👌');
        this.move(direction);
        return true;
    }
    // 单位移动 (goByPath中的移动基本函数)
    go(direction) {
        const moveResult = this.move(direction);
        if (moveResult != OK)
            return moveResult;
        // 如果ok的话，有可能撞上东西了或者一切正常
        const currentPos = `${this.pos.x}/${this.pos.y}`;
        if (this.memory.prePos && currentPos == this.memory.prePos) {
            // 这个时候确定在原点驻留了
            const crossResult = this.memory.disableCross ? ERR_BUSY : this.requestCross(direction);
            if (crossResult != OK) {
                delete this.memory.moveData;
                return ERR_INVALID_TARGET;
            }
        }
        this.memory.prePos = currentPos;
        return OK;
    }
    /* 压缩路径 */
    serializeFarPath(positions) {
        if (positions.length == 0)
            return '';
        // 确保路径里第一个位置是自己当前的位置
        if (!positions[0].isEqualTo(this.pos))
            positions.splice(0, 0, this.pos);
        return positions.map((pos, index) => {
            // 最后一个位置就不用再移动
            if (index >= positions.length - 1)
                return null;
            // 由于房间边缘地块会有重叠，所以这里筛除掉重叠的步骤
            if (pos.roomName != positions[index + 1].roomName)
                return null;
            // 获取到下个位置的方向
            return pos.getDirectionTo(positions[index + 1]);
        }).join('');
    }
}

class PowerCreepMissonBase extends PowerCreep {
    // pc处理任务专用函数
    ManageMisson() {
        /* 获取名字 */
        var name = this.name;
        var info = name.split('/');
        /* pc姓名 如： E41S45/home/shard3/1 */
        // console.log(JSON.stringify)
        // if (!this.memory.belong) this.memory.belong =this.room.name  // 所属房间
        // if (!this.memory.role) this.memory.role = 'queen' // 角色
        // if (!this.memory.shard) this.memory.shard = this.shard as shardName    // 所属shard
        if (info.length != 3) {
            this.say("名字有问题!");
            return;
        }
        if (!this.memory.belong)
            this.memory.belong = info[0]; // 所属房间
        if (!this.memory.role)
            this.memory.role = info[1]; // 角色
        if (!this.memory.shard)
            this.memory.shard = info[2]; // 所属shard
        if (!Game.rooms[this.memory.belong])
            return;
        var thisSpawn = Game.rooms[this.memory.belong].GetStructData('powerspawn');
        if (!thisSpawn)
            return;
        if (!this.memory.spawn) {
            this.memory.spawn = thisSpawn.id;
        }
        // 房间没开power去开power
        if (!Game.rooms[this.memory.belong].controller.isPowerEnabled) {
            /* 没有允许Power就自动激活power开关 */
            if (!this.pos.isNearTo(Game.rooms[this.memory.belong].controller))
                this.goTo(Game.rooms[this.memory.belong].controller.pos, 1);
            else
                this.enableRoom(Game.rooms[this.memory.belong].controller);
            return;
        }
        // 快没生命了去renew
        if (this.room.name == this.memory.belong && this.memory.shard == Game.shard.name) {
            if (this.ticksToLive < 1000) {
                if (!this.pos.isNearTo(thisSpawn)) {
                    this.goTo(thisSpawn.pos, 1);
                }
                else
                    this.renew(thisSpawn);
                return;
            }
        }
        if (!this.memory.MissionData)
            this.memory.MissionData = {};
        if (!Game.rooms[this.memory.belong].memory.Misson['PowerCreep'])
            Game.rooms[this.memory.belong].memory.Misson['PowerCreep'] = [];
        if ((Game.time - global.Gtime[this.room.name]) % 200 == 0) {
            /*根据PC技能调整房间的爬体型*/
            if (!this.room.memory.UpgradespawnConfig['harvest']) {
                this.room.memory.UpgradespawnConfig['harvest'] = 0;
            }
            this.room.memory.UpgradespawnConfig['harvest'] = 1;
            if (this.powers[PWR_REGEN_SOURCE]) {
                this.room.memory.UpgradespawnConfig['harvest'] = 2;
            }
        }
        if (Object.keys(this.memory.MissionData).length <= 0) {
            /* 领取任务 */
            if ((Game.time - global.Gtime[this.room.name]) % 2)
                return;
            var taskList = Game.rooms[this.memory.belong].memory.Misson['PowerCreep'];
            var thisTaskList = [];
            for (var Stask of taskList) {
                if (Stask.CreepBind && isInArray(Object.keys(Stask.CreepBind), this.memory.role))
                    thisTaskList.push(Stask);
            }
            /* 根据优先等级排列，领取最优先的任务 */
            thisTaskList.sort(compare$1('level'));
            /* 还没有绑定的任务，就等待接取任务 */
            LoopBind: for (var t of thisTaskList) {
                if (t.CreepBind && t.CreepBind[this.memory.role] && t.CreepBind[this.memory.role].bind.length < t.CreepBind[this.memory.role].num) {
                    /* 绑定任务了就输入任务数据 */
                    t.processing = true; // 领取任务后，任务开始计时
                    t.CreepBind[this.memory.role].bind.push(this.name);
                    this.memory.MissionData.id = t.id; // 任务id
                    this.memory.MissionData.name = t.name; // 任务名
                    this.memory.MissionData.delay = 150; // 爬虫处理任务的超时时间
                    this.memory.MissionData.Data = t.Data ? t.Data : {}; // 任务数据传输
                    break LoopBind;
                }
            }
            if (Object.keys(this.memory.MissionData).length <= 0) {
                /* 没有任务就生产ops */
                if (this.powers[PWR_GENERATE_OPS] && !this.powers[PWR_GENERATE_OPS].cooldown) {
                    this.usePower(PWR_GENERATE_OPS);
                }
                // 如果ops过多，就转移ops
                if (this.store.getUsedCapacity('ops') == this.store.getCapacity()) {
                    var storage_ = this.room.storage;
                    if (!storage_)
                        return;
                    if (this.transfer(storage_, 'ops', Math.ceil(this.store.getUsedCapacity('ops') / 4)) == ERR_NOT_IN_RANGE)
                        this.goTo(storage_.pos, 1);
                }
            }
            return;
        }
        else {
            /* 处理任务 */
            this.memory.MissionData.delay--; // 爬虫内置Tick计时
            if (this.memory.MissionData.delay <= 0) {
                this.memory.MissionData = {};
                return;
            }
            switch (this.memory.MissionData.name) {
                case "仓库扩容": {
                    this.handle_pwr_storage();
                    break;
                }
                case '塔防增强': {
                    this.handle_pwr_tower();
                    break;
                }
                case '合成加速': {
                    this.handle_pwr_lab();
                    break;
                }
                case '扩展填充': {
                    this.handle_pwr_extension();
                    break;
                }
                case '虫卵强化': {
                    this.handle_pwr_spawn();
                    break;
                }
                case '工厂强化': {
                    this.handle_pwr_factory();
                    break;
                }
                case 'power强化': {
                    this.handle_pwr_powerspawn();
                    break;
                }
                case 'source强化': {
                    this.handle_pwr_source(this.memory.MissionData.Data);
                    break;
                }
            }
        }
    }
    // queen类型pc执行任务前执行的准备
    OpsPrepare() {
        var storage_ = this.room.storage;
        if (!storage_)
            return false;
        // 先去除杂质
        for (let i in this.store) {
            if (i != 'ops') {
                this.transfer_(storage_, i);
                return;
            }
        }
        let num = this.store.getUsedCapacity('ops');
        if (num < 200 || num < Math.ceil(this.store.getCapacity() / 4)) {
            this.usePower(PWR_GENERATE_OPS);
            // 过少就去提取ops资源
            let terminal_ = this.room.terminal;
            if (terminal_ && storage_.store.getUsedCapacity('ops') + terminal_.store.getUsedCapacity('ops') < 2500) {
                // 资源调度
                let room_ = Game.rooms[this.memory.belong];
                if (room_.MissionNum('Structure', '资源购买') <= 0)
                    if (DispatchNum(room_.name) < 2 && !checkSend(room_.name, 'ops') && !checkDispatch(room_.name, 'ops')) // 已经存在其它房间的传送信息的情况
                     {
                        console.log(Colorful$1(`[资源调度] 房间${this.memory.belong}没有足够的资源[${'ops'}],将执行资源调度!`, 'yellow'));
                        let dispatchTask = {
                            sourceRoom: room_.name,
                            rType: 'ops',
                            num: 10000,
                            delayTick: 200,
                            conditionTick: 35,
                            buy: true,
                            mtype: 'deal'
                        };
                        Memory.ResourceDispatchData.push(dispatchTask);
                    }
            }
            if (storage_.store.getUsedCapacity('ops') > 0) {
                var max_pc_number = Number(this.store.getCapacity()) / 2;
                if (this.store.getFreeCapacity() < max_pc_number) {
                    max_pc_number = this.store.getFreeCapacity();
                }
                if (storage_.store.getUsedCapacity('ops') < max_pc_number) {
                    max_pc_number = storage_.store.getUsedCapacity('ops');
                }
                // max_pc_number = max_pc_number < 200 ? 200 : max_pc_number;
                if (this.withdraw(storage_, 'ops', max_pc_number) == ERR_NOT_IN_RANGE) {
                    this.goTo(storage_.pos, 1);
                }
            }
            else if (terminal_.store.getUsedCapacity('ops') > 0) {
                var max_pc_number = Number(this.store.getCapacity()) / 2;
                if (this.store.getFreeCapacity() < max_pc_number) {
                    max_pc_number = this.store.getFreeCapacity();
                }
                if (terminal_.store.getUsedCapacity('ops') < max_pc_number) {
                    max_pc_number = terminal_.store.getUsedCapacity('ops');
                }
                // max_pc_number = max_pc_number < 200 ? 200 : max_pc_number;
                if (this.withdraw(terminal_, 'ops', max_pc_number) == ERR_NOT_IN_RANGE) {
                    this.goTo(terminal_.pos, 1);
                }
            }
            return false;
        }
        else
            return true;
    }
}

class PowerCreepFunctionExtension extends PowerCreep {
    workstate(rType = RESOURCE_ENERGY) {
        if (!this.memory.working)
            this.memory.working = false;
        if (this.memory.working && this.store[rType] == 0) {
            this.memory.working = false;
        }
        if (!this.memory.working && this.store.getFreeCapacity() == 0) {
            this.memory.working = true;
        }
    }
    transfer_(distination, rType = RESOURCE_ENERGY) {
        if (this.transfer(distination, rType) == ERR_NOT_IN_RANGE) {
            this.goTo(distination.pos, 1);
        }
        this.memory.standed = false;
    }
    withdraw_(distination, rType = RESOURCE_ENERGY) {
        if (this.withdraw(distination, rType) == ERR_NOT_IN_RANGE) {
            this.goTo(distination.pos, 1);
        }
        this.memory.standed = false;
    }
}

class PowerCreepMissonAction extends PowerCreep {
    // 操作仓库
    handle_pwr_storage() {
        var storage_ = this.room.storage;
        if (!storage_)
            return;
        if (isOPWR(storage_)) {
            Game.rooms[this.memory.belong].DeleteMission(this.memory.MissionData.id);
            this.memory.MissionData = {};
        }
        if (!this.OpsPrepare())
            return;
        if (!this.pos.inRangeTo(storage_, 2)) {
            this.goTo(storage_.pos, 2);
            return;
        }
        else
            this.usePower(PWR_OPERATE_STORAGE, storage_);
    }
    // 操作tower
    handle_pwr_tower() {
        if (this.powers[PWR_OPERATE_TOWER] && this.powers[PWR_OPERATE_TOWER].cooldown) {
            if (Game.rooms[this.memory.belong].GainMission(this.memory.MissionData.id)) {
                Game.rooms[this.memory.belong].DeleteMission(this.memory.MissionData.id);
                this.memory.MissionData = {};
            }
            else
                this.memory.MissionData = {};
            return;
        }
        if (!this.OpsPrepare())
            return;
        for (var id of this.memory.MissionData.data.tower) {
            var tower_ = Game.getObjectById(id);
            if (!isOPWR(tower_)) {
                if (!this.pos.isNearTo(tower_)) {
                    this.goTo(tower_.pos, 1);
                }
                else {
                    this.usePower(PWR_OPERATE_TOWER, tower_);
                }
                return;
            }
        }
    }
    // 操作lab
    handle_pwr_lab() {
        if (this.powers[PWR_OPERATE_LAB] && this.powers[PWR_OPERATE_LAB].cooldown) {
            if (Game.rooms[this.memory.belong].GainMission(this.memory.MissionData.id)) {
                Game.rooms[this.memory.belong].DeleteMission(this.memory.MissionData.id);
                this.memory.MissionData = {};
            }
            else
                this.memory.MissionData = {};
            return;
        }
        if (!this.OpsPrepare())
            return;
        for (var id of this.memory.MissionData.Data.lab) {
            var lab_ = Game.getObjectById(id);
            if (!isOPWR(lab_)) {
                if (!this.pos.isNearTo(lab_)) {
                    this.goTo(lab_.pos, 1);
                }
                else {
                    this.usePower(PWR_OPERATE_LAB, lab_);
                }
                return;
            }
        }
    }
    // 操作拓展
    handle_pwr_extension() {
        var storage_ = this.room.storage;
        if (!storage_)
            return;
        if (this.powers[PWR_OPERATE_EXTENSION] && this.powers[PWR_OPERATE_EXTENSION].cooldown) {
            if (Game.rooms[this.memory.belong].GainMission(this.memory.MissionData.id)) {
                Game.rooms[this.memory.belong].DeleteMission(this.memory.MissionData.id);
                this.memory.MissionData = {};
            }
            else
                this.memory.MissionData = {};
            return;
        }
        if (!this.OpsPrepare())
            return;
        if (!this.pos.inRangeTo(storage_, 3)) {
            this.goTo(storage_.pos, 3);
            return;
        }
        else
            this.usePower(PWR_OPERATE_EXTENSION, storage_);
    }
    /* 操作孵化 */
    handle_pwr_spawn() {
        if (this.powers[PWR_OPERATE_SPAWN] && this.powers[PWR_OPERATE_SPAWN].cooldown) {
            if (Game.rooms[this.memory.belong].GainMission(this.memory.MissionData.id)) {
                Game.rooms[this.memory.belong].DeleteMission(this.memory.MissionData.id);
                this.memory.MissionData = {};
            }
            else
                this.memory.MissionData = {};
            return;
        }
        var spawningSpawn = this.pos.findClosestByRange(FIND_STRUCTURES, {
            filter: (stru) => {
                return stru.structureType == 'spawn';
            }
        });
        if (!this.OpsPrepare())
            return;
        if (!this.pos.inRangeTo(spawningSpawn, 3)) {
            this.goTo(spawningSpawn.pos, 3);
            return;
        }
        else
            this.usePower(PWR_OPERATE_SPAWN, spawningSpawn);
    }
    /* 操作工厂 */
    handle_pwr_factory() {
        // var factory_ = Game.rooms[this.memory.belong].GetStructData('factory') as StructureStorage
        var factory_ = Game.getObjectById(Game.rooms[this.memory.belong].memory.StructureIdData.FactoryId);
        if (!factory_) {
            delete Game.rooms[this.memory.belong].memory.StructureIdData.FactoryId;
            return;
        }
        if (this.powers[PWR_OPERATE_FACTORY] && this.powers[PWR_OPERATE_FACTORY].cooldown) {
            if (Game.rooms[this.memory.belong].GainMission(this.memory.MissionData.id)) {
                Game.rooms[this.memory.belong].DeleteMission(this.memory.MissionData.id);
                this.memory.MissionData = {};
            }
            else
                this.memory.MissionData = {};
            return;
        }
        if (!this.OpsPrepare())
            return;
        if (!this.pos.inRangeTo(factory_, 3)) {
            this.goTo(factory_.pos, 3);
            return;
        }
        else
            this.usePower(PWR_OPERATE_FACTORY, factory_);
    }
    /* 操作powerspawn */
    handle_pwr_powerspawn() {
        // var powerspawn_ = Game.rooms[this.memory.belong].GetStructData('powerspawn') as StructureStorage
        var powerspawn_ = Game.getObjectById(Game.rooms[this.memory.belong].memory.StructureIdData.PowerSpawnID);
        if (!powerspawn_) {
            delete Game.rooms[this.memory.belong].memory.StructureIdData.PowerSpawnID;
            return;
        }
        if (this.powers[PWR_OPERATE_POWER] && this.powers[PWR_OPERATE_POWER].cooldown) {
            if (Game.rooms[this.memory.belong].GainMission(this.memory.MissionData.id)) {
                Game.rooms[this.memory.belong].DeleteMission(this.memory.MissionData.id);
                this.memory.MissionData = {};
            }
            else
                this.memory.MissionData = {};
            return;
        }
        if (!this.OpsPrepare())
            return;
        if (!this.pos.inRangeTo(powerspawn_, 3)) {
            this.goTo(powerspawn_.pos, 3);
            return;
        }
        else
            this.usePower(PWR_OPERATE_POWER, powerspawn_);
    }
    /*操作source*/
    handle_pwr_source(Data) {
        var source_ = Game.getObjectById(Data.source_id);
        if (!source_)
            return;
        if (source_.effects) {
            if (source_.effects.length > 0) {
                if (this.memory.MissionData.id) {
                    Game.rooms[this.memory.belong].DeleteMission(this.memory.MissionData.id);
                }
                this.memory.MissionData = {};
            }
        }
        if (!this.OpsPrepare())
            return;
        if (!this.pos.inRangeTo(source_, 2)) {
            this.goTo(source_.pos, 2);
            return;
        }
        else {
            this.usePower(PWR_REGEN_SOURCE, source_);
        }
    }
}

// 定义好挂载顺序
const plugins = [
    PowerCreepMoveExtension,
    PowerCreepMissonBase,
    PowerCreepFunctionExtension,
    PowerCreepMissonAction,
];
/**
* 依次挂载所有的拓展
*/
var mountPowerCreep = () => plugins.forEach(plugin => assignPrototype(PowerCreep, plugin));

/**
 * 创建帮助信息
 * 给帮助的显示添加一点小细节
 *
 * @param modules 模块的描述
 */
function createHelp(...modules) {
    return moduleStyle() + apiStyle() + `<div class="module-help">${modules.map(createModule).join('')}</div>`;
}
const createModule = function (module) {
    const functionList = module.api.map(createApiHelp).join('');
    const html = `<div class="module-container">
        <div class="module-info">
            <span class="module-title">${Colorful$1(module.name, 'yellow')}</span>
            <span class="module-describe">${Colorful$1(module.describe, 'green')}</span>
        </div>
        <div class="module-api-list">${functionList}</div>
    </div>`;
    return html.replace(/\n/g, '');
};
/**
 * 绘制单个 api 的帮助元素
 *
 * @param func api 的描述信息
 * @returns 绘制完成的字符串
 */
const createApiHelp = function (func) {
    const contents = [];
    // 介绍
    if (func.describe)
        contents.push(Colorful$1(func.describe, 'green'));
    // 参数介绍
    if (func.params)
        contents.push(func.params.map(param => {
            return `  - ${Colorful$1(param.name, 'blue')}: ${Colorful$1(param.desc, 'green')}`;
        }).map(s => `<div class="api-content-line">${s}</div>`).join(''));
    // 函数示例中的参数
    let paramInFunc = func.params ? func.params.map(param => Colorful$1(param.name, 'blue')).join(', ') : '';
    // 如果启用了命令模式的话就忽略其参数
    let funcCall = Colorful$1(func.functionName, 'yellow') + (func.commandType ? '' : `(${paramInFunc})`);
    // 函数示例
    contents.push(funcCall);
    const content = contents.map(s => `<div class="api-content-line">${s}</div>`).join('');
    const checkboxId = `${func.functionName}${Game.time}`;
    // return func.params ? `${title}\n${param}\n${functionName}\n` : `${title}\n${functionName}\n`
    const result = `
    <div class="api-container">
        <label for="${checkboxId}">${func.title} ${Colorful$1(func.functionName, 'yellow', true)}</label>
        <input id="${checkboxId}" type="checkbox" />
        <div class="api-content">${content}</div>
    </div>
    `;
    return result.replace(/\n/g, '');
};
const moduleStyle = function () {
    const style = `
    <style>
    .module-help {
        display: flex;
        flex-flow: column nowrap;
    }
    .module-container {
        padding: 0px 10px 10px 10px;
        display: flex;
        flex-flow: column nowrap;
    }
    .module-info {
        margin: 5px;
        display: flex;
        flex-flow: row nowrap;
        align-items: baseline;
    }
    .module-title {
        font-size: 19px;
        font-weight: bolder;
        margin-left: -15px;
    }
    .module-api-list {
        display: flex;
        flex-flow: row wrap;
    }
    </style>`;
    return style.replace(/\n/g, '');
};
const apiStyle = function () {
    const style = `
    <style>
    .api-content-line {
        width: max-content;
        padding-right: 15px;
    }
    .api-container {
        margin: 5px;
        width: 250px;
        background-color: #2b2b2b;
        overflow: hidden;
        display: flex;
        flex-flow: column;
    }

    .api-container label {
        transition: all 0.1s;
        min-width: 300px;
        
    }
    
    /* 隐藏input */
    .api-container input {
        display: none;
    }
    
    .api-container label {
        cursor: pointer;
        display: block;
        padding: 10px;
        background-color: #3b3b3b;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    
    .api-container label:hover, label:focus {
        background-color: #525252;
    }
    
    /* 清除所有展开的子菜单的 display */
    .api-container input + .api-content {
        overflow: hidden;
        transition: all 0.1s;
        width: auto;
        max-height: 0px;
        padding: 0px 10px;
    }
    
    /* 当 input 被选中时，给所有展开的子菜单设置样式 */
    .api-container input:checked + .api-content {
        max-height: 200px;
        padding: 10px;
        background-color: #1c1c1c;
        overflow-x: auto;
    }
    </style>`;
    return style.replace(/\n/g, '');
};

/**
 * 全局拓展的别名
 * 使用别名来方便在控制台执行方法
 *
 * @property {string} alias 别名
 * @property {function} exec 执行别名时触发的操作
 */
var extension = [
    // 常用的资源常量
    {
        alias: 'help',
        exec: function () {
            return [
                ...projectTitle.map(line => colorful(line, 'green', true)),
                '\n',
                '使用前请详细阅读如下规则:',
                '1.使用frame.add时,如果布局为man,房间的中心点需要两格内有1个link和1个tower(如果刚开局,以后有就行了).',
                '2.预设布局有不同的控制中心点:',
                '   2.1如果布局为dev,中心点在你第一个spawn向右两格.',
                '   2.2如果布局为tea,中心点在你第一个spawn向右五格.',
                '   2.3如果布局为hoho,中心点在你第一个spawn向右三格,向下两格.',
                '3.能力越大责任越大,不要使用该框架欺负萌新!',
                '4.急速冲级代码不了解使用方法不要使用,否则有宕机风险!',
                '5.本框架攻击模块具备各类型攻击代码及多次跨shard打击能力(超时空军团),除非自保,否则不要滥用!',
                '6.不保证该代码没有Bug,遇到bug欢迎QQ群里找Mikebraton交流报告.',
                '\n',
                Colorful$1('如果同意请控制台输入  manual', 'yellow', true),
            ].join('\n');
        }
    },
    // manual
    {
        alias: 'manual',
        exec: function () {
            return [
                ...projectTitle.map(line => colorful(line, 'blue', true)),
                createHelp({
                    name: '《帮助手册及使用指南》',
                    describe: '各类型手册请在这里查找',
                    api: [
                        {
                            title: '全局命令手册',
                            commandType: true,
                            describe: '与房间无关的命令手册',
                            functionName: 'manual_global'
                        },
                        {
                            title: '框架控制手册',
                            commandType: true,
                            describe: '房间控制相关的命令手册 【重要】',
                            functionName: 'manual_room'
                        },
                        {
                            title: '爬虫行为手册',
                            commandType: true,
                            describe: '涉及爬虫的具体行为相关的任务,比如战争、搬运等',
                            functionName: 'manual_creep'
                        },
                        {
                            title: '统计相关手册',
                            commandType: true,
                            describe: '统计房间的资源、cpu等及可视化等相关的命令手册',
                            functionName: 'manual_stat'
                        },
                        {
                            title: '旗帜使用手册',
                            commandType: true,
                            describe: '列举所有任务中可能有用的旗帜',
                            functionName: 'manual_flag'
                        },
                    ]
                })
            ].join('\n');
        }
    },
    // global
    {
        alias: 'manual_global',
        exec: function () {
            return [
                ...projectTitle.map(line => colorful(line, 'blue', true)),
                createHelp({
                    name: '名单相关',
                    describe: '全局名单',
                    api: [
                        {
                            title: '添加绕过房间:',
                            describe: '例: bypass.add("W1N1")',
                            params: [
                                { name: 'roomName', desc: '绕过的房间' },
                            ],
                            functionName: 'bypass.add'
                        },
                        {
                            title: '查看绕过房间:',
                            describe: '例: bypass.show()',
                            functionName: 'bypass.show'
                        },
                        {
                            title: '清空绕过房间:',
                            describe: '例: bypass.clean()',
                            functionName: 'bypass.clean'
                        },
                        {
                            title: '移除绕过房间:',
                            describe: '例: bypass.remove("W1N1")',
                            params: [
                                { name: 'roomName', desc: '移除的房间' },
                            ],
                            functionName: 'bypass.remove'
                        },
                        {
                            title: '添加白名单:',
                            describe: '例: whitelist.add("")',
                            params: [
                                { name: 'username', desc: '添加的用户名' },
                            ],
                            functionName: 'whitelist.add'
                        },
                        {
                            title: '查看白名单:',
                            describe: '例: whitelist.show()',
                            functionName: 'whitelist.show'
                        },
                        {
                            title: '清空白名单:',
                            describe: '例: whitelist.clean()',
                            functionName: 'whitelist.clean'
                        },
                        {
                            title: '移除白名单:',
                            describe: '例: whitelist.remove("")',
                            params: [
                                { name: 'username', desc: '移除的用户名' },
                            ],
                            functionName: 'whitelist.remove'
                        },
                        {
                            title: '忽略控制台任务输出:',
                            params: [
                                { name: 'name', desc: '任务名字' },
                            ],
                            functionName: 'missionInfo.ignore'
                        },
                        {
                            title: '恢复控制台任务输出:',
                            params: [
                                { name: 'name', desc: '任务名字' },
                            ],
                            functionName: 'missionInfo.remove'
                        },
                        {
                            title: '忽略控制台lab输出:',
                            params: [
                                { name: 'ignore', desc: 'true | false' },
                            ],
                            functionName: 'missionInfo.lab'
                        },
                        {
                            title: '开启/关闭自动搓像素(默认开启):',
                            functionName: 'pixel.switch'
                        },
                        {
                            title: '自动买像素:',
                            describe: '例: pixel.buy(100,25000,10,20000)',
                            params: [
                                { name: 'num', desc: '数量' },
                                { name: 'price', desc: '价格' },
                                { name: 'unit', desc: '(可选) 单次购入数量' },
                                { name: 'floor', desc: '(可选) 自动调价价格下限' },
                            ],
                            functionName: 'pixel.buy'
                        },
                        {
                            title: '自动卖像素:',
                            describe: '例: pixel.sell(100,30000,10,40000)',
                            params: [
                                { name: 'num', desc: '数量' },
                                { name: 'price', desc: '价格' },
                                { name: 'unit', desc: '(可选) 单次卖出数量' },
                                { name: 'ceil', desc: '(可选) 自动调价价格上限' },
                            ],
                            functionName: 'pixel.sell'
                        },
                        {
                            title: '取消买卖像素:',
                            describe: '例: pixel.cancel("sell")',
                            params: [
                                { name: 'type', desc: '交易类型 buy | sell' },
                            ],
                            functionName: 'pixel.sell'
                        },
                    ]
                }, {
                    name: '行为相关',
                    describe: '全局行为',
                    api: [
                        {
                            title: '全局资源传送:',
                            describe: '无需指定自己房间名,传送资源到目标房间',
                            params: [
                                { name: 'roomName', desc: '目标房间' },
                                { name: 'res', desc: '目标资源类型' },
                                { name: 'num', desc: '目标资源数量' },
                                { name: 'pass', desc: '非自己房间需要为true作为验证' },
                            ],
                            functionName: 'give.set'
                        },
                        {
                            title: '取消全局资源传送:',
                            describe: '还需要配合terminal.Csend来取消已经纳入规划的传送任务',
                            params: [
                                { name: 'roomName', desc: '目标房间' },
                                { name: 'res', desc: '目标资源类型' },
                            ],
                            functionName: 'give.remove'
                        },
                        {
                            title: '删除所有旗帜:',
                            describe: '此操作会删除游戏内所有旗帜, 包括手动插的',
                            params: [
                                { name: 'roomName', desc: '目标房间' },
                                { name: 'res', desc: '目标资源类型' },
                            ],
                            functionName: 'flag.clear'
                        },
                    ]
                })
            ].join('\n');
        }
    },
    // room
    {
        alias: 'manual_room',
        exec: function () {
            return [
                ...projectTitle.map(line => colorful(line, 'blue', true)),
                createHelp(
                // 框架控制
                {
                    name: '房间控制、监控',
                    describe: '* 涉及房间管理、控制的命令',
                    api: [
                        {
                            title: '添加控制房间:',
                            describe: '例: frame.add("W1N1","man",14,23)',
                            params: [
                                { name: 'roomName', desc: '想控制的房间' },
                                { name: 'plan', desc: '手动布局: man; 预设布局: dev | tea | hoho' },
                                { name: 'x', desc: '中心点的x坐标 注意: 预设布局中心点请详见输入help' },
                                { name: 'y', desc: '中心点的y坐标 中心点选取请慎重,详见help' },
                            ],
                            functionName: 'frame.add'
                        },
                        {
                            title: '删除控制房间:',
                            describe: '例: frame.remove("W1N1") 还需手动unclaim房间',
                            params: [
                                { name: 'roomName', desc: '想删除控制的房间' },
                            ],
                            functionName: 'frame.remove'
                        },
                        {
                            title: '房间内建筑拆除:',
                            describe: '例: frame.del("W1N1",12,23,"road") 千万不能手动拆自己房间内除了wall之外的任何建筑',
                            params: [
                                { name: 'roomName', desc: '我所控制的房间' },
                                { name: 'x', desc: '要拆除的建筑x坐标' },
                                { name: 'y', desc: '要拆除的建筑y坐标' },
                                { name: 'structureType', desc: '要拆除的建筑类型' },
                            ],
                            functionName: 'frame.del'
                        },
                        {
                            title: '房间所有建筑拆除:',
                            describe: '仅拆除敌对建筑;例: frame.delType("W1N1","road") 千万不能手动拆自己房间内除了wall之外的任何建筑',
                            params: [
                                { name: 'roomName', desc: '我所控制的房间' },
                                { name: 'structureType', desc: '要拆除的建筑类型' },
                            ],
                            functionName: 'frame.delType'
                        },
                        {
                            title: '房间进入经济模式:',
                            describe: '例: frame.economy("W1N1") 8级房能用,进入经济模式后,不会一直升级,节省能量和cpu',
                            params: [
                                { name: 'roomName', desc: '我所控制的房间' },
                            ],
                            functionName: 'frame.economy'
                        },
                        {
                            title: '所有房间进入经济模式:',
                            describe: '例: frame.allEconomy() 所有8级房进入经济模式',
                            functionName: 'frame.allEconomy'
                        },
                        {
                            title: '查询房间内当前存在的任务:',
                            describe: '例: frame.task("W1N1") ',
                            params: [
                                { name: 'roomName', desc: '我所控制的房间' },
                            ],
                            functionName: 'frame.task'
                        },
                        {
                            title: '新房快速初始化:',
                            describe: '例: frame.speedup("W1N1")',
                            params: [
                                { name: 'roomName', desc: '我所控制的房间' },
                            ],
                            functionName: 'frame.speedup'
                        },
                        {
                            title: '房间可视化切换:',
                            describe: '例: visual.toggle("W1N1")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                            ],
                            functionName: 'visual.toggle'
                        },
                    ]
                }, 
                // 日常维护
                {
                    name: '日常维护',
                    describe: '* 例如爬虫数量的调整、任务的手动删除等',
                    api: [
                        {
                            title: '计算房间日常开销:',
                            describe: '例: maintain.cost("W1N1")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                            ],
                            functionName: 'maintain.cost'
                        },
                        {
                            title: '常驻爬虫数量调整:',
                            describe: '只适用于upgrade harvest carry transport manage build类型爬虫;例:spawn.num("W1N1","carry",1)',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'role', desc: '爬虫角色类型' },
                                { name: 'num', desc: '爬虫数量' },
                            ],
                            functionName: 'spawn.num'
                        },
                        {
                            title: '任务爬虫数量调整:',
                            describe: '适用于任务类型爬虫的数量调整;例:spawn.Mnum("W1N1","C-85ednh1ib439985674","aio",1)',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'id', desc: '任务id' },
                                { name: 'role', desc: '爬虫角色类型' },
                                { name: 'num', desc: '爬虫数量' },
                            ],
                            functionName: 'spawn.Mnum'
                        },
                        {
                            title: '定时孵化任务孵化配置一键还原:',
                            describe: '修改定时信息,立刻重新孵化;例:spawn.restart("W1N1","C-85ednh1ib439985674")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'id', desc: '任务id' },
                            ],
                            functionName: 'spawn.restart'
                        },
                        {
                            title: '启用替代爬虫配置:',
                            describe: '例:spawn.altConfig("W1N1","transport",1)',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'role', desc: '爬虫类型' },
                                { name: 'num', desc: '爬虫数量' },
                            ],
                            functionName: 'spawn.altConfig'
                        },
                        {
                            title: '孵化额外transport:',
                            describe: '例:spawn.extraTransport("W1N1",1)',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'num', desc: '爬虫数量' },
                            ],
                            functionName: 'spawn.extraTransport'
                        },
                        {
                            title: '资源转移:【推荐】',
                            describe: '从房间A传资源(或所有)到房间B(需要有终端和仓库) 例:logistic.send("W1N1","W1N2","GH2O",20000)',
                            params: [
                                { name: 'roomName', desc: '源房间' },
                                { name: 'destRoom', desc: '目标房间' },
                                { name: 'rType(可选)', desc: '资源类型【不选表示除energy和ops外所有资源】' },
                                { name: 'num(可选)', desc: '资源数量【不限制数量】,不选表示全部数量' },
                            ],
                            functionName: 'logistic.send'
                        },
                        {
                            title: '取消资源转移:',
                            describe: '取消从房间A传资源到房间B(需要有终端和仓库) 例:logistic.Csend("W1N1","W1N2")',
                            params: [
                                { name: 'roomName', desc: '源房间' },
                                { name: 'destRoom', desc: '目标房间' },
                            ],
                            functionName: 'logistic.Csend'
                        },
                        {
                            title: '资源转移信息查询:',
                            describe: '例:logistic.show()',
                            params: [],
                            functionName: 'logistic.show'
                        },
                        {
                            title: '资源传送:【不推荐】',
                            describe: '从房间A传资源到房间B(需要有终端和仓库) 例:terminal.send("W1N1","W1N2","GH2O",20000)',
                            params: [
                                { name: 'roomName', desc: '源房间' },
                                { name: 'destRoom', desc: '目标房间' },
                                { name: 'rType', desc: '资源类型' },
                                { name: 'num', desc: '资源数量【不能高于150000】' },
                            ],
                            functionName: 'terminal.send'
                        },
                        {
                            title: '取消资源传送:',
                            describe: '取消从房间A传资源到房间B(需要有终端和仓库) 例:terminal.Csend("W1N1","W1N2","GH2O")',
                            params: [
                                { name: 'roomName', desc: '源房间' },
                                { name: 'destRoom', desc: '目标房间' },
                                { name: 'rType', desc: '资源类型' },
                            ],
                            functionName: 'terminal.Csend'
                        },
                        {
                            title: '查看现在所有的资源传送情况:',
                            describe: '从房间A传资源到房间B(需要有终端和仓库) 例:terminal.show()',
                            functionName: 'terminal.show'
                        },
                        {
                            title: '查看房间资源调度上限:',
                            describe: 'dispatch.show("W1N1")',
                            params: [
                                { name: 'roomName', desc: '源房间' },
                            ],
                            functionName: 'dispatch.show'
                        },
                        {
                            title: '注册消费link:',
                            describe: '让中央link自动向某link传送能量 例:link.comsume("W1N1","6204890bedf59067e60b4df3")',
                            params: [
                                { name: 'roomName', desc: '房间' },
                                { name: 'linkID', desc: 'link的ID' },
                            ],
                            functionName: 'link.comsume'
                        },
                        {
                            title: '删除具体任务:',
                            describe: '例:Game.rooms["xxxx"].DeleteMission("C-85ednh1ib439985674")',
                            params: [
                                { name: 'missionID', desc: '任务Id' },
                            ],
                            functionName: 'Game.rooms["xxxx"].DeleteMission'
                        },
                    ]
                }, 
                // 市场行为
                {
                    name: '市场行为',
                    describe: '与市场有关的各类命令',
                    api: [
                        {
                            title: '成交某订单:',
                            describe: '使用deal 例: market.deal("W1N1","624297baf8094abe1c16a8b8",10000)',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'orderID', desc: '单子的id' },
                                { name: 'num', desc: '数量' },
                            ],
                            functionName: 'market.deal'
                        },
                        {
                            title: '查询市场上的订单:',
                            describe: '查询市场上的订单 例: market.look("GH2O","sell")',
                            params: [
                                { name: 'rType', desc: '资源类型' },
                                { name: 'mType', desc: '交易类型: buy | sell' },
                            ],
                            functionName: 'market.look'
                        },
                        {
                            title: '下单买某类型资源:',
                            describe: '例: market.buy("W1N1","GH2O","order",30000,35,10000,true)',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'rType', desc: '资源类型' },
                                { name: 'mtype', desc: '交易类型: deal | order' },
                                { name: 'num', desc: '数量' },
                                { name: 'price', desc: '价格' },
                                { name: 'unit', desc: '(可选) 单次购入数量' },
                                { name: 'confirm', desc: '(可选) 确认交易(总额大于10M时需确认)' },
                            ],
                            functionName: 'market.buy'
                        },
                        {
                            title: '查询某类型资源的近n天的平均价格:',
                            describe: '例: market.ave("GH2O",7)',
                            params: [
                                { name: 'rType', desc: '资源类型' },
                                { name: 'day', desc: '天数' },
                            ],
                            functionName: 'market.ave'
                        },
                        {
                            title: '查询是否有订单:',
                            describe: '例: market.have("W1N1,"GH2O","buy",50,10)',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'rType', desc: '资源类型' },
                                { name: 'mType', desc: '交易类型: buy | sell' },
                                { name: 'price', desc: '(可选) 价格' },
                                { name: 'range', desc: '(可选) 浮动区间' },
                            ],
                            functionName: 'market.have'
                        },
                        {
                            title: '查询市场上资源的最高价格:',
                            describe: '例: market.highest("GH2O","buy",100)',
                            params: [
                                { name: 'rType', desc: '资源类型' },
                                { name: 'mType', desc: '交易类型: buy | sell' },
                                { name: 'limit', desc: '(可选) 价格上限' },
                            ],
                            functionName: 'market.highest'
                        },
                        {
                            title: '查询市场上资源的最低价格:',
                            describe: '例: market.lowest("GH2O","sell",100)',
                            params: [
                                { name: 'rType', desc: '资源类型' },
                                { name: 'mType', desc: '交易类型: buy | sell' },
                                { name: 'limit', desc: '(可选) 价格下限' },
                            ],
                            functionName: 'market.lowest'
                        },
                        {
                            title: '卖资源:',
                            describe: '例: market.sell("W1N1","L","deal",5000)',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'rType', desc: '资源类型' },
                                { name: 'mtype', desc: '交易类型: deal | order' },
                                { name: 'num', desc: '想卖掉的数量' },
                                { name: 'price', desc: '(可选) 对于deal来说的最低价格' },
                                { name: 'unit', desc: '(可选) 单次卖出数量' },
                            ],
                            functionName: 'market.sell'
                        },
                        {
                            title: '查询某房间正在卖的资源:',
                            describe: '例: market.query("W1N1")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                            ],
                            functionName: 'market.query'
                        },
                        {
                            title: '取消资源的卖出任务:',
                            describe: '例: market.cancel("W1N1","deal","GH2O")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'rType', desc: '资源类型' },
                                { name: 'mtype', desc: '交易类型: deal | order' },
                            ],
                            functionName: 'market.cancel'
                        },
                        {
                            title: '更改订单价格:',
                            describe: '例: market.revise("W1N1","GH2O","deal","sell",100)',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'rType', desc: '资源类型' },
                                { name: 'mtype', desc: '交易类型: deal | order' },
                                { name: 'mType', desc: '交易类型: buy | sell' },
                                { name: 'price', desc: '新价格' },
                            ],
                            functionName: 'market.revise'
                        },
                        {
                            title: '重置房间能量价格:',
                            describe: '例: market.resetEnergyPrice("W1N1")',
                            params: [
                                { name: 'roomName', desc: '房间名 | all (所有房间)' },
                            ],
                            functionName: 'market.resetEnergyPrice'
                        },
                    ]
                }, 
                // 日常行为
                {
                    name: '日常行为',
                    describe: '房间一些日常行为的控制',
                    api: [
                        // outmine
                        {
                            title: '外矿采集:',
                            describe: '例: mine.harvest("W1N1",14,23,"W1N2")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'X', desc: '自己房间内采集起始点的x坐标(用于自动造路)' },
                                { name: 'Y', desc: '自己房间内采集起始点的y坐标(用于自动造路)' },
                                { name: 'destRoom', desc: '目标房间名' },
                            ],
                            functionName: 'mine.harvest'
                        },
                        {
                            title: '取消外矿采集:',
                            describe: '例: mine.Charvest("W1N1","W1N2")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'destRoom', desc: '目标房间名' },
                            ],
                            functionName: 'mine.Charvest'
                        },
                        {
                            title: '更新外矿路径信息:',
                            describe: '例: mine.update("W1N1","W1N2")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'destRoom', desc: '目标房间名' },
                            ],
                            functionName: 'mine.update'
                        },
                        {
                            title: '强制更新外矿路径信息:',
                            describe: '例: mine.forceUpdate("W1N1","W1N2")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'destRoom', desc: '目标房间名' },
                            ],
                            functionName: 'mine.forceUpdate'
                        },
                        {
                            title: '删除外矿路径信息:',
                            describe: '例: mine.delRoad("W1N1","W1N2")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'destRoom', desc: '目标房间名' },
                            ],
                            functionName: 'mine.delRoad'
                        },
                        // nuke
                        {
                            title: '核弹发射:',
                            describe: '例: nuke.launch("W1N1","W1N2",12,34)',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'destRoom', desc: '目标房间名' },
                                { name: 'X', desc: '核弹着弹点x坐标' },
                                { name: 'Y', desc: '核弹着弹点y坐标' },
                            ],
                            functionName: 'nuke.launch'
                        },
                        {
                            title: '开/关核弹自动填充:',
                            describe: '例: nuke.switch("W1N1")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                            ],
                            functionName: 'nuke.switch'
                        },
                        {
                            title: '主防忽略指定ram:',
                            describe: '例: rampart.add("W1N1",25,25)',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'x', desc: '忽略ram的x坐标' },
                                { name: 'y', desc: '忽略ram的y坐标' },
                            ],
                            functionName: 'rampart.add'
                        },
                        {
                            title: '取消忽略指定ram:',
                            describe: '例: rampart.remove("W1N1",25,25)',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'x', desc: '取消忽略ram的x坐标' },
                                { name: 'y', desc: '取消忽略ram的y坐标' },
                            ],
                            functionName: 'rampart.remove'
                        },
                    ]
                }, {
                    name: '实验室',
                    describe: '控制房间内实验室的行为',
                    api: [
                        // lab                       
                        {
                            title: 'lab初始化 (新造的lab必须初始化):',
                            describe: '例: lab.init("W1N1")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                            ],
                            functionName: 'lab.init'
                        },
                        {
                            title: '化合物合成【不建议】:',
                            describe: '例: lab.compound("W1N1","OH",1000)',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'type', desc: '资源类型' },
                                { name: 'num', desc: '资源数量' },
                            ],
                            functionName: 'lab.compound'
                        },
                        {
                            title: '取消化合物合成:',
                            describe: '例: lab.Ccompound("W1N1")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                            ],
                            functionName: 'lab.Ccompound'
                        },
                        {
                            title: '合成自动规划【建议】:',
                            describe: '自动合成低级化合物,规划合成 例: lab.dispatch("W1N1","XKHO2",1000)',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'type', desc: '资源类型' },
                                { name: 'num', desc: '资源数量' },
                            ],
                            functionName: 'lab.dispatch'
                        },
                        {
                            title: '取消资源合成规划:',
                            describe: '取消资源合成规划,配合lab.Ccompound使用 例: lab.Cdispatch("W1N1")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                            ],
                            functionName: 'lab.Cdispatch'
                        },
                        {
                            title: '实验室自动合成:',
                            describe: '实验室会在房间储量低于一定值时自动合成, 例: lab.addAuto("W1N1","G",10000)',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'type', desc: '资源类型' },
                                { name: 'num', desc: '资源数量' },
                            ],
                            functionName: 'lab.addAuto'
                        },
                        {
                            title: '取消实验室自动合成:',
                            describe: '例: lab.delAuto("W1N1","G")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'type', desc: '资源类型' },
                            ],
                            functionName: 'lab.delAuto'
                        },
                        {
                            title: '取消所有自动合成:',
                            describe: '例: lab.cancelAuto("W1N1")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                            ],
                            functionName: 'lab.cancelAuto'
                        },
                    ]
                }, {
                    name: '工厂',
                    describe: '控制房间内工厂的行为',
                    api: [
                        // factory
                        {
                            title: '工厂等级初始化:',
                            describe: '如果工厂有pc,并且有工厂等级,需要初始化工厂等级',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                            ],
                            functionName: 'factory.level'
                        },
                        {
                            title: '启动/关闭 工厂:',
                            describe: '默认开启',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                            ],
                            functionName: 'factory.switch'
                        },
                        {
                            title: '输出工厂目前工作状态:',
                            describe: '例: factory.show("W1N1")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                            ],
                            functionName: 'factory.show'
                        },
                        {
                            title: '添加工厂基本商品生产列表:',
                            describe: '基本商品生产列表 例: factory.add("W1N1","utrium_bar",10000)',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'cType', desc: '商品类型' },
                                { name: 'num', desc: '数量' },
                            ],
                            functionName: 'factory.add'
                        },
                        {
                            title: '删除工厂基本商品生产:',
                            describe: ' 例: factory.remove("W1N1","utrium_bar")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'cType', desc: '商品类型' },
                            ],
                            functionName: 'factory.remove'
                        },
                        {
                            title: '设置工厂流水线商品:',
                            describe: '只能是流水线商品 例: factory.set("W1N1","machine") ',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'cType', desc: '商品类型' },
                            ],
                            functionName: 'factory.set'
                        },
                        {
                            title: '删除工厂流水线商品:',
                            describe: '例: factory.del("W1N1","machine")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'cType', desc: '商品类型' },
                            ],
                            functionName: 'factory.del'
                        },
                        {
                            title: '解压特定商品:',
                            describe: '例: factory.decompress("W1N1","keanium_bar",10000)',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'cType', desc: '商品类型' },
                                { name: 'num', desc: '数量' },
                            ],
                            functionName: 'factory.decompress'
                        },
                        {
                            title: '取消解压特定商品:',
                            describe: '例: factory.Cdecompress("W1N1","keanium_bar")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'cType', desc: '商品类型' },
                            ],
                            functionName: 'factory.Cdecompress'
                        },
                        {
                            title: '切换自动解压所有商品:',
                            describe: '例: factory.autoDecompress("W1N1")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                            ],
                            functionName: 'factory.autoDecompress'
                        },
                    ]
                }, {
                    name: '过道',
                    describe: '控制房间的过道采集任务',
                    api: [
                        // cross
                        {
                            title: '初始化过道采集任务(此前未初始化必须初始化):',
                            describe: '例: cross.init("W1N1",["W1N0","W2N0","W3N0"])',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'realteRooms', desc: '想采集的过道房间列表' },
                            ],
                            functionName: 'cross.init'
                        },
                        {
                            title: '开启/关闭过道:',
                            describe: '例: cross.switch("W1N1")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                            ],
                            functionName: 'cross.switch'
                        },
                        {
                            title: '增加过道房间:',
                            describe: '例: cross.add("W1N1","W4N0")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'crossRoom', desc: '过道房间名' },
                            ],
                            functionName: 'cross.add'
                        },
                        {
                            title: '删除过道房间:',
                            describe: '例: cross.remove("W1N1","W4N0")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'crossRoom', desc: '过道房间名' },
                            ],
                            functionName: 'cross.remove'
                        },
                        {
                            title: '开启/关闭 power采集:',
                            describe: '例: cross.power("W1N1")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                            ],
                            functionName: 'cross.power'
                        },
                        {
                            title: '删除特定power采集任务:',
                            describe: '例: cross.delPower("W1N1","W2N0")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'crossRoom', desc: '过道房间名' },
                            ],
                            functionName: 'cross.delPower'
                        },
                        {
                            title: '开启/关闭 deposit采集:',
                            describe: '例: cross.deposit("W1N1")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                            ],
                            functionName: 'cross.deposit'
                        },
                        {
                            title: '展示过道采集情况:',
                            describe: '例: cross.show("W1N1")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                            ],
                            functionName: 'cross.show'
                        },
                        {
                            title: '取消过道采集任务:',
                            describe: '例: cross.cancel("W1N1")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                            ],
                            functionName: 'cross.cancel'
                        },
                    ]
                }, {
                    name: '帕瓦',
                    describe: '控制房间的帕瓦消耗',
                    api: [
                        // power
                        {
                            title: '启动/关闭 GPL升级:',
                            describe: '例:power.switch("W1N1")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                            ],
                            functionName: 'power.switch'
                        },
                        {
                            title: 'GPL升级节省能量模式:',
                            describe: '例:power.save("W1N1")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                            ],
                            functionName: 'power.save'
                        },
                        {
                            title: '限制/激活 PC技能:',
                            describe: '只适用于queen类爬虫 例:power.option("W1N1","factory")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'structure', desc: '建筑类型' },
                            ],
                            functionName: 'power.option'
                        },
                        {
                            title: '输出PC技能限制/激活信息:',
                            describe: '只适用于queen类爬虫 例:power.show("W1N1")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                            ],
                            functionName: 'power.show'
                        },
                        {
                            title: '创建pc:',
                            describe: ' 例:power.create("W1N1","queen")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'role', desc: 'pc角色名' },
                            ],
                            functionName: 'power.create'
                        },
                        {
                            title: '删除pc:',
                            describe: ' 例:power.del("W1N1/queen/shard3")',
                            params: [
                                { name: 'name', desc: 'pc名' },
                            ],
                            functionName: 'power.del'
                        },
                        {
                            title: '添加帕瓦供应:',
                            describe: ' 例:power.add("W1N1")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                            ],
                            functionName: 'powerSupply.add'
                        },
                        {
                            title: '移除帕瓦供应:',
                            describe: ' 例:power.remove("W1N1")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                            ],
                            functionName: 'powerSupply.remove'
                        },
                        {
                            title: '查看帕瓦供应列表:',
                            describe: ' 例:power.show()',
                            functionName: 'powerSupply.show'
                        },
                        {
                            title: '清空帕瓦供应列表:',
                            describe: ' 例:power.clean()',
                            functionName: 'powerSupply.clean'
                        },
                    ]
                })
            ].join('\n');
        }
    },
    // creep
    {
        alias: 'manual_creep',
        exec: function () {
            return [
                ...projectTitle.map(line => colorful(line, 'blue', true)),
                createHelp({
                    name: '日常行为',
                    describe: '日常升级、刷墙等命令',
                    api: [
                        {
                            title: '刷墙:',
                            describe: '例: repair.set("W1N1","global",1,"LH","T0")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'type', desc: '刷墙类型 global | globalrampart | globalwall | special(只刷旗子下的墙)' },
                                { name: 'num', desc: '刷墙爬数量' },
                                { name: 'boost', desc: 'boost类型 null | LH | LH2O | XLH2O' },
                                { name: 'level', desc: '体型 T0 | T1 | T2 越高体型越小' },
                            ],
                            functionName: 'repair.set'
                        },
                        {
                            title: '取消刷墙:',
                            describe: '例: repair.remove("W1N1","global")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'type', desc: '刷墙类型 global | globalrampart | globalwall | special(只刷旗子下的墙)' },
                            ],
                            functionName: 'repair.remove'
                        },
                        {
                            title: '扩张:',
                            describe: '例: expand.set("W1N1","W2N2","shard3",2,1)',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'destRoom', desc: '目标房间' },
                                { name: 'shard', desc: '目标房间所在shard' },
                                { name: 'num', desc: '援建/升级爬数量' },
                                { name: 'Cnum', desc: 'claim爬数量 默认1' },
                                { name: 'level(可选)', desc: '体型等级 T1-T3 (强化) | T4-T7 (带治疗)' },
                                { name: 'shardData(可选)', desc: '多次跨shard参数' },
                            ],
                            functionName: 'expand.set'
                        },
                        {
                            title: '取消扩张:',
                            describe: '例: expand.Cset("W1N1","W2N2","shard3")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'destRoom', desc: '目标房间' },
                                { name: 'shard', desc: '目标房间所在shard' },
                            ],
                            functionName: 'expand.remove'
                        },
                        {
                            title: '自适应冲级:',
                            describe: '例: upgrade.adaptive("W1N1",true)',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'option', desc: '是否启用自适应冲级 true | false' },
                            ],
                            functionName: 'upgrade.adaptive'
                        },
                        {
                            title: '急速冲级:',
                            describe: '例: upgrade.quick("W1N1",5,"GH2O")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'num', desc: '冲级爬数量' },
                                { name: 'boost', desc: 'boost类型 null | GH | GH2O | XGH2O' },
                            ],
                            functionName: 'upgrade.quick'
                        },
                        {
                            title: '取消急速冲级:',
                            describe: '例: upgrade.Cquick("W1N1")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                            ],
                            functionName: 'upgrade.Cquick'
                        },
                        {
                            title: '普通冲级:',
                            describe: '例: upgrade.normal("W1N1",2,"GH2O")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'num', desc: '冲级爬数量' },
                                { name: 'boost', desc: 'boost类型 null | GH | GH2O | XGH2O' },
                            ],
                            functionName: 'upgrade.normal'
                        },
                        {
                            title: '取消普通冲级:',
                            describe: '例: upgrade.Cnormal("W1N1")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                            ],
                            functionName: 'upgrade.Cnormal'
                        },
                        {
                            title: '签名:',
                            describe: '例: scout.sign("W1N1","W2N2","shard3","hello world")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'destRoom', desc: '目标房间' },
                                { name: 'shard', desc: '目标房间所在shard' },
                                { name: 'word', desc: '签名内容' },
                                { name: 'shardData(可选)', desc: '多次跨shard参数' },
                            ],
                            functionName: 'scout.sign'
                        },
                        {
                            title: '取消签名:',
                            describe: '例: scout.Csign("W1N1","W2N2","shard3")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'destRoom', desc: '目标房间' },
                                { name: 'shard', desc: '目标房间所在shard' },
                                { name: 'word', desc: '签名内容' },
                            ],
                            functionName: 'scout.Csign'
                        },
                        {
                            title: '指定资源搬运:',
                            describe: '例: carry.special("W1N1","energy","Flag1","Flag2",2,100000)',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'rType', desc: '搬运的资源类型' },
                                { name: 'src', desc: '起始点旗帜名称' },
                                { name: 'dest', desc: '终点旗帜名称' },
                                { name: 'num(可选)', desc: '搬运爬数量' },
                                { name: 'resourcenum(可选)', desc: '搬运的资源数量' },
                            ],
                            functionName: 'carry.special'
                        },
                        {
                            title: '搬运所有资源:',
                            describe: '例: carry.all("W1N1","Flag1","Flag2",2)',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'src', desc: '起始点旗帜名称' },
                                { name: 'dest', desc: '终点旗帜名称' },
                                { name: 'num(可选)', desc: '搬运爬数量' },
                            ],
                            functionName: 'carry.all'
                        },
                        {
                            title: '取消搬运资源:',
                            describe: '例: carry.cancel("W1N1")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                            ],
                            functionName: 'carry.cancel'
                        },
                        {
                            title: '跨shard搬运资源:',
                            describe: '例: carry.shard("W1N1","E3N5","shard3","power",3,1000,"T0")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'destRoom', desc: '目标房间名' },
                                { name: 'shard', desc: 'shard名' },
                                { name: 'rType', desc: '搬运的资源类型' },
                                { name: 'num', desc: '搬运爬数量' },
                                { name: 'interval', desc: '孵化间隔' },
                                { name: 'level', desc: '强化等级 T0 | T1 | T2 | T3' },
                                { name: 'shardData(可选)', desc: '多次跨shard参数' },
                            ],
                            functionName: 'carry.shard'
                        },
                        {
                            title: '取消跨shard搬运资源:',
                            describe: '例: carry.shard("W1N1","E3N5","shard3")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'destRoom', desc: '目标房间名' },
                                { name: 'shard', desc: 'shard名' },
                            ],
                            functionName: 'carry.Cshard'
                        },
                        {
                            title: '搬运指定房间内资源:',
                            describe: '例: carry.gleaner("W1N1","E3N5",3,500,1000,"T0")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'destRoom', desc: '目标房间名' },
                                { name: 'num', desc: '搬运爬数量' },
                                { name: 'suicide', desc: '在寿命低于此数值时自杀, 避免资源掉落浪费' },
                                { name: 'interval(可选)', desc: '孵化间隔' },
                                { name: 'level(可选)', desc: '强化等级 T0 | T1 | T2 | T3' },
                            ],
                            functionName: 'carry.gleaner'
                        },
                        {
                            title: '取消搬运指定房间内资源:',
                            describe: '例: carry.Cgleaner("W1N1")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                            ],
                            functionName: 'carry.Cgleaner'
                        },
                        {
                            title: '偷取别人外矿能量:',
                            describe: '例: carry.mine("W1N1","W1N2",1,"T0")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'destRoom', desc: '目标房间名' },
                                { name: 'num', desc: '搬运爬数量' },
                                { name: 'level(可选)', desc: '是否需要治疗 T0 | T1' },
                            ],
                            functionName: 'carry.mine'
                        },
                        {
                            title: '取消搬运指定房间内资源:',
                            describe: '例: carry.Cmine("W1N1")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                            ],
                            functionName: 'carry.Cmine'
                        },
                        {
                            title: '紧急援建:',
                            describe: '例: support.build("W1N1","W2N2","shard3",1,1000)',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'destRoom', desc: '目标房间' },
                                { name: 'shard', desc: '目标房间所在shard' },
                                { name: 'num', desc: '爬虫数量' },
                                { name: 'interval', desc: '出爬时间间隔' },
                                { name: 'defend(可选)', desc: '(boolean) 是否需要一定防御能力 默认 false' },
                                { name: 'shardData(可选)', desc: '多次跨shard参数' },
                            ],
                            functionName: 'support.build'
                        },
                        {
                            title: '取消紧急援建:',
                            describe: '例: support.Cbuild("W1N1","W2N2","shard3")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'destRoom', desc: '目标房间' },
                                { name: 'shard', desc: '目标房间所在shard' },
                            ],
                            functionName: 'support.Cbuild'
                        },
                        {
                            title: '紧急升级:',
                            describe: '例: support.upgrade("W1N1","W2N2","shard3",1,1000)',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'destRoom', desc: '目标房间' },
                                { name: 'shard', desc: '目标房间所在shard' },
                                { name: 'num', desc: '爬虫数量' },
                                { name: 'interval', desc: '出爬时间间隔' },
                                { name: 'defend(可选)', desc: '(boolean) 是否需要一定防御能力 默认 false' },
                                { name: 'shardData(可选)', desc: '多次跨shard参数' },
                            ],
                            functionName: 'support.upgrade'
                        },
                        {
                            title: '取消紧急升级:',
                            describe: '例: support.Cupgrade("W1N1","W2N2","shard3")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'destRoom', desc: '目标房间' },
                                { name: 'shard', desc: '目标房间所在shard' },
                            ],
                            functionName: 'support.Cupgrade'
                        },
                        {
                            title: '紧急修墙:',
                            describe: '例: support.repair("W1N1","W2N2","shard3",1,1000)',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'destRoom', desc: '目标房间' },
                                { name: 'shard', desc: '目标房间所在shard' },
                                { name: 'num', desc: '爬虫数量' },
                                { name: 'interval', desc: '出爬时间间隔' },
                                { name: 'defend(可选)', desc: '(boolean) 是否需要一定防御能力 默认 false' },
                                { name: 'shardData(可选)', desc: '多次跨shard参数' },
                            ],
                            functionName: 'support.repair'
                        },
                        {
                            title: '取消紧急修墙:',
                            describe: '例: support.Crepair("W1N1","W2N2","shard3")',
                            params: [
                                { name: 'roomName', desc: '房间名' },
                                { name: 'destRoom', desc: '目标房间' },
                                { name: 'shard', desc: '目标房间所在shard' },
                            ],
                            functionName: 'support.Crepair'
                        },
                    ]
                }, {
                    name: '战争行为',
                    describe: '战争相关的命令',
                    api: [
                        {
                            title: '一体机:',
                            describe: '例: war.aio("W1N1","W1N12","shard3",1,1000,true,"T1")',
                            params: [
                                { name: 'roomName', desc: '所在房间' },
                                { name: 'destRoom', desc: '目标房间' },
                                { name: 'shard', desc: '目标房间所在shard' },
                                { name: 'num', desc: '爬虫数量' },
                                { name: 'interval', desc: '出爬时间间隔' },
                                { name: 'boost', desc: '是否boost' },
                                { name: 'bodyLevel', desc: 'T0 | T1 | T2 越高防御力越弱,攻击力越强' },
                                { name: 'shardData(可选)', desc: '多次跨shard参数' },
                            ],
                            functionName: 'war.aio'
                        },
                        {
                            title: '取消一体机:',
                            describe: '例: war.Caio("W1N1","W1N12","shard3")',
                            params: [
                                { name: 'roomName', desc: '目标房间' },
                                { name: 'destRoom', desc: '目标房间' },
                                { name: 'shard', desc: '目标房间所在shard' },
                            ],
                            functionName: 'war.Caio'
                        },
                        {
                            title: '双人小队:',
                            describe: '例: war.double("W1N1","W1N12","shard3","attack",1,1000)',
                            params: [
                                { name: 'roomName', desc: '目标房间' },
                                { name: 'destRoom', desc: '目标房间' },
                                { name: 'shard', desc: '目标房间所在shard' },
                                { name: 'type', desc: '双人小队类型: attack:红球 |dismantle:黄球' },
                                { name: 'num', desc: '爬虫数量' },
                                { name: 'interval', desc: '出爬时间间隔' },
                                { name: 'shardData(可选)', desc: '多次跨shard参数' },
                            ],
                            functionName: 'war.double'
                        },
                        {
                            title: '取消双人小队:',
                            describe: '例: war.Cdouble("W1N1","W1N12","shard3","attack")',
                            params: [
                                { name: 'roomName', desc: '目标房间' },
                                { name: 'destRoom', desc: '目标房间' },
                                { name: 'shard', desc: '目标房间所在shard' },
                                { name: 'type', desc: '双人小队类型: attack:红球 |dismantle:黄球' },
                            ],
                            functionName: 'war.Cdouble'
                        },
                        {
                            title: '四人小队:',
                            describe: '例: war.squad("W1N1","W1N12","shard3","D",1000)',
                            params: [
                                { name: 'roomName', desc: '目标房间' },
                                { name: 'destRoom', desc: '目标房间' },
                                { name: 'shard', desc: '目标房间所在shard' },
                                { name: 'type', desc: '四人小队类型: D:黄|A:红|R:蓝|DR|DA|RA|Aio:一体机' },
                                { name: 'interval', desc: '出爬时间间隔' },
                                { name: 'shardData(可选)', desc: '多次跨shard参数' },
                            ],
                            functionName: 'war.squad'
                        },
                        {
                            title: '取消四人小队:',
                            describe: '例: war.Csquad("W1N1","W1N12","shard3","D")',
                            params: [
                                { name: 'roomName', desc: '目标房间' },
                                { name: 'destRoom', desc: '目标房间' },
                                { name: 'shard', desc: '目标房间所在shard' },
                                { name: 'type', desc: '四人小队类型: D:黄|A:红|R:蓝|DR|DA|RA|Aio:一体机' },
                            ],
                            functionName: 'war.Csquad'
                        },
                        {
                            title: '拆家大黄:',
                            describe: '例: war.dismantle("W1N1","W1N12","shard3",1,1000,true)',
                            params: [
                                { name: 'roomName', desc: '目标房间' },
                                { name: 'destRoom', desc: '目标房间' },
                                { name: 'shard', desc: '目标房间所在shard' },
                                { name: 'num', desc: '爬虫数量' },
                                { name: 'interval', desc: '出爬时间间隔' },
                                { name: 'boost', desc: '是否boost' },
                                { name: 'shardData(可选)', desc: '多次跨shard参数' },
                            ],
                            functionName: 'war.dismantle'
                        },
                        {
                            title: '取消拆家大黄:',
                            describe: '例: war.Cdismantle("W1N1","W1N12","shard3")',
                            params: [
                                { name: 'roomName', desc: '目标房间' },
                                { name: 'destRoom', desc: '目标房间' },
                                { name: 'shard', desc: '目标房间所在shard' },
                            ],
                            functionName: 'war.Cdismantle'
                        },
                        {
                            title: '攻击控制器:',
                            describe: '例: war.control("W1N1","W1N12","shard3",1000)',
                            params: [
                                { name: 'roomName', desc: '目标房间' },
                                { name: 'destRoom', desc: '目标房间' },
                                { name: 'shard', desc: '目标房间所在shard' },
                                { name: 'interval', desc: '出爬时间间隔' },
                                { name: 'shardData(可选)', desc: '多次跨shard参数' },
                            ],
                            functionName: 'war.control'
                        },
                        {
                            title: '取消攻击控制器:',
                            describe: '例: war.Ccontrol("W1N1","W1N12","shard3")',
                            params: [
                                { name: 'roomName', desc: '目标房间' },
                                { name: 'destRoom', desc: '目标房间' },
                                { name: 'shard', desc: '目标房间所在shard' },
                            ],
                            functionName: 'war.Ccontrol'
                        },
                        {
                            title: '紧急支援:',
                            describe: '例: war.support("W1N1","W1N12","shard3","aio",1,1000,true)',
                            params: [
                                { name: 'roomName', desc: '目标房间' },
                                { name: 'destRoom', desc: '目标房间' },
                                { name: 'shard', desc: '目标房间所在shard' },
                                { name: 'type', desc: '紧急支援类型: double:双人小队 |aio:一体机' },
                                { name: 'num', desc: '爬虫数量' },
                                { name: 'interval', desc: '出爬时间间隔' },
                                { name: 'boost', desc: '是否boost(只会aio有效)' },
                                { name: 'shardData(可选)', desc: '多次跨shard参数' },
                            ],
                            functionName: 'war.support'
                        },
                        {
                            title: '取消紧急支援:',
                            describe: '例: war.Csupport("W1N1","W1N12","shard3","double")',
                            params: [
                                { name: 'roomName', desc: '目标房间' },
                                { name: 'destRoom', desc: '目标房间' },
                                { name: 'shard', desc: '目标房间所在shard' },
                                { name: 'type', desc: '紧急支援类型: double:双人小队 |aio:一体机' },
                            ],
                            functionName: 'war.Csupport'
                        },
                        {
                            title: '踩工地:',
                            describe: '例: war.site("W1N1","W1N12","shard3",1,1000,true,"T1")',
                            params: [
                                { name: 'roomName', desc: '所在房间' },
                                { name: 'destRoom', desc: '目标房间' },
                                { name: 'shard', desc: '目标房间所在shard' },
                                { name: 'num', desc: '爬虫数量' },
                                { name: 'interval', desc: '出爬时间间隔' },
                                { name: 'boost', desc: '是否boost' },
                                { name: 'bodyLevel', desc: 'T0 | T1 | T2 越高防御力越弱,攻击力越强' },
                                { name: 'shardData(可选)', desc: '多次跨shard参数' },
                            ],
                            functionName: 'war.site'
                        },
                        {
                            title: '取消踩工地:',
                            describe: '例: war.Csite("W1N1","W1N12","shard3")',
                            params: [
                                { name: 'roomName', desc: '目标房间' },
                                { name: 'destRoom', desc: '目标房间' },
                                { name: 'shard', desc: '目标房间所在shard' },
                            ],
                            functionName: 'war.Csite'
                        },
                    ]
                })
            ].join('\n');
        }
    },
    // stat
    {
        alias: 'manual_stat',
        exec: function () {
            return [
                ...projectTitle.map(line => colorful(line, 'blue', true)),
                createHelp({
                    name: '统计相关',
                    describe: '全局资源、储量统计',
                    api: [
                        {
                            title: '全局资源统计:',
                            describe: '全局资源数量统计',
                            functionName: 'resource.all'
                        },
                        {
                            title: '房间资源统计:',
                            describe: '例: resource.room("W1N1")',
                            params: [
                                { name: 'roomName', desc: '房间' },
                            ],
                            functionName: 'resource.room'
                        },
                        {
                            title: '全局lab合成统计:',
                            describe: '全局lab合成统计',
                            functionName: 'resource.lab'
                        },
                        {
                            title: '商品资源名称打印:',
                            describe: '商品资源名称打印',
                            functionName: 'resource.com'
                        },
                        {
                            title: '全局储量统计:',
                            describe: '全局储量统计',
                            functionName: 'store.all'
                        },
                        {
                            title: '房间储量统计:',
                            describe: '例: store.room("W1N1")',
                            params: [
                                { name: 'roomName', desc: '房间' },
                            ],
                            functionName: 'store.room'
                        },
                    ]
                })
            ].join('\n');
        }
    },
    {
        alias: 'manual_flag',
        exec: function () {
            return [
                ...projectTitle.map(line => colorful(line, 'blue', true)),
                '这里列出一些可能用到的旗帜及其作用 统一规定xx为任何字符串 [xx]为房间名',
                '旗帜名: [xx]/repair 房间内所有防御塔参与维修',
                '旗帜名: [xx]/stop 房间内所有防御塔停止攻击',
                '旗帜名: dismantle_xx 大黄拆迁指定旗帜下建筑',
                '旗帜名: aio_xx 一体机拆迁指定旗帜下建筑',
                '旗帜名: squad_attack_xx 四人小队攻击指定旗帜下建筑',
                '旗帜名: double_attack_xx attack双人小队拆迁指定旗帜下建筑',
                '旗帜名: double_dismantle_xx dismantle双人小队拆迁指定旗帜下建筑',
                '旗帜名: support_aio_xx 紧急支援一体机前往指定旗帜',
                '旗帜名: support_double_xx 紧急支援双人小队拆迁指定旗帜下建筑',
                '旗帜名: reapair_xx special维修爬维修指定旗帜下墙体',
                '旗帜名: withdraw_xx紧急援助爬从该旗帜下的建筑提取能量',
                '旗帜名: [紧急援助爬所属房间]/HB/harvest 紧急援助爬从该旗帜下的房间的矿点采集能量',
                '旗帜名: LayoutVisualDev 插在任意房间可以显示dev自动布局',
                '旗帜名: TowerVisualAttack 插在距离自己8级房最近房间或有视野房间 显示该房间防御塔伤害信息',
                '旗帜名: TowerVisualHeal 插在距离自己8级房最近房间或有视野房间 显示该房间防御塔治疗信息',
                '旗帜名: TowerVisualRepair 插在距离自己8级房最近房间或有视野房间 显示该房间防御塔维修信息',
            ].join('\n');
        }
    },
];
/**
 * 帮助文档中的标题
 */
const projectTitle = [
// String.raw`    ███████╗██╗   ██╗██████╗ ███████╗██████╗ ██████╗ ██╗████████╗ ██████╗██╗  ██╗`,
// String.raw`    ██╔════╝██║   ██║██╔══██╗██╔════╝██╔══██╗██╔══██╗██║╚══██╔══╝██╔════╝██║  ██║`,
// String.raw`    ███████╗██║   ██║██████╔╝█████╗  ██████╔╝██████╔╝██║   ██║   ██║     ███████║`,
// String.raw`    ╚════██║██║   ██║██╔═══╝ ██╔══╝  ██╔══██╗██╔══██╗██║   ██║   ██║     ██╔══██║`,
// String.raw`    ███████║╚██████╔╝██║     ███████╗██║  ██║██████╔╝██║   ██║   ╚██████╗██║  ██`,
// String.raw`    ╚══════╝ ╚═════╝ ╚═╝     ╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝   ╚═╝    ╚═════╝╚═╝  ╚═╝`,
// String.raw`                             ██████╗  ██████╗ ████████╗`,
// String.raw`                             ██╔══██╗██╔═══██╗╚══██╔══╝`,
// String.raw`                             ██████╔╝██║   ██║   ██║   `,
// String.raw`                             ██╔══██╗██║   ██║   ██║   `,
// String.raw`                             ██████╔╝╚██████╔╝   ██║   `,
// String.raw`                             ╚═════╝  ╚═════╝    ╚═╝   `,
];

// 挂载全局拓展
function mountHelp () {
    // 挂载有别名的操作
    extension.map(item => {
        Object.defineProperty(global, item.alias, { get: item.exec });
    });
    // 挂载没有别名的操作
    _.assign(global, extension);
}

/*
creep对穿+跨房间寻路+寻路缓存
跑的比香港记者还快从你做起
应用此模块会导致creep.moveTo可选参数中这些项失效：reusePath、serializeMemory、noPathFinding、ignore、avoid、serialize
保留creep.moveTo中其他全部可选参数如visualizePathStyle、range、ignoreDestructibleStructures、ignoreCreeps、ignoreRoad等
新增creep.moveTo中可选参数ignoreSwamps，会无视swamp与road的移动力损耗差异，一律与plain相同处理，用于方便pc和眼，默认false
例：creep.moveTo(controller, {ignoreSwamps: true});
新增creep.moveTo中可选参数bypassHostileCreeps，被creep挡路时若此项为true则绕过别人的creep，默认为true，设为false用于近战攻击
例：creep.moveTo(controller, {bypassHostileCreeps: false});
新增creep.moveTo中可选参数bypassRange，被creep挡路准备绕路时的绕路半径，默认为5
例：creep.moveTo(controller, {bypassRange: 10});
新增creep.moveTo中可选参数noPathDelay，寻得的路是不完全路径时的再次寻路延迟，默认为10
例：creep.moveTo(controller, {noPathDelay: 5});
新增返回值ERR_INVALID_ARGS，表示range或者bypassRange类型错误

遇到己方creep自动进行对穿，遇到自己设置了不想被对穿的creep（或bypassHostileCreeps设为true时遇到他人creep）会自动绕过
会将新手墙和部署中的invaderCore处理为无法通过
会绕过非终点的portal，不影响creep.moveTo(portal)
不使用Memory及global，不会因此干扰外部代码
不会在Creep.prototype、PowerCreep.prototype上增加官方未有的键值，不会因此干扰外部代码
本模块不可用于sim，在sim会因为房间名格式不对返回ERR_INVALID_TARGET
模块参数见代码头部，模块接口见代码尾部
版本号规则：alpha test = 0.1.x，beta test = 0.9.x，publish >= 1.0.0

author: Scorpior
debug helpers: fangxm, czc
inspired by: Yuandiaodiaodiao
date: 2020/3/30
version: 0.9.4(beta test)

Usage:
module :main

require('超级移动优化');
module.exports.loop=function() {

    //your codes go here

}

changelog:
0.1.0:  maybe not runnable
0.1.1： still maybe not runnable，修了一些typo，完成正向移动，修改isObstacleStructure
0.1.2： maybe runnable，some bugs are fixed
0.1.3:  修正工地位置寻路错误，调整打印格式
0.1.4:  补充pc对穿，打印中增加cache hits统计
0.9.0:  启用自动清理缓存，保留ignoreCreeps参数，调整对穿顺序+增加在storage附近检查对穿，
        正确识别敌对rampart，正确查询带range路径，打印中增加对穿频率统计
0.9.1:  增加正常逻辑开销统计，修改cache搜索开销统计为cache miss开销统计，绕路bugfix，跨房检测bugfix，other bugfix
0.9.2:  修改缓存策略减少查找耗时增加命中率，增加核心区对穿次数统计，对穿bugfix，other bugfix
0.9.3： 取消路径反向复用避免偶发的复用非最优路径的情况，改进识别被新手墙封闭的房间，增加avoidRooms设置，
        增加远距离跨房寻路成功率，房间出口处对穿bug fix
0.9.4:  优化路径复用避免偶发的复用非最优路径的情况，删除运行时参数中neutralCostMatrixClearDelay，
        自动根据挡路建筑情况设置中立房间costMatrix过期时间，增加ob寻路（检查房间是否可走），
        提供deletePathInRoom接口（使用方式见下方ps），print()中增加平均每次查找缓存时检查的路径数量统计，
        findRoute遇到过道新手墙时bugfix，偏移路径bugfix
0.9.5： TODO：ignoreSwamp避开路，提供deletePathFromRoom、deletePathToRoom接口，增加自动visual，betterMove


ps:
1.默认ignoreCreeps为true，主动设置ignoreCreeps为false会在撞到creep时重新寻路
2.对于不想被对穿的creep（比如没有脚的中央搬运工）, 设置memory：
creep.memory.dontPullMe = true;
3.修路后希望手动更新房间内路径，可执行如下代码：
require('超级移动优化').deletePathInRoom(roomName);
4.战斗中遇到敌方pc不断产生新rampart挡路的情况，目前是撞上建筑物才重新寻路（原版moveTo撞上也继续撞），如果觉得需要手动提前激活重新寻路则联系我讨论
5.在控制台输入require('超级移动优化').print()获取性能信息，鼓励发给作者用于优化
*/
// 运行时参数 
let pathClearDelay = 3000; // 清理相应时间内都未被再次使用的路径，同时清理死亡creep的缓存，设为undefined表示不清除缓存
let hostileCostMatrixClearDelay = 500; // 自动清理相应时间前创建的其他玩家房间的costMatrix
let coreLayoutRange = 3; // 核心布局半径，在离storage这个范围内频繁检查对穿（减少堵路的等待
let avoidRooms = Memory.bypassRooms ? Memory.bypassRooms : []; // 永不踏入这些房间 ,'E8N19','E8N18','W19N13'
/** @type {{id:string, roomName:string, taskQueue:{path:MyPath, idx:number, roomName:string}[]}[]} */
let observers = []; // 如果想用ob寻路，把ob的id放这里
/***************************************
 *  局部缓存
 */
/** @type {{ [time: number]:{path:MyPath, idx:number, roomName:string}[] }} */
let obTimer = {}; // 【未启用】用于登记ob调用，在相应的tick查看房间对象
let obTick = Game.time;
/** @type {Paths} */
let globalPathCache = {}; // 缓存path
/** @type {MoveTimer} */
let pathCacheTimer = {}; // 用于记录path被使用的时间，清理长期未被使用的path
/** @type {CreepPaths} */
let creepPathCache = {}; // 缓存每个creep使用path的情况
let creepMoveCache = {}; // 缓存每个creep最后一次移动的tick
let emptyCostMatrix = new PathFinder.CostMatrix;
/** @type {CMs} */
let costMatrixCache = {}; // true存ignoreDestructibleStructures==true的，false同理
/** @type {{ [time: number]:{roomName:string, avoids:string[]}[] }} */
let costMatrixCacheTimer = {}; // 用于记录costMatrix的创建时间，清理过期costMatrix
let autoClearTick = Game.time; // 用于避免重复清理缓存
const obstacles = new Set(OBSTACLE_OBJECT_TYPES);
const originMove = Creep.prototype.move;
const originMoveTo = Creep.prototype.moveTo;
RoomPosition.prototype.findClosestByPath;
// 统计变量
let startTime;
let endTime;
let startCacheSearch;
let analyzeCPU = {
    move: { sum: 0, calls: 0 },
    moveTo: { sum: 0, calls: 0 },
    findClosestByPath: { sum: 0, calls: 0 }
};
let cacheHitCost = 0;
let cacheMissCost = 0;
let unWalkableCCost = 255;
/***************************************
 *  util functions
 */
let reg1 = /^([WE])([0-9]+)([NS])([0-9]+)$/; // parse得到['E28N7','E','28','N','7']
/**
 *  统一到大地图坐标，平均单次开销0.00005
 * @param {RoomPosition} pos
 */
function formalize(pos) {
    let splited = reg1.exec(pos.roomName);
    if (splited && splited.length == 5) {
        return {
            x: (splited[1] === 'W' ? -splited[2] : +splited[2] + 1) * 50 + pos.x,
            y: (splited[3] === 'N' ? -splited[4] : +splited[4] + 1) * 50 + pos.y
        };
    } // else 房间名字不是正确格式
    return {};
}
/**
 *  阉割版isEqualTo，提速
 * @param {RoomPosition} pos1
 * @param {RoomPosition} pos2
 */
function isEqual(pos1, pos2) {
    return pos1.x == pos2.x && pos1.y == pos2.y && pos1.roomName == pos2.roomName;
}
/**
 *  兼容房间边界
 *  参数具有x和y属性就行
 * @param {RoomPosition} pos1
 * @param {RoomPosition} pos2
 */
function isNear(pos1, pos2) {
    if (pos1.roomName == pos2.roomName) { // undefined == undefined 也成立
        return -1 <= pos1.x - pos2.x && pos1.x - pos2.x <= 1 && -1 <= pos1.y - pos2.y && pos1.y - pos2.y <= 1;
    }
    else if (pos1.roomName && pos2.roomName) { // 是完整的RoomPosition
        if (pos1.x + pos2.x != 49 && pos1.y + pos2.y != 49)
            return false; // 肯定不是两个边界点, 0.00003 cpu
        // start
        let splited1 = reg1.exec(pos1.roomName);
        let splited2 = reg1.exec(pos2.roomName);
        if (splited1 && splited1.length == 5 && splited2 && splited2.length == 5) {
            // 统一到大地图坐标
            let formalizedEW = (splited1[1] === 'W' ? -splited1[2] : +splited1[2] + 1) * 50 + pos1.x - (splited2[1] === 'W' ? -splited2[2] : +splited2[2] + 1) * 50 - pos2.x;
            let formalizedNS = (splited1[3] === 'N' ? -splited1[4] : +splited1[4] + 1) * 50 + pos1.y - (splited2[3] === 'N' ? -splited2[4] : +splited2[4] + 1) * 50 - pos2.y;
            return -1 <= formalizedEW && formalizedEW <= 1 && -1 <= formalizedNS && formalizedNS <= 1;
        }
        // end - start = 0.00077 cpu
    }
    return false;
}
/**
 * @param {RoomPosition} pos1
 * @param {RoomPosition} pos2
 */
function inRange(pos1, pos2, range) {
    if (pos1.roomName == pos2.roomName) {
        return -range <= pos1.x - pos2.x && pos1.x - pos2.x <= range && -range <= pos1.y - pos2.y && pos1.y - pos2.y <= range;
    }
    else {
        pos1 = formalize(pos1);
        pos2 = formalize(pos2);
        return pos1.x && pos2.x && inRange(pos1, pos2, range);
    }
}
/**
 *  fromPos和toPos是pathFinder寻出的路径上的，只可能是同房相邻点或者跨房边界点
 * @param {RoomPosition} fromPos
 * @param {RoomPosition} toPos
 */
function getDirection(fromPos, toPos) {
    if (fromPos.roomName == toPos.roomName) {
        if (toPos.x > fromPos.x) { // 下一步在右边
            if (toPos.y > fromPos.y) { // 下一步在下面
                return BOTTOM_RIGHT;
            }
            else if (toPos.y == fromPos.y) { // 下一步在正右
                return RIGHT;
            }
            return TOP_RIGHT; // 下一步在上面
        }
        else if (toPos.x == fromPos.x) { // 横向相等
            if (toPos.y > fromPos.y) { // 下一步在下面
                return BOTTOM;
            }
            else if (toPos.y < fromPos.y) {
                return TOP;
            }
        }
        else { // 下一步在左边
            if (toPos.y > fromPos.y) { // 下一步在下面
                return BOTTOM_LEFT;
            }
            else if (toPos.y == fromPos.y) {
                return LEFT;
            }
            return TOP_LEFT;
        }
    }
    else { // 房间边界点
        if (fromPos.x == 0 || fromPos.x == 49) { // 左右相邻的房间，只需上下移动（左右边界会自动弹过去）
            if (toPos.y > fromPos.y) { // 下一步在下面
                return BOTTOM;
            }
            else if (toPos.y < fromPos.y) { // 下一步在上
                return TOP;
            } // else 正左正右
            return fromPos.x ? RIGHT : LEFT;
        }
        else if (fromPos.y == 0 || fromPos.y == 49) { // 上下相邻的房间，只需左右移动（上下边界会自动弹过去）
            if (toPos.x > fromPos.x) { // 下一步在右边
                return RIGHT;
            }
            else if (toPos.x < fromPos.x) {
                return LEFT;
            } // else 正上正下
            return fromPos.y ? BOTTOM : TOP;
        }
    }
}
let isHighWay = (roomName) => {
        // E0 || E10 || E1S0 || [E10S0|E1S10] || [E10S10] 比正则再除快
        return roomName[1] == 0 || roomName[2] == 0 || roomName[3] == 0 || roomName[4] == 0 || roomName[5] == 0;
    };
/**
 *  缓存的路径和当前moveTo参数相同
 * @param {MyPath} path
 * @param {*} ops
 */
function isSameOps(path, ops) {
    return path.ignoreRoads == !!ops.ignoreRoads &&
        path.ignoreSwamps == !!ops.ignoreSwamps &&
        path.ignoreStructures == !!ops.ignoreDestructibleStructures;
}
function hasActiveBodypart(body, type) {
    if (!body) {
        return true;
    }
    for (var i = body.length - 1; i >= 0; i--) {
        if (body[i].hits <= 0)
            break;
        if (body[i].type === type)
            return true;
    }
    return false;
}
function isClosedRampart(structure) {
    return structure.structureType == STRUCTURE_RAMPART && !structure.my && !structure.isPublic;
}
/**
 *  查看是否有挡路建筑
 * @param {Room} room
 * @param {RoomPosition} pos
 * @param {boolean} ignoreStructures
 */
function isObstacleStructure(room, pos, ignoreStructures) {
    let consSite = room.lookForAt(LOOK_CONSTRUCTION_SITES, pos);
    if (0 in consSite && consSite[0].my && obstacles.has(consSite[0].structureType)) { // 工地会挡路
        return true;
    }
    let struct = room.lookForAt(LOOK_STRUCTURES, pos);
    for (let s of struct) {
        if (!s.hits || (s instanceof StructureInvaderCore && s.ticksToDeploy)) { // 是新手墙或者无敌中的invaderCore
            return true;
        }
        else if (!ignoreStructures && (obstacles.has(s.structureType) || isClosedRampart(s))) {
            return true;
        }
    }
    return false;
    // let possibleStructures = room.lookForAt(LOOK_STRUCTURES, pos);  // room.lookForAt比pos.lookFor快
    // 万一有人把路修在extension上，导致需要每个建筑都判断，最多重叠3个建筑（rap+road+其他）
    // return obstacles.has(possibleStructures[0]) || obstacles.has(possibleStructures[1]) || obstacles.has(possibleStructures[2]);    // 条件判断平均每次0.00013cpu
}
/**
 *  登记ob需求
 * @param {MyPath} path
 * @param {number} idx
 */
function addObTask(path, idx) {
    let roomName = path.posArray[idx].roomName;
    //console.log('准备ob ' + roomName);
    for (let obData of observers) {
        if (Game.map.getRoomLinearDistance(obData.roomName, roomName) <= 10) {
            obData.taskQueue.push({ path: path, idx: idx, roomName: roomName });
            break;
        }
    }
}
/**
 *  尝试用ob检查路径
 */
function doObTask() {
    for (let obData of observers) { // 遍历所有ob
        let queue = obData.taskQueue;
        while (queue.length) { // 没有task就pass
            let task = queue[queue.length - 1];
            let roomName = task.roomName;
            if (roomName in costMatrixCache) { // 有过视野不用再ob
                if (!task.path.directionArray[task.idx]) {
                    //console.log(roomName + ' 有视野了无需ob');
                    checkRoom({ name: roomName }, task.path, task.idx - 1);
                }
                queue.pop();
                continue;
            }
            /** @type {StructureObserver} */
            let ob = Game.getObjectById(obData.id);
            if (ob) {
                //console.log('ob ' + roomName);
                ob.observeRoom(roomName);
                if (!(Game.time + 1 in obTimer)) {
                    obTimer[Game.time + 1] = [];
                }
                obTimer[Game.time + 1].push({ path: task.path, idx: task.idx, roomName: roomName }); // idx位置无direction
            }
            else {
                observers.splice(observers.indexOf(obData), 1);
            }
            break;
        }
    }
}
/**
 *  查看ob得到的房间
 */
function checkObResult() {
    for (let tick in obTimer) {
        if (+tick < Game.time) {
            delete obTimer[tick];
            continue; // 后面可能还有要检查的
        }
        else if (+tick == Game.time) {
            for (let result of obTimer[tick]) {
                if (result.roomName in Game.rooms) {
                    //console.log('ob得到 ' + result.roomName);
                    checkRoom(Game.rooms[result.roomName], result.path, result.idx - 1); // checkRoom要传有direction的idx
                }
            }
            delete obTimer[tick];
        } // else 没有要检查的
        break; // 检查完了或者没有要检查的
    }
}
/**
 *  为房间保存costMatrix，ignoreDestructibleStructures这个参数的两种情况各需要一个costMatrix
 *  设置costMatrix缓存的过期时间
 * @param {Room} room
 * @param {RoomPosition} pos
 */
function generateCostMatrix(room, pos) {
    let noStructureCostMat = new PathFinder.CostMatrix; // 不考虑可破坏的建筑，但是要考虑墙上资源点和无敌的3种建筑，可能还有其他不能走的？
    let structureCostMat = new PathFinder.CostMatrix; // 在noStructrue的基础上加上所有不可行走的建筑
    let totalStructures = room.find(FIND_STRUCTURES);
    let ignoreRoadPos = [].concat(room.find(FIND_SOURCES), room.find(FIND_MINERALS), room.find(FIND_DEPOSITS)); // 修路也没用的墙点
    let x, y, noviceWall, deployingCore, centralPortal;
    let clearDelay = Infinity;
    for (let object of ignoreRoadPos) {
        x = object.pos.x;
        y = object.pos.y;
        noStructureCostMat.set(x, y, unWalkableCCost);
    }
    if (room.controller && (room.controller.my || room.controller.safeMode)) { // 自己的工地不能踩
        for (let consSite of room.find(FIND_CONSTRUCTION_SITES)) {
            if (obstacles.has(consSite.structureType)) {
                x = consSite.pos.x;
                y = consSite.pos.y;
                noStructureCostMat.set(x, y, unWalkableCCost);
                structureCostMat.set(x, y, unWalkableCCost);
            }
        }
    }
    for (let s of totalStructures) {
        if (s.structureType == STRUCTURE_INVADER_CORE) { // 第1种可能无敌的建筑
            if (s.ticksToDeploy) {
                deployingCore = true;
                clearDelay = clearDelay > s.ticksToDeploy ? s.ticksToDeploy : clearDelay;
                noStructureCostMat.set(s.pos.x, s.pos.y, unWalkableCCost);
            }
            structureCostMat.set(s.pos.x, s.pos.y, unWalkableCCost);
        }
        else if (s.structureType == STRUCTURE_PORTAL) { // 第2种无敌建筑
            if (!isHighWay(room.name)) {
                centralPortal = true;
                clearDelay = clearDelay > s.ticksToDecay ? s.ticksToDecay : clearDelay;
            }
            x = s.pos.x;
            y = s.pos.y;
            structureCostMat.set(x, y, unWalkableCCost);
            noStructureCostMat.set(x, y, unWalkableCCost);
        }
        else if (s.structureType == STRUCTURE_WALL) { // 第3种可能无敌的建筑
            if (!s.hits) {
                noviceWall = true;
                noStructureCostMat.set(s.pos.x, s.pos.y, unWalkableCCost);
            }
            structureCostMat.set(s.pos.x, s.pos.y, unWalkableCCost);
        }
        else if (s.structureType == STRUCTURE_ROAD) { // 路的移动力损耗是1，此处设置能寻到墙上的路
            x = s.pos.x;
            y = s.pos.y;
            if (noStructureCostMat.get(x, y) == 0) { // 不是在3种无敌建筑或墙中资源上
                noStructureCostMat.set(x, y, 1);
                if (structureCostMat.get(x, y) == 0) { // 不是在不可行走的建筑上
                    structureCostMat.set(x, y, 1);
                }
            }
        }
        else if (obstacles.has(s.structureType) || isClosedRampart(s)) { // HELP：有没有遗漏其他应该设置 noStructureCostMat 的点
            structureCostMat.set(s.pos.x, s.pos.y, unWalkableCCost);
        }
    }
    costMatrixCache[room.name] = {
        roomName: room.name,
        true: noStructureCostMat,
        false: structureCostMat // 对应 ignoreDestructibleStructures = false
    };
    let avoids = [];
    if (room.controller && room.controller.owner && !room.controller.my && hostileCostMatrixClearDelay) { // 他人房间，删除costMat才能更新被拆的建筑位置
        if (!(Game.time + hostileCostMatrixClearDelay in costMatrixCacheTimer)) {
            costMatrixCacheTimer[Game.time + hostileCostMatrixClearDelay] = [];
        }
        costMatrixCacheTimer[Game.time + hostileCostMatrixClearDelay].push({
            roomName: room.name,
            avoids: avoids
        }); // 记录清理时间
    }
    else if (noviceWall || deployingCore || centralPortal) { // 如果遇到可能消失的挡路建筑，这3种情况下clearDelay才可能被赋值为非Infinity
        if (noviceWall) { // 如果看见新手墙
            let neighbors = Game.map.describeExits(room.name);
            for (let direction in neighbors) {
                let status = Game.map.getRoomStatus(neighbors[direction]);
                if (status.status == 'closed') {
                    avoidRooms[neighbors[direction]] = 1;
                }
                else if (status.status != 'normal' && status.timestamp != null) {
                    let estimateTickToChange = (status.timestamp - new Date().getTime()) / 10000; // 10s per tick
                    clearDelay = clearDelay > estimateTickToChange ? Math.ceil(estimateTickToChange) : clearDelay;
                }
            }
            if (pos) { // 如果知道自己的pos
                for (let direction in neighbors) {
                    if (!(neighbors[direction] in avoidRooms)) {
                        let exits = room.find(+direction);
                        if (PathFinder.search(pos, exits, { maxRooms: 1, roomCallback: () => noStructureCostMat }).incomplete) { // 此路不通
                            avoidRooms[neighbors[direction]] = 1;
                            avoids.push(neighbors[direction]);
                        }
                    }
                }
            }
        }
        //console.log(room.name + ' costMat 设置清理 ' + clearDelay);
        if (!(Game.time + clearDelay in costMatrixCacheTimer)) {
            costMatrixCacheTimer[Game.time + clearDelay] = [];
        }
        costMatrixCacheTimer[Game.time + clearDelay].push({
            roomName: room.name,
            avoids: avoids // 因新手墙导致的avoidRooms需要更新
        }); // 记录清理时间
    }
    //console.log('生成costMat ' + room.name);
}
/**
 *  把路径上有视野的位置的正向移动方向拿到，只有在找新路时调用，找新路时会把有视野房间都缓存进costMatrixCache
 * @param {MyPath} path
 */
function generateDirectionArray(path) {
    let posArray = path.posArray;
    let directionArray = new Array(posArray.length);
    let incomplete = 0;
    for (let idx = 1; idx in posArray; idx++) {
        if (posArray[idx - 1].roomName in costMatrixCache) { // 有costMat，是准确路径，否则需要在有视野时checkRoom()
            directionArray[idx] = getDirection(posArray[idx - 1], posArray[idx]);
        }
        else if (!incomplete) { // 记录第一个缺失准确路径的位置
            incomplete = idx;
        }
    }
    if (observers.length && incomplete) {
        addObTask(path, incomplete); // 这格没有direction
    }
    path.directionArray = directionArray;
}
/**
 *  第一次拿到该room视野，startIdx是新房中唯一有direction的位置
 * @param {Room} room
 * @param {MyPath} path
 * @param {number} startIdx
 */
function checkRoom(room, path, startIdx) {
    if (!(room.name in costMatrixCache)) {
        generateCostMatrix(room, path.posArray[startIdx]);
    }
    let thisRoomName = room.name;
    /** @type {CostMatrix} */
    let costMat = costMatrixCache[thisRoomName][String(path.ignoreStructures)];
    let posArray = path.posArray;
    let directionArray = path.directionArray;
    let i;
    for (i = startIdx; i + 1 in posArray && posArray[i].roomName == thisRoomName; i++) {
        if (costMat.get(posArray[i].x, posArray[i].y) == unWalkableCCost) { // 路上有东西挡路
            return false;
        }
        directionArray[i + 1] = getDirection(posArray[i], posArray[i + 1]);
    }
    if (observers.length && i + 1 in posArray) {
        while (i + 1 in posArray) {
            if (!directionArray[i + 1]) {
                addObTask(path, i + 1); // 这格没有direction
                break;
            }
            i += 1;
        }
    }
    return true;
}
/**
 *  尝试对穿，有2种不可穿情况
 * @param {Creep} creep
 * @param {RoomPosition} pos
 * @param {boolean} bypassHostileCreeps
 */
function trySwap(creep, pos, bypassHostileCreeps, ignoreCreeps) {
    let obstacleCreeps = creep.room.lookForAt(LOOK_CREEPS, pos).concat(creep.room.lookForAt(LOOK_POWER_CREEPS, pos));
    if (obstacleCreeps.length) {
        if (!ignoreCreeps) {
            return ERR_INVALID_TARGET;
        }
        for (let c of obstacleCreeps) {
            if (c.my) {
                if (c.memory.dontPullMe) { // 第1种不可穿情况：挡路的creep设置了不对穿
                    return ERR_INVALID_TARGET;
                }
                if (creepMoveCache[c.name] != Game.time && originMove.call(c, getDirection(pos, creep.pos)) == ERR_NO_BODYPART && creep.pull) {
                    creep.pull(c);
                    originMove.call(c, creep);
                }
            }
            else if (bypassHostileCreeps && (!c.room.controller || !c.room.controller.my || !c.room.controller.safeMode)) { // 第二种不可穿情况：希望绕过敌对creep
                return ERR_INVALID_TARGET;
            }
        }
        return OK; // 或者全部操作成功
    }
    return ERR_NOT_FOUND; // 没有creep
}
let temporalAvoidFrom, temporalAvoidTo;
function routeCallback(nextRoomName, fromRoomName) {
    if (nextRoomName in avoidRooms) {
        //console.log('Infinity at ' + nextRoomName);
        return Infinity;
    }
    return isHighWay(nextRoomName) ? 1 : 1.15;
}
function bypassRouteCallback(nextRoomName, fromRoomName) {
    if (fromRoomName == temporalAvoidFrom && nextRoomName == temporalAvoidTo) {
        //console.log(`Infinity from ${fromRoomName} to ${nextRoomName}`);
        return Infinity;
    }
    return routeCallback(nextRoomName);
}
/**
 *  遇到跨房寻路，先以房间为单位寻route，再寻精细的path
 * @param {string} fromRoomName
 * @param {string} toRoomName
 * @param {boolean} bypass
 */
function findRoute(fromRoomName, toRoomName, bypass = false) {
    //console.log('findRoute', fromRoomName, toRoomName, bypass);
    return Game.map.findRoute(fromRoomName, toRoomName, { routeCallback: bypass ? bypassRouteCallback : routeCallback });
}
/**
 * @param {RoomPosition} pos
 * @param {Room} room
 * @param {CostMatrix} costMat
 */
function checkTemporalAvoidExit(pos, room, costMat) {
    let neighbors = Game.map.describeExits(room.name);
    temporalAvoidFrom = temporalAvoidTo = ''; // 清空旧数据
    for (let direction in neighbors) {
        if (!(neighbors[direction] in avoidRooms)) {
            for (let direction in neighbors) {
                let exits = room.find(+direction);
                if (PathFinder.search(pos, exits, {
                    maxRooms: 1,
                    roomCallback: () => costMat
                }).incomplete) { // 此路不通
                    temporalAvoidFrom = room.name;
                    temporalAvoidTo = neighbors[direction];
                }
            }
        }
    }
}
function routeReduce(temp, item) {
    temp[item.room] = 1;
    return temp;
}
function bypassHostile(creep) {
    return !creep.my || creep.memory.dontPullMe;
}
function bypassMy(creep) {
    return creep.my && creep.memory.dontPullMe;
}
let bypassRoomName, bypassCostMat, bypassIgnoreCondition, userCostCallback, costMat, route;
function bypassRoomCallback(roomName) {
    if (roomName in avoidRooms) {
        return false;
    }
    if (roomName == bypassRoomName) { // 在findTemporalRoute函数里刚刚建立了costMatrix
        costMat = bypassCostMat;
    }
    else {
        costMat = roomName in costMatrixCache ? costMatrixCache[roomName][findPathIgnoreCondition] : emptyCostMatrix;
    }
    if (userCostCallback) {
        let resultCostMat = userCostCallback(roomName, roomName in costMatrixCache ? costMat.clone() : new PathFinder.CostMatrix);
        if (resultCostMat instanceof PathFinder.CostMatrix) {
            costMat = resultCostMat;
        }
    }
    return costMat;
}
function bypassRoomCallbackWithRoute(roomName) {
    if (roomName in route) {
        if (roomName == bypassRoomName) { // 在findTemporalRoute函数里刚刚建立了costMatrix
            costMat = bypassCostMat;
        }
        else {
            costMat = roomName in costMatrixCache ? costMatrixCache[roomName][findPathIgnoreCondition] : emptyCostMatrix;
        }
        if (userCostCallback) {
            let resultCostMat = userCostCallback(roomName, roomName in costMatrixCache ? costMat.clone() : new PathFinder.CostMatrix);
            if (resultCostMat instanceof PathFinder.CostMatrix) {
                costMat = resultCostMat;
            }
        }
        return costMat;
    }
    return false;
}
/**
 *  影响参数：bypassHostileCreeps, ignoreRoads, ignoreDestructibleStructures, ignoreSwamps, costCallback, range, bypassRange
 *  及所有PathFinder参数：plainCost, SwampCost, masOps, maxRooms, maxCost, heuristicWeight
 * @param {Creep} creep
 * @param {RoomPosition} toPos
 * @param {MoveToOpts} ops
 */
function findTemporalPath(creep, toPos, ops) {
    let nearbyCreeps;
    if (ops.ignoreCreeps) { // 有ignoreCreep，只绕过无法对穿的creep
        nearbyCreeps = creep.pos.findInRange(FIND_CREEPS, ops.bypassRange, {
            filter: ops.bypassHostileCreeps ? bypassHostile : bypassMy
        }).concat(creep.pos.findInRange(FIND_POWER_CREEPS, ops.bypassRange, {
            filter: ops.bypassHostileCreeps ? bypassHostile : bypassMy
        }));
    }
    else { // 绕过所有creep
        nearbyCreeps = creep.pos.findInRange(FIND_CREEPS, ops.bypassRange).concat(creep.pos.findInRange(FIND_POWER_CREEPS, ops.bypassRange));
    }
    if (!(creep.room.name in costMatrixCache)) { // 这个房间的costMatrix已经被删了
        generateCostMatrix(creep.room, creep.pos);
    }
    bypassIgnoreCondition = !!ops.ignoreDestructibleStructures;
    /** @type {CostMatrix} */
    bypassCostMat = costMatrixCache[creep.room.name][bypassIgnoreCondition].clone();
    for (let c of nearbyCreeps) {
        bypassCostMat.set(c.pos.x, c.pos.y, unWalkableCCost);
    }
    bypassRoomName = creep.room.name;
    userCostCallback = typeof ops.costCallback == 'function' ? ops.costCallback : undefined;
    /**@type {PathFinderOpts} */
    let PathFinderOpts = {
        maxRooms: ops.maxRooms,
        maxCost: ops.maxCost,
        heuristicWeight: ops.heuristicWeight || 1.2,
    };
    if (ops.ignoreSwamps) { // HELP 这里有没有什么不增加计算量的简短写法
        PathFinderOpts.plainCost = ops.plainCost || 1;
        PathFinderOpts.swampCost = ops.swampCost || 1;
    }
    else if (ops.ignoreRoads) {
        PathFinderOpts.plainCost = ops.plainCost || 1;
        PathFinderOpts.swampCost = ops.swampCost || 5;
    }
    else {
        PathFinderOpts.plainCost = ops.plainCost || 2;
        PathFinderOpts.swampCost = ops.swampCost || 10;
    }
    if (creep.pos.roomName != toPos.roomName) { // findRoute会导致非最优path的问题
        checkTemporalAvoidExit(creep.pos, creep.room, bypassCostMat); // 因为creep挡路导致的无法通行的出口
        route = findRoute(creep.pos.roomName, toPos.roomName, true);
        if (route == ERR_NO_PATH) {
            return false;
        }
        PathFinderOpts.maxRooms = PathFinderOpts.maxRooms || route.length + 1;
        PathFinderOpts.maxOps = ops.maxOps || 4000 + route.length ** 2 * 100; // 跨10room则有4000+10*10*100=14000
        route = route.reduce(routeReduce, { [creep.pos.roomName]: 1 }); // 因为 key in Object 比 Array.includes(value) 快，但不知道值不值得reduce
        PathFinderOpts.roomCallback = bypassRoomCallbackWithRoute;
    }
    else {
        PathFinderOpts.maxOps = ops.maxOps;
        PathFinderOpts.roomCallback = bypassRoomCallback;
    }
    let result = PathFinder.search(creep.pos, { pos: toPos, range: ops.range }, PathFinderOpts).path;
    if (result.length) {
        let creepCache = creepPathCache[creep.name];
        creepCache.path = {
            end: formalize(result[result.length - 1]),
            posArray: result,
            ignoreStructures: !!ops.ignoreDestructibleStructures
        };
        generateDirectionArray(creepCache.path);
        return true;
    }
    return false;
}
let findPathIgnoreCondition;
/**
 * @param {{[roomName:string]:1}} temp
 * @param {{room:string}} item
 * @returns {{[roomName:string]:1}}
 */
function roomCallback(roomName) {
    if (roomName in avoidRooms) {
        return false;
    }
    costMat = roomName in costMatrixCache ? costMatrixCache[roomName][findPathIgnoreCondition] : emptyCostMatrix;
    if (userCostCallback) {
        let resultCostMat = userCostCallback(roomName, roomName in costMatrixCache ? costMat.clone() : new PathFinder.CostMatrix);
        if (resultCostMat instanceof PathFinder.CostMatrix) {
            costMat = resultCostMat;
        }
    }
    return costMat;
}
function roomCallbackWithRoute(roomName) {
    if (roomName in route) {
        costMat = roomName in costMatrixCache ? costMatrixCache[roomName][findPathIgnoreCondition] : emptyCostMatrix;
        //console.log('in route ' + roomName);
        if (userCostCallback) {
            let resultCostMat = userCostCallback(roomName, roomName in costMatrixCache ? costMat.clone() : new PathFinder.CostMatrix);
            if (resultCostMat instanceof PathFinder.CostMatrix) {
                costMat = resultCostMat;
            }
        }
        return costMat;
    }
    //console.log('out route ' + roomName);
    return false; // 不在route上的不搜索
}
/**
 *  影响参数：ignoreRoads, ignoreDestructibleStructures, ignoreSwamps, costCallback, range
 *  及所有PathFinder参数：plainCost, SwampCost, maxOps, maxRooms, maxCost, heuristicWeight
 * @param {RoomPosition} fromPos
 * @param {RoomPosition} toPos
 * @param {MoveToOpts} ops
 */
function findPath(fromPos, toPos, ops) {
    if (!(fromPos.roomName in costMatrixCache) && fromPos.roomName in Game.rooms) { // 有视野没costMatrix
        generateCostMatrix(Game.rooms[fromPos.roomName], fromPos);
    }
    findPathIgnoreCondition = !!ops.ignoreDestructibleStructures;
    userCostCallback = typeof ops.costCallback == 'function' ? ops.costCallback : undefined;
    /**@type {PathFinderOpts} */
    let PathFinderOpts = {
        maxRooms: ops.maxRooms,
        maxCost: ops.maxCost,
        heuristicWeight: ops.heuristicWeight || 1.2
    };
    if (ops.ignoreSwamps) { // HELP 这里有没有什么不增加计算量的简短写法
        PathFinderOpts.plainCost = ops.plainCost;
        PathFinderOpts.swampCost = ops.swampCost || 1;
    }
    else if (ops.ignoreRoads) {
        PathFinderOpts.plainCost = ops.plainCost;
        PathFinderOpts.swampCost = ops.swampCost || 5;
    }
    else {
        PathFinderOpts.plainCost = ops.plainCost || 2;
        PathFinderOpts.swampCost = ops.swampCost || 10;
    }
    if (fromPos.roomName != toPos.roomName) { // findRoute会导致非最优path的问题
        route = findRoute(fromPos.roomName, toPos.roomName);
        if (route == ERR_NO_PATH) {
            return { path: [] };
        }
        PathFinderOpts.maxOps = ops.maxOps || 4000 + route.length ** 2 * 100; // 跨10room则有2000+10*10*50=7000
        PathFinderOpts.maxRooms = PathFinderOpts.maxRooms || route.length + 1;
        route = route.reduce(routeReduce, { [fromPos.roomName]: 1 }); // 因为 key in Object 比 Array.includes(value) 快，但不知道值不值得reduce
        //console.log(fromPos + ' using route ' + JSON.stringify(route));
        PathFinderOpts.roomCallback = roomCallbackWithRoute;
    }
    else {
        PathFinderOpts.maxOps = ops.maxOps;
        PathFinderOpts.roomCallback = roomCallback;
    }
    return PathFinder.search(fromPos, { pos: toPos, range: ops.range }, PathFinderOpts);
}
let combinedX, combinedY;
/**
 * @param {MyPath} newPath
 */
function addPathIntoCache(newPath) {
    combinedX = newPath.start.x + newPath.start.y;
    combinedY = newPath.end.x + newPath.end.y;
    if (!(combinedX in globalPathCache)) {
        globalPathCache[combinedX] = {
            [combinedY]: [] // 数组里放不同ops的及其他start、end与此对称的
        };
    }
    else if (!(combinedY in globalPathCache[combinedX])) {
        globalPathCache[combinedX][combinedY] = []; // 数组里放不同ops的及其他start、end与此对称的
    }
    globalPathCache[combinedX][combinedY].push(newPath);
}
function invalidate() {
    return 0;
}
/**
 * @param {MyPath} path
 */
function deletePath(path) {
    if (path.start) { // 有start属性的不是临时路
        let pathArray = globalPathCache[path.start.x + path.start.y][path.end.x + path.end.y];
        pathArray.splice(pathArray.indexOf(path), 1);
        path.posArray = path.posArray.map(invalidate);
    }
}
let minX, maxX, minY, maxY;
/**
 *  寻找房内缓存路径，起始位置两步限制避免复用非最优路径
 * @param {RoomPosition} formalFromPos
 * @param {RoomPosition} formalToPos
 * @param {RoomPosition} fromPos
 * @param {CreepPaths} creepCache
 * @param {MoveToOpts} ops
 */
function findShortPathInCache(formalFromPos, formalToPos, fromPos, creepCache, ops) {
    startCacheSearch = Game.cpu.getUsed();
    minX = formalFromPos.x + formalFromPos.y - 2;
    maxX = formalFromPos.x + formalFromPos.y + 2;
    minY = formalToPos.x + formalToPos.y - 1 - ops.range;
    maxY = formalToPos.x + formalToPos.y + 1 + ops.range;
    for (combinedX = minX; combinedX <= maxX; combinedX++) {
        if (combinedX in globalPathCache) {
            for (combinedY = minY; combinedY <= maxY; combinedY++) {
                if (combinedY in globalPathCache[combinedX]) {
                    for (let path of globalPathCache[combinedX][combinedY]) { // 这个数组应该会很短
                        if (isNear(path.start, formalFromPos) && isNear(fromPos, path.posArray[1]) && inRange(path.end, formalToPos, ops.range) && isSameOps(path, ops)) { // 找到路了
                            creepCache.path = path;
                            return true;
                        }
                    }
                }
            }
        }
    }
    return false;
}
/**
 *  寻找跨房缓存路径，允许起始位置少量的误差
 * @param {RoomPosition} formalFromPos
 * @param {RoomPosition} formalToPos
 * @param {CreepPaths} creepCache
 * @param {MoveToOpts} ops
 */
function findLongPathInCache(formalFromPos, formalToPos, creepCache, ops) {
    startCacheSearch = Game.cpu.getUsed();
    minX = formalFromPos.x + formalFromPos.y - 2;
    maxX = formalFromPos.x + formalFromPos.y + 2;
    minY = formalToPos.x + formalToPos.y - 1 - ops.range;
    maxY = formalToPos.x + formalToPos.y + 1 + ops.range;
    for (combinedX = minX; combinedX <= maxX; combinedX++) {
        if (combinedX in globalPathCache) {
            for (combinedY = minY; combinedY <= maxY; combinedY++) {
                if (combinedY in globalPathCache[combinedX]) {
                    for (let path of globalPathCache[combinedX][combinedY]) { // 这个数组应该会很短
                        if (isNear(path.start, formalFromPos) && inRange(path.end, formalToPos, ops.range) && isSameOps(path, ops)) { // 找到路了
                            creepCache.path = path;
                            return true;
                        }
                    }
                }
            }
        }
    }
    return false;
}
let startRoomName, endRoomName;
/**
 *  起止点都在自己房间的路不清理
 * @param {CreepPaths['name']} creepCache
 */
function setPathTimer(creepCache) {
    {
        let posArray = creepCache.path.posArray;
        startRoomName = posArray[0].roomName;
        endRoomName = posArray[posArray.length - 1].roomName;
        if (startRoomName != endRoomName || (startRoomName in Game.rooms && Game.rooms[startRoomName].controller && !Game.rooms[startRoomName].controller.my)) { // 跨房路或者敌方房间路
            if (!(Game.time + pathClearDelay in pathCacheTimer)) {
                pathCacheTimer[Game.time + pathClearDelay] = [];
            }
            pathCacheTimer[Game.time + pathClearDelay].push(creepCache.path);
            creepCache.path.lastTime = Game.time;
        }
    }
}
/**
 *
 * @param {Creep} creep
 * @param {RoomPosition} toPos
 * @param {RoomPosition[]} posArray
 * @param {number} startIdx
 * @param {number} idxStep
 * @param {PolyStyle} visualStyle
 */
function showVisual(creep, toPos, posArray, startIdx, idxStep, visualStyle) {
    return;
}
/**
 *  按缓存路径移动
 * @param {Creep} creep
 * @param {PolyStyle} visualStyle
 * @param {RoomPosition} toPos
 */
function moveOneStep(creep, visualStyle, toPos) {
    let creepCache = creepPathCache[creep.name];
    if (visualStyle) {
        showVisual(creep, toPos, creepCache.path.posArray, creepCache.idx);
    }
    if (creep.fatigue) {
        return ERR_TIRED;
    }
    creepCache.idx++;
    creepMoveCache[creep.name] = Game.time;
    Game.cpu.getUsed() - startTime;
    //creep.room.visual.circle(creepCache.path.posArray[creepCache.idx]);
    return originMove.call(creep, creepCache.path.directionArray[creepCache.idx]);
}
/**
 *
 * @param {Creep} creep
 * @param {{
        path: MyPath,
        dst: RoomPosition,
        idx: number
    }} pathCache
 * @param {PolyStyle} visualStyle
 * @param {RoomPosition} toPos
 * @param {boolean} ignoreCreeps
 */
function startRoute(creep, pathCache, visualStyle, toPos, ignoreCreeps) {
    let posArray = pathCache.path.posArray;
    let idx = 0;
    while (idx in posArray && isNear(creep.pos, posArray[idx])) {
        idx += 1;
    }
    idx -= 1;
    pathCache.idx = idx;
    creepMoveCache[creep.name] = Game.time;
    let nextStep = posArray[idx];
    if (ignoreCreeps) {
        trySwap(creep, nextStep, false, true);
    }
    return originMove.call(creep, getDirection(creep.pos, posArray[idx]));
}
/**
 * @param {Function} fn
 */
function wrapFn(fn, name) {
    return function () {
        startTime = Game.cpu.getUsed(); // 0.0015cpu
        if (obTick < Game.time) {
            obTick = Game.time;
            checkObResult();
            doObTask();
        }
        let code = fn.apply(this, arguments);
        endTime = Game.cpu.getUsed();
        if (endTime - startTime >= 0.2) {
            analyzeCPU[name].sum += endTime - startTime;
            analyzeCPU[name].calls++;
        }
        return code;
    };
}
function clearUnused() {
    if (Game.time % pathClearDelay == 0) { // 随机清一次已死亡creep
        for (let name in creepPathCache) {
            if (!(name in Game.creeps)) {
                delete creepPathCache[name];
            }
        }
    }
    for (let time in pathCacheTimer) {
        if (+time > Game.time) {
            break;
        }
        //console.log('clear path');
        for (let path of pathCacheTimer[time]) {
            if (path.lastTime == +time - pathClearDelay) {
                deletePath(path);
            }
        }
        delete pathCacheTimer[time];
    }
    for (let time in costMatrixCacheTimer) {
        if (+time > Game.time) {
            break;
        }
        //console.log('clear costMat');
        for (let data of costMatrixCacheTimer[time]) {
            delete costMatrixCache[data.roomName];
            for (let avoidRoomName of data.avoids) {
                delete avoidRooms[avoidRoomName];
            }
        }
        delete costMatrixCacheTimer[time];
    }
}
/**@type {[MoveToOpts, RoomPosition, CreepPaths['1'], MyPath, number, RoomPosition[], boolean]}
 */
let [ops, toPos, creepCache, path, idx, posArray, found] = [undefined, undefined, undefined, undefined, undefined, undefined, undefined];
/**
 *  把moveTo重写一遍
 * @param {Creep} this
 * @param {number | RoomObject} firstArg
 * @param {number | MoveToOpts} secondArg
 * @param {MoveToOpts} opts
 */
function betterMoveTo(firstArg, secondArg, opts) {
    if (!this.my) {
        return ERR_NOT_OWNER;
    }
    if (this.spawning) {
        return ERR_BUSY;
    }
    if (typeof firstArg == 'object') {
        toPos = firstArg.pos || firstArg;
        ops = secondArg || {};
    }
    else {
        toPos = { x: firstArg, y: secondArg, roomName: this.room.name };
        ops = opts || {};
    }
    ops.bypassHostileCreeps = ops.bypassHostileCreeps === undefined || ops.bypassHostileCreeps; // 设置默认值为true
    ops.ignoreCreeps = ops.ignoreCreeps === undefined || ops.ignoreCreeps;
    if (typeof toPos.x != "number" || typeof toPos.y != "number") { // 房名无效或目的坐标不是数字，不合法
        //this.say('no tar');
        return ERR_INVALID_TARGET;
    }
    else if (inRange(this.pos, toPos, ops.range || 1)) { // 已到达
        if (isEqual(toPos, this.pos) || ops.range) { // 已到达
            return OK;
        } // else 走一步
        if (this.pos.roomName == toPos.roomName && ops.ignoreCreeps) { // 同房间考虑一下对穿
            trySwap(this, toPos, false, true);
        }
        creepMoveCache[this.name] = Game.time; // 用于防止自己移动后被误对穿
        Game.cpu.getUsed() - startTime;
        return originMove.call(this, getDirection(this.pos, toPos));
    }
    ops.range = ops.range || 1;
    if (!hasActiveBodypart(this.body, MOVE)) {
        return ERR_NO_BODYPART;
    }
    if (this.fatigue) {
        if (!ops.visualizePathStyle) { // 不用画路又走不动，直接return
            return ERR_TIRED;
        } // else 要画路，画完再return
    }
    // HELP：感兴趣的帮我检查这里的核心逻辑orz
    creepCache = creepPathCache[this.name];
    if (creepCache) { // 有缓存
        path = creepCache.path;
        idx = creepCache.idx;
        if (path && idx in path.posArray && path.ignoreStructures == !!ops.ignoreDestructibleStructures) { // 缓存路条件相同
            posArray = path.posArray;
            if (isEqual(toPos, creepCache.dst) || inRange(posArray[posArray.length - 1], toPos, ops.range)) { // 正向走，目的地没变
                if (isEqual(this.pos, posArray[idx])) { // 正常
                    if ('storage' in this.room && inRange(this.room.storage.pos, this.pos, coreLayoutRange) && ops.ignoreCreeps) {
                        if (trySwap(this, posArray[idx + 1], false, true) == OK) ;
                    }
                    //this.say('正常');
                    return moveOneStep(this, ops.visualizePathStyle, toPos);
                }
                else if (idx + 1 in posArray && idx + 2 in posArray && isEqual(this.pos, posArray[idx + 1])) { // 跨房了
                    creepCache.idx++;
                    if (!path.directionArray[idx + 2]) { // 第一次见到该房则检查房间
                        if (checkRoom(this.room, path, creepCache.idx)) { // 传creep所在位置的idx
                            //this.say('新房 可走');
                            //console.log(`${Game.time}: ${this.name} check room ${this.pos.roomName} OK`);
                            return moveOneStep(this, ops.visualizePathStyle, toPos); // 路径正确，继续走
                        } // else 检查中发现房间里有建筑挡路，重新寻路
                        //console.log(`${Game.time}: ${this.name} check room ${this.pos.roomName} failed`);
                        deletePath(path);
                    }
                    else {
                        //this.say('这个房间见过了');
                        return moveOneStep(this, ops.visualizePathStyle, toPos); // 路径正确，继续走
                    }
                }
                else if (isNear(this.pos, posArray[idx])) { // 堵路了
                    let code = trySwap(this, posArray[idx], ops.bypassHostileCreeps, ops.ignoreCreeps); // 检查挡路creep
                    if (code == OK) ;
                    else if (code == ERR_INVALID_TARGET) { // 是被设置了不可对穿的creep或者敌对creep挡路，临时绕路
                        ops.bypassRange = ops.bypassRange || 5; // 默认值
                        if (typeof ops.bypassRange != "number" || typeof ops.range != 'number') {
                            return ERR_INVALID_ARGS;
                        }
                        if (findTemporalPath(this, toPos, ops)) { // 有路，creepCache的内容会被这个函数更新
                            //this.say('开始绕路');
                            return startRoute(this, creepCache, ops.visualizePathStyle, toPos, ops.ignoreCreeps);
                        }
                        else { // 没路
                            //this.say('没路啦');
                            return ERR_NO_PATH;
                        }
                    }
                    else if (code == ERR_NOT_FOUND && isObstacleStructure(this.room, posArray[idx], ops.ignoreDestructibleStructures)) { // 发现出现新建筑物挡路，删除costMatrix和path缓存，重新寻路
                        //console.log(`${Game.time}: ${this.name} find obstacles at ${this.pos}`);
                        delete costMatrixCache[this.pos.roomName];
                        deletePath(path);
                    } // else 上tick移动失败但也不是建筑物和creep/pc挡路。有2个情况：1.下一格路本来是穿墙路并碰巧消失了；2.下一格是房间出口，有另一个creep抢路了然后它被传送到隔壁了。不处理第1个情况，按第2个情况对待。
                    //this.say('对穿' + getDirection(this.pos, posArray[idx]) + '-' + originMove.call(this, getDirection(this.pos, posArray[idx])));
                    if (ops.visualizePathStyle) {
                        showVisual(this, toPos, posArray, idx, 1, ops.visualizePathStyle);
                    }
                    creepMoveCache[this.name] = Game.time;
                    return originMove.call(this, getDirection(this.pos, posArray[idx])); // 有可能是第一步就没走上路or通过略过moveTo的move操作偏离路线，直接call可兼容
                }
                else if (idx - 1 >= 0 && isNear(this.pos, posArray[idx - 1])) { // 因为堵路而被自动传送反向跨房了
                    //this.say('偏离一格');
                    if (this.pos.roomName == posArray[idx - 1].roomName && ops.ignoreCreeps) { // 不是跨房而是偏离，检查对穿
                        trySwap(this, posArray[idx - 1], false, true);
                    }
                    if (ops.visualizePathStyle) {
                        showVisual(this, toPos, posArray, idx, 1, ops.visualizePathStyle);
                    }
                    creepMoveCache[this.name] = Game.time;
                    return originMove.call(this, getDirection(this.pos, posArray[idx - 1])); // 同理兼容略过moveTo的move
                } // else 彻底偏离，重新寻路
            } // else 目的地变了
        } // else 缓存中没路或者条件变了
    } // else 需要重新寻路，先找缓存路，找不到就寻路
    if (!creepCache) { // 初始化cache
        creepCache = {
            dst: { x: NaN, y: NaN },
            path: undefined,
            idx: 0
        };
        creepPathCache[this.name] = creepCache;
    }
    else {
        creepCache.path = undefined;
    }
    if (typeof ops.range != 'number') {
        return ERR_INVALID_ARGS;
    }
    found = this.pos.roomName == toPos.roomName ? findShortPathInCache(formalize(this.pos), formalize(toPos), this.pos, creepCache, ops) : findLongPathInCache(formalize(this.pos), formalize(toPos), creepCache, ops);
    if (found) ;
    else { // 没找到缓存路
        if (autoClearTick < Game.time) { // 自动清理
            autoClearTick = Game.time;
            clearUnused();
        }
        let result = findPath(this.pos, toPos, ops);
        if (!result.path.length || (result.incomplete && result.path.length == 1)) { // 一步也动不了了
            //this.say('no path')
            return ERR_NO_PATH;
        }
        result = result.path;
        result.unshift(this.pos);
        //this.say('start new');
        let newPath = {
            start: formalize(result[0]),
            end: formalize(result[result.length - 1]),
            posArray: result,
            ignoreRoads: !!ops.ignoreRoads,
            ignoreStructures: !!ops.ignoreDestructibleStructures,
            ignoreSwamps: !!ops.ignoreSwamps
        };
        generateDirectionArray(newPath);
        addPathIntoCache(newPath);
        //console.log(this, this.pos, 'miss');
        creepCache.path = newPath;
    }
    creepCache.dst = toPos;
    setPathTimer(creepCache);
    found ? cacheHitCost += Game.cpu.getUsed() - startCacheSearch : cacheMissCost += Game.cpu.getUsed() - startCacheSearch;
    return startRoute(this, creepCache, ops.visualizePathStyle, toPos, ops.ignoreCreeps);
}
/***************************************
 *  初始化
 *  Creep.prototype.move()将在v0.9.x版本加入
 *  ob寻路、自动visual将在v0.9.x或v1.0.x版本加入
 *  RoomPosition.prototype.findClosestByPath()将在v1.1加入
 *  Creep.prototype.flee()、RoomPosition.prototype.findSquadPathTo()函数将在v1.1或v1.2加入
 *  checkSquadPath()有小概率会写
 */
avoidRooms = avoidRooms.reduce((temp, roomName) => {
    temp[roomName] = 1;
    return temp;
}, []);
observers = observers.reduce((temp, id) => {
    let ob = Game.getObjectById(id.id);
    if (ob && ob.observeRoom && ob.my) {
        temp.push({ id, roomName: ob.room.name, taskQueue: [] });
    }
    return temp;
}, []);
// Creep.prototype.move = wrapFn(config.changeMove? betterMove : originMove, 'move');
Creep.prototype.moveTo = wrapFn(betterMoveTo , 'moveTo');
Creep.prototype.originMoveTo = originMoveTo;
Creep.prototype.$moveTo = Creep.prototype.moveTo;
Creep.prototype.moveTo = function (...e) {
    if (this.memory.lastPos && this.memory.lastPos.x == this.pos.x && this.memory.lastPos.y == this.pos.y) {
        this.memory.lastPos.time += 1;
        if (this.memory.lastPos.time > 6)
            this.memory.dontPullMe = true;
    }
    else {
        this.memory.dontPullMe = false;
        this.memory.lastPos = { x: this.pos.x, y: this.pos.y, time: 0 };
    }
    // this.say(this.memory.lastPos.time)
    return this.$moveTo(...e);
};
// Creep.prototype.$move=Creep.prototype.move;
// Creep.prototype.move=function (...e) {
//     this.memory.dontPullMe = false;
//     return this.$move(...e)
// };
Creep.prototype.$build = Creep.prototype.build;
Creep.prototype.build = function (...e) {
    this.memory.dontPullMe = true;
    return this.$build(...e);
};
Creep.prototype.$repair = Creep.prototype.repair;
Creep.prototype.repair = function (...e) {
    this.memory.dontPullMe = true;
    return this.$repair(...e);
};
Creep.prototype.$upgradeController = Creep.prototype.upgradeController;
Creep.prototype.upgradeController = function (...e) {
    this.memory.dontPullMe = true;
    return this.$upgradeController(...e);
};
Creep.prototype.$dismantle = Creep.prototype.dismantle;
Creep.prototype.dismantle = function (...e) {
    this.memory.dontPullMe = true;
    return this.$dismantle(...e);
};
Creep.prototype.$harvest = Creep.prototype.harvest;
Creep.prototype.harvest = function (...e) {
    this.memory.dontPullMe = true;
    return this.$harvest(...e);
};
Creep.prototype.$attack = Creep.prototype.attack;
Creep.prototype.attack = function (...e) {
    this.memory.dontPullMe = true;
    return this.$attack(...e);
};
// Creep.prototype.$withdraw=Creep.prototype.withdraw;
// Creep.prototype.withdraw=function (...e) {
//     this.memory.dontPullMe = true;
//     return this.$withdraw(...e)
// };

const initStorage = function () {
    if (!Memory.rooms)
        Memory.rooms = {};
    else
        delete Memory.rooms.undefined;
};
const mountAll = function () {
    // 存储的兜底工作
    initStorage();
    // 挂载全部拓展
    mountConsole();
    mountPosition();
    mountRoom();
    mountStructure();
    mountCreep();
    mountPowerCreep();
    mountHelp();
    console.log(Colorful$1('拓展挂载完成', 'blue', true));
};
const createGlobalExtension = function () {
    mountAll();
    return {
        born: () => { }
    };
};

/* 可视化模块 */
/**
 * 防御塔数据可视化
 * TowerVisualAttack 防御塔攻击数据
 * TowerVisualHeal   防御塔治疗数据
 * TowerVisualRepair 防御塔维修数据
 * 较消耗cpu，仅做短暂统计用，请及时截图及销毁旗帜
 * @returns void
 */
function showTowerData() {
    if (Game.flags['TowerVisualWar']) {
        let roomName = Game.flags['TowerVisualWar'].pos.roomName;
        // if (!global.warData) global.warData = {}
        if (!global.HostileData)
            return;
        if (!global.HostileData[roomName])
            return;
        // console.log('开始绘制操作')
        if (global.HostileData[roomName].data) {
            // console.log(JSON.stringify(global.warData.tower[roomName].data))
            for (var posData in global.HostileData[roomName].data) {
                /* 数据 */
                let posXY = unzipXandY(posData);
                let tx = posXY[0];
                let ty = posXY[1];
                var Data = global.HostileData[roomName].data[posData];
                Data.attack;
                if (Data.attack + Data.rattack > 0) {
                    let attack = Data.attack + Data.rattack;
                    new RoomVisual(roomName).text(`${attack}`, tx, ty - 0.1, { color: 'red', font: 0.3, align: 'center' });
                }
                if (Data.heal > 0) {
                    new RoomVisual(roomName).text(`${Data.heal}`, tx, ty + 0.3, { color: 'green', font: 0.3, align: 'center' });
                }
            }
            return;
        }
        if (!Game.rooms[roomName]) {
            return;
        }
    }
    if (Game.flags['TowerVisualAllhurt']) {
        let roomName = Game.flags['TowerVisualAllhurt'].pos.roomName;
        if (!global.warData)
            global.warData = {};
        if (!global.warData.allhurt)
            global.warData.allhurt = {};
        if (!global.warData.allhurt[roomName])
            global.warData.allhurt[roomName] = { count: 0 };
        if (global.warData.allhurt[roomName].data) {
            // console.log(JSON.stringify(global.warData.tower[roomName].data))
            for (var posData in global.warData.allhurt[roomName].data) {
                /* 数据 */
                let posXY = unzipXandY(posData);
                let tx = posXY[0];
                let ty = posXY[1];
                var Data = global.warData.allhurt[roomName].data[posData];
                new RoomVisual(roomName).text(`${Data.attack}`, tx, ty - 0.1, { color: 'red', font: 0.3, align: 'center' });
                if (Data.avoid) {
                    new RoomVisual(roomName).text(`${Data.avoid}`, tx, ty + 0.3, { color: 'yellow', font: 0.3, align: 'center' });
                }
            }
            return;
        }
        if (!Game.rooms[roomName]) {
            /* 如果没有房间视野，采用observe观察 */
            for (let i in Memory.RoomControlData) {
                if (Game.rooms[i] && Game.rooms[i].controller.level >= 8) {
                    let observer_ = Game.getObjectById(Game.rooms[i].memory.StructureIdData.ObserverID);
                    if (observer_ && observer_.observeRoom(roomName) == OK)
                        break;
                }
            }
            return;
        }
        if (!global.warData.allhurt[roomName]) {
            console.log(roomName, '操作绘制');
            global.warData.allhurt[roomName] = { count: 0, data: {} };
            global.warData.allhurt[roomName].data = getAllhurt(Game.rooms[roomName]);
        }
    }
    if (Game.flags['TowerVisualAttack']) {
        let roomName = Game.flags['TowerVisualAttack'].pos.roomName;
        if (!global.warData)
            global.warData = {};
        if (!global.warData.tower)
            global.warData.tower = {};
        if (!global.warData.tower[roomName])
            global.warData.tower[roomName] = { count: 0 };
        if (global.warData.tower[roomName].data) {
            // console.log(JSON.stringify(global.warData.tower[roomName].data))
            for (var posData in global.warData.tower[roomName].data) {
                /* 数据 */
                let posXY = unzipXandY(posData);
                let tx = posXY[0];
                let ty = posXY[1];
                var Data = global.warData.tower[roomName].data[posData];
                new RoomVisual(roomName).text(`${Data.attack}`, tx, ty - 0.1, { color: 'red', font: 0.3, align: 'center' });
                if (Data.avoid) {
                    new RoomVisual(roomName).text(`${Data.avoid}`, tx, ty + 0.3, { color: 'yellow', font: 0.3, align: 'center' });
                }
            }
            return;
        }
        if (!Game.rooms[roomName]) {
            /* 如果没有房间视野，采用observe观察 */
            for (let i in Memory.RoomControlData) {
                if (Game.rooms[i] && Game.rooms[i].controller.level >= 8) {
                    let observer_ = Game.getObjectById(Game.rooms[i].memory.StructureIdData.ObserverID);
                    if (observer_ && observer_.observeRoom(roomName) == OK)
                        break;
                }
            }
            return;
        }
        if (!global.warData.tower[roomName].data)
            global.warData.tower[roomName].data = getTowerData(Game.rooms[roomName]);
    }
    if (Game.flags['TowerVisualHeal']) {
        let roomName = Game.flags['TowerVisualHeal'].pos.roomName;
        if (!global.warData)
            global.warData = {};
        if (!global.warData.tower)
            global.warData.tower = {};
        if (!global.warData.tower[roomName])
            global.warData.tower[roomName] = { count: 0 };
        if (global.warData.tower[roomName].data) {
            for (var posData in global.warData.tower[roomName].data) {
                /* 数据 */
                let posXY = unzipXandY(posData);
                let tx = posXY[0];
                let ty = posXY[1];
                var Data = global.warData.tower[roomName].data[posData];
                new RoomVisual(roomName).text(`${Data.heal}`, tx, ty, { color: 'green', font: 0.4, align: 'center' });
            }
            return;
        }
        if (!Game.rooms[roomName]) {
            /* 如果没有房间视野，采用observe观察 */
            for (let i in Memory.RoomControlData) {
                if (Game.rooms[i] && Game.rooms[i].controller.level >= 8) {
                    let observer_ = Game.getObjectById(Game.rooms[i].memory.StructureIdData.ObserverID);
                    if (!observer_) {
                        delete Game.rooms[i].memory.StructureIdData.ObserverID;
                        return;
                    }
                    if (observer_ && observer_.observeRoom(roomName) == OK)
                        break;
                }
            }
            return;
        }
        if (!global.warData.tower[roomName].data)
            global.warData.tower[roomName].data = getTowerData(Game.rooms[roomName]);
    }
    if (Game.flags['TowerVisualRepair']) {
        let roomName = Game.flags['TowerVisualRepair'].pos.roomName;
        if (!global.warData)
            global.warData = {};
        if (!global.warData.tower)
            global.warData.tower = {};
        if (!global.warData.tower[roomName])
            global.warData.tower[roomName] = { count: 0 };
        if (global.warData.tower[roomName].data) {
            for (var posData in global.warData.tower[roomName].data) {
                /* 数据 */
                let posXY = unzipXandY(posData);
                let tx = posXY[0];
                let ty = posXY[1];
                var Data = global.warData.tower[roomName].data[posData];
                new RoomVisual(roomName).text(`${Data.repair}`, tx, ty, { color: 'yellow', font: 0.4, align: 'center' });
            }
            return;
        }
        if (!Game.rooms[roomName]) {
            /* 如果没有房间视野，采用observe观察 */
            for (let i in Memory.RoomControlData) {
                if (Game.rooms[i] && Game.rooms[i].controller.level >= 8) {
                    let observer_ = Game.getObjectById(Game.rooms[i].memory.StructureIdData.ObserverID);
                    if (observer_ && observer_.observeRoom(roomName) == OK)
                        break;
                }
            }
            return;
        }
        if (!global.warData.tower[roomName].data)
            global.warData.tower[roomName].data = getTowerData(Game.rooms[roomName]);
    }
}
const towerDataVisual = {
    tickEnd: showTowerData
};
/**
 * 房间日常数据可视化
 * 瞬时cpu 平均cpu 房间状态 任务数 bucket等
 */
// export function RoomDataVisual(room:Room):void{
//     room.visual.rect(0,0,7,10,{opacity:0.1,stroke: '#696969',strokeWidth:0.2})
//     let row = 0
//     room.visual.text(`全局实时CPU:${(global.UsedCpu?global.UsedCpu:0).toFixed(2)}`,0,row+=1,{color: 'black', font:0.7,align:'left'})
//     room.visual.text(`全局平均CPU:${(global.AveCpu?global.AveCpu:0).toFixed(2)}`,0,row+=1,{color: 'black', font:0.7,align:'left'})
//     room.visual.text(`测量基数:${(global.CpuData?global.CpuData.length:0)}`,0,row+=1,{color: 'black', font:0.7,align:'left'})
//     room.visual.text(`房间状态:${(room.memory.state=="peace"?"和平":"战争")}`,0,row+=1,{color: room.memory.state == 'peace'?'#006400':'red', font:0.7,align:'left'})
//     room.visual.text(`cpu池:${Game.cpu.bucket}`,0,row+=1,{color: Game.cpu.bucket < 2000?'red':'black', font:0.7,align:'left'})
//     /* 控制器进度 */
//     let processController = room.controller.level >= 8?100:((room.controller.progress/room.controller.progressTotal)*100).toFixed(4)
//     room.visual.text(`控制器进度:${processController}%`,0,row+=1,{color: 'black', font:0.7,align:'left'})
//     /* 目前存在任务数 */
//     var MissonNum = 0
//     for (var range in room.memory.Misson)
//         MissonNum += Object.keys(room.memory.Misson[range]).length
//     room.visual.text(`房间任务数:${MissonNum}`,0,row+=1,{color: MissonNum>0?'#008B8B':'black', font:0.7,align:'left'})
//     /* 仓库剩余容量 */
//     let storage_ = room.storage
//     if (storage_)
//     {
//         let num = Math.ceil(storage_.store.getFreeCapacity()/1000)
//         let color:string
//         if (num <= 50) color = '#B22222'
//         else if (num > 50 && num <= 200) color = '#FF8C00'
//         else if (num > 200 && num <= 400) color = '#006400'
//         else color = '#4682B4'
//         room.visual.text(`仓库剩余容量:${num}K`,0,row+=1,{color: color , font:0.7,align:'left'})
//     }
//     if (room.controller.level >= 8)
//     {
//         if (room.memory.productData.producing)
//         room.visual.text(`工厂生产:${room.memory.productData.producing.com}`,0,row+=1,{color: 'black' , font:0.7,align:'left'})
//         if (Object.keys(room.memory.ComDispatchData).length > 0)
//         {
//             room.visual.text(`合成规划:${Object.keys(room.memory.ComDispatchData)[Object.keys(room.memory.ComDispatchData).length-1]}`,0,row+=1,{color: 'black' , font:0.7,align:'left'})
//         }
//     }
//     /* lab资源可视化 */
//     if (Object.keys(room.memory.RoomLabBind).length > 0)
//     {
//         for (let i in room.memory.RoomLabBind)
//         {
//             let lab_ = Game.getObjectById(i) as StructureLab
//             if (!lab_)
//             {
//                 delete room.memory.RoomLabBind[i]
//                 let index = room.memory.StructureIdData.labs.indexOf(i)
//                 room.memory.StructureIdData.labs.splice(index,1)
//                 continue
//             }
//             room.visual.text(`${room.memory.RoomLabBind[i].rType}`,lab_.pos.x,lab_.pos.y,{color:CompoundColor[room.memory.RoomLabBind[i].rType],font:0.3,align:'center',strokeWidth:0.2})
//         }
//     }
// }
const normalTextStyle = { color: colors$2.zinc, opacity: 0.8, font: 0.7, align: 'left' };
function labelBar(visual, x, y, labelSpace, w, label, content, percent, color) {
    visual.text(label, x + labelSpace, y, { color, opacity: 0.7, font: 0.7, align: 'right' });
    // box(visual, x + labelSpace + 0.1, y - 0.7, 6.2, 0.9, { color, opacity: 0.2 })
    visual.rect(x + labelSpace + 0.1 + 0.1, y - 0.6, percent * w, 0.7, { fill: color, opacity: 0.3 });
    visual.text(content, x + labelSpace + 0.1 + w / 2, y - 0.05, { color, font: 0.5, align: 'center' });
}
function creepColor(visual, creep) {
    const x = creep.pos.x, y = creep.pos.y;
    const color = '#' + creep.name.substring(0, 6);
    visual.circle(x, y, { radius: 0.55, stroke: color, strokeWidth: 0.1, fill: "", opacity: 1 });
    visual.text(RoleData[creep.memory.role].mark, x, y + 0.16, { font: 0.5, opacity: 1, align: "center" });
}
/**
 * 房间日常数据可视化
 * 瞬时cpu 平均cpu 房间状态 任务数 bucket等
 */
function processRoomDataVisual(room) {
    var _a;
    if (!room.memory.Visualdisplay)
        return;
    const visual = room.visual;
    // Room Status
    var line = 0.7;
    visual.text(`${room.name}`, 0.1, line, normalTextStyle);
    visual.text(room.memory.state === 'peace' ? '和平' : '战争', room.name.length * 0.45 + 0.3, 0.7, Object.assign(Object.assign({}, normalTextStyle), { color: room.memory.state === 'peace' ? colors$2.zinc : colors$2.red }));
    Object.values(room.memory.Misson).reduce((a, b) => a + b.length, 0);
    // visual.text(`共 ${missionNum} 任务`, room.name.length * 0.45 + 2, 0.7, { ...normalTextStyle, color: missionNum > 20 ? colors.amber : colors.zinc })
    // visual.text(`${Object.values(global.CreepNumData[room.name] || {}).reduce((a, b) => a + b, 0)} 爬虫`, room.name.length * 0.45 + missionNum.toString().length * 0.4 + 4.6, 0.7, normalTextStyle)
    // if (!global.RoomDataVisual || !Game.cpu.generatePixel) {
    // CPU
    const cpuUsed = global.UsedCpu || 0;
    const usedCpuPercent = cpuUsed / Game.cpu.limit;
    const usedCpuPercentVisual = Math.min(usedCpuPercent, 1);
    const cpuColor = usedCpuPercent > 0.8 ? colors$2.rose : usedCpuPercent > 0.5 ? colors$2.amber : colors$2.emerald;
    labelBar(visual, 0.1, line += 1.1, 1.4, 6, 'CPU', `${cpuUsed.toFixed(2)} - ${Math.round(usedCpuPercent * 100)}%`, usedCpuPercentVisual, cpuColor);
    // 平均CPU
    const ave_cpuUsed = (global.AveCpu ? global.AveCpu : 0);
    const ave_usedCpuPercent = ave_cpuUsed / Game.cpu.limit;
    const ave_usedCpuPercentVisual = Math.min(ave_usedCpuPercent, 1);
    const ave_cpuColor = ave_usedCpuPercent > 0.8 ? colors$2.rose : ave_usedCpuPercent > 0.5 ? colors$2.amber : colors$2.emerald;
    labelBar(visual, 0.1, line += 1.1, 1.4, 6, 'APU', `${ave_cpuUsed.toFixed(2)} - ${Math.round(ave_usedCpuPercent * 100)}%-<${(global.CpuData ? global.CpuData.length : 0)}>`, ave_usedCpuPercentVisual, ave_cpuColor);
    // Bucket
    const bucket = Game.cpu.bucket;
    const bucketPercent = bucket / 10000;
    const bucketColor = bucketPercent < 0.1 ? colors$2.rose : bucketPercent < 0.3 ? colors$2.amber : colors$2.emerald;
    labelBar(visual, 0.1, line += 1.1, 1.4, 6, 'BKT', `${bucket}`, bucketPercent, bucketColor);
    // if (Game.cpu.generatePixel) global.RoomDataVisual = Game.map.visual.export();
    // } else {
    //   if (Game.cpu.generatePixel) Game.map.visual.import(global.RoomDataVisual);
    //   line += 3.3;
    // }
    //   
    // 控制器进度
    if (room.controller.level < 8) {
        const controllerProgress = room.controller.level >= 8 ? 1 : room.controller.progress / room.controller.progressTotal;
        labelBar(visual, 0.1, line += 1.1, 1.4, 6, '升级', `${controllerProgress >= 1 ? 100 : ((controllerProgress * 100).toFixed(4))}%`, controllerProgress, colors$2.cyan);
    }
    // 仓库
    // let storage = room.storage as StructureStorage
    // if (storage) {
    //   let storage_all = storage.store.getCapacity();
    //   let storage_use = storage.store.getUsedCapacity();
    //   const storageFree = Math.ceil(storage_use / 1000)
    //   const storageUsedPercent = storage_use / storage_all
    //   const storageFreeColor = storageUsedPercent > 0.9 ? colors.rose : storageUsedPercent > 0.7 ? colors.amber : colors.cyan
    //   labelBar(visual, 0.1, line += 1.1, 1.4, 6, '仓库', `${storageFree}K`, storageUsedPercent, storageFreeColor)
    // }
    // 工厂
    // let line2 = 0.7
    // if (room.controller && room.controller.level >= 8) {
    //   if (room.memory.productData.producing) {
    //     const producing = room.memory.productData.producing
    //     if (producing.num) {
    //       const producingNum = (producing.num || 0)
    //       const producingPercent = (producing.num - producingNum) / producing.num
    //       const producingPercentVisual = Math.min(producingPercent, 1)
    //       labelBar(visual, 8, line2 += 1.1, 1.4, 6, '工厂', `${producing.com} - ${(producingPercent * 100).toFixed(1)}%`, producingPercentVisual, colors.cyan)
    //     }
    //     else {
    //       visual.text(`工厂生产 -> ${producing.com}`, 8, line2 += 1.1, normalTextStyle)
    //     }
    //   }
    //   if (room.memory.ComDispatchData && !_.isEmpty(room.memory.ComDispatchData)) {
    //     const ress = Object.keys(room.memory.ComDispatchData) as ResourceConstant[]
    //     const res = ress[ress.length - 1]
    //     const resData = room.memory.ComDispatchData[res]!
    //     visual.text(`合成规划 ${res} (${resData.dispatch_num})`, 8, line2 += 1.1, normalTextStyle)
    //   }
    // }
    // lab 资源可视化
    if (room.memory.RoomLabBind && Object.keys(room.memory.RoomLabBind).length > 0) {
        for (const i in room.memory.RoomLabBind) {
            const lab = Game.getObjectById(i);
            if (!lab) {
                delete room.memory.RoomLabBind[i];
                if ((_a = room.memory.StructureIdData) === null || _a === void 0 ? void 0 : _a.labs)
                    room.memory.StructureIdData.labs.splice(room.memory.StructureIdData.labs.indexOf(i), 1);
                continue;
            }
            room.visual.text(`${room.memory.RoomLabBind[i].rType}`, lab.pos.x, lab.pos.y, { color: CompoundColor[room.memory.RoomLabBind[i].rType], font: 0.3, align: 'center', strokeWidth: 0.2 });
        }
    }
    if (["Morningtea"].includes(room.controller.owner.username)) {
        for (const creep of room.find(FIND_MY_CREEPS)) {
            creepColor(visual, creep);
        }
    }
}

/* [通用]房间运行主程序 */
const roomRunner = function (room) {
    var _a;
    if (!Memory.RoomControlData[room.name])
        return; // 非框架控制不运行
    if (!((_a = room === null || room === void 0 ? void 0 : room.controller) === null || _a === void 0 ? void 0 : _a.my))
        return;
    var cpu_test = false;
    if (Memory.Systemswitch.Showtestroom) {
        cpu_test = true;
    }
    let cpu_list = [];
    /* 房间核心 */
    if (cpu_test) {
        cpu_list.push(Game.cpu.getUsed());
    }
    room.RoomInit(); // 房间数据初始化
    if (cpu_test) {
        cpu_list.push(Game.cpu.getUsed());
    }
    room.RoomEcosphere(); // 房间状态、布局
    if (cpu_test) {
        cpu_list.push(Game.cpu.getUsed());
    }
    room.SpawnMain(); // 常驻爬虫的孵化管理 [不涉及任务相关爬虫的孵化]
    if (cpu_test) {
        cpu_list.push(Game.cpu.getUsed());
    }
    /* 房间运维 */
    room.MissionManager(); // 任务管理器
    if (cpu_test) {
        cpu_list.push(Game.cpu.getUsed());
    }
    room.SpawnExecution(); // 孵化爬虫
    if (cpu_test) {
        cpu_list.push(Game.cpu.getUsed());
    }
    room.TowerWork(); // 防御塔工作
    if (cpu_test) {
        cpu_list.push(Game.cpu.getUsed());
    }
    room.StructureMission(); // terminal link factory 工作
    if (cpu_test) {
        cpu_list.push(Game.cpu.getUsed());
    }
    ResourceDispatch(room); // 资源调度
    if (cpu_test) {
        cpu_list.push(Game.cpu.getUsed());
    }
    processRoomDataVisual(room); // 房间可视化
    if (cpu_test) {
        cpu_list.push(Game.cpu.getUsed());
    }
    room.LevelMessageUpdate(); // 房间等级Memory信息更新
    if (cpu_test) {
        cpu_list.push(Game.cpu.getUsed());
        console.log(room.name, '初始化' + (cpu_list[1] - cpu_list[0]).toFixed(3), '房间布局' + (cpu_list[2] - cpu_list[1]).toFixed(3), '孵化管理' + (cpu_list[3] - cpu_list[2]).toFixed(3), '任务管理' + (cpu_list[4] - cpu_list[3]).toFixed(3), '孵化爬虫' + (cpu_list[5] - cpu_list[4]).toFixed(3), '防御塔' + (cpu_list[6] - cpu_list[5]).toFixed(3), 'T-L-F' + (cpu_list[7] - cpu_list[6]).toFixed(3), '资源调度' + (cpu_list[8] - cpu_list[7]).toFixed(3), '房间可视' + (cpu_list[9] - cpu_list[8]).toFixed(3), '总计' + (cpu_list[10] - cpu_list[0]).toFixed(3));
    }
};

const creepRunner = function (creep) {
    var _a;
    if (creep.memory.Rerunt) {
        /*指令级别的操作闲置*/
        if (creep.memory.Rerunt > Game.time && !(Game.getObjectById(creep.memory.targetID).effects)) {
            Memory.creepscpu[creep.name] = '';
            return;
        }
        else
            delete creep.memory.Rerunt;
    }
    // 模仿原神角色说话，要求爬命名时必须使用shenli的命名方法
    if (creep.owner.username === 'shenli') {
        if (Math.random() < 0.4)
            creep.sayHi(creep.room.memory.state);
    }
    var cpu_test = false;
    if (Memory.Systemswitch.Showtestcreep) {
        cpu_test = true;
    }
    let cpu_list = [];
    if (cpu_test) {
        cpu_list.push(Game.cpu.getUsed());
    }
    if (creep.spawning) {
        /* 爬虫出生角色可视化 */
        creep.room.visual.text(`${creep.memory.role}`, creep.pos.x, creep.pos.y, { color: '#ffffff', font: 0.5, align: 'center', stroke: '#ff9900' });
    }
    /* 跨shard找回记忆 */
    if (!creep.memory.role) {
        var InshardMemory = global.intershardData;
        if (InshardMemory['creep'][creep.name]) {
            creep.memory = InshardMemory['creep'][creep.name].MemoryData;
            InshardMemory.creep[creep.name].state = 1;
        }
        return;
    }
    if (!RoleData[creep.memory.role])
        return;
    // 自适应体型生产的爬虫执行恢复体型的相关逻辑
    if (!global.Adaption[creep.memory.belong] && creep.memory.adaption) {
        if (creep.store.getUsedCapacity() == 0) {
            let room = Game.rooms[creep.memory.belong];
            if (!room)
                return;
            let bodyData = RoleLevelData[creep.memory.role][room.controller.level].bodypart;
            if (creep.body.length >= bodyData[0] + bodyData[1] + bodyData[2] + bodyData[3] + bodyData[4] + bodyData[5] + bodyData[6] + bodyData[7]) {
                creep.memory.adaption = false;
            }
            if (!creep.memory.adaption) {
                let allSpawnenergy = CalculateEnergy(GenerateAbility(bodyData[0], bodyData[1], bodyData[2], bodyData[3], bodyData[4], bodyData[5], bodyData[6], bodyData[7]));
                if (bodyData && room.energyAvailable >= allSpawnenergy && room.memory.SpawnList && room.memory.SpawnList.length <= 0) {
                    creep.suicide();
                    global.Adaption[creep.memory.belong] = true;
                }
            }
        }
        /* adaption爬虫执行自S */
    }
    if (cpu_test) {
        cpu_list.push(Game.cpu.getUsed());
    }
    /* 非任务类型爬虫 */
    if (RoleData[creep.memory.role].fun) {
        RoleData[creep.memory.role].fun(creep);
    }
    /* 任务类型爬虫 */
    else {
        creep.ManageMisson();
    }
    if (cpu_test) {
        cpu_list.push(Game.cpu.getUsed());
        Memory.creepscpu[creep.name] = (cpu_list[1] - cpu_list[0]).toFixed(3) + "|" + (cpu_list[2] - cpu_list[1]).toFixed(3) + "|" + creep.memory.role;
        if (cpu_list[2] - cpu_list[0] > 0.3) {
            let MissionDataName = '未领取';
            if ((_a = creep.memory.MissionData) === null || _a === void 0 ? void 0 : _a.name) {
                MissionDataName = creep.memory.MissionData.name;
            }
            console.log(creep.name, creep.room.name, '初始化' + (cpu_list[1] - cpu_list[0]).toFixed(3), '任务执行' + (cpu_list[2] - cpu_list[1]).toFixed(3), '总计' + (cpu_list[2] - cpu_list[0]).toFixed(3), creep.memory.role, MissionDataName, creep.memory.working);
        }
    }
};

const powerCreepRunner = function (pc) {
    var cpu_test = false;
    if (Memory.Systemswitch.Showtestpowercreep) {
        cpu_test = true;
    }
    let cpu_list = [];
    if (cpu_test) {
        cpu_list.push(Game.cpu.getUsed());
    }
    if (pc && pc.ticksToLive)
        pc.ManageMisson();
    if (cpu_test) {
        cpu_list.push(Game.cpu.getUsed());
        console.log(pc.name, '总计' + (cpu_list[1] - cpu_list[0]).toFixed(3));
    }
};

/**
 * 统计所有爬虫归属，统计数目 【已测试】
 */
function CreepNumStatistic() {
    if (!global.CreepNumData)
        global.CreepNumData = {};
    for (let roomName in Memory.RoomControlData) {
        if (Game.rooms[roomName] && !global.CreepNumData[roomName])
            global.CreepNumData[roomName] = {};
        if (global.CreepNumData[roomName]) {
            /* 所有角色数量归零 从0开始统计 */
            for (let roleName in global.CreepNumData[roomName])
                global.CreepNumData[roomName][roleName] = 0;
        }
    }
    /* 计算爬虫 */
    let shard = Game.shard.name;
    for (let c in Memory.creeps) {
        let creep_ = Game.creeps[c];
        /* 代表爬虫死亡或进入星门，清除记忆 */
        if (!creep_) {
            // if (Game.rooms[Memory.creeps[c].belong].memory.enemy && Game.rooms[Memory.creeps[c].belong].memory.enemy[c]) {
            //     delete Game.rooms[Memory.creeps[c].belong].memory.enemy[c];
            // }
            delete Memory.creeps[c];
            if (Memory.creepscpu[c]) {
                delete Memory.creepscpu[c];
            }
            //console.log(`爬虫${c}的记忆已被清除！`)
            continue;
        }
        /* 代表爬虫没记忆或刚出星门  */
        if (!creep_.memory.role)
            continue;
        /* 代表爬虫是其他shard的来客 */
        if (creep_.memory.shard != shard)
            continue;
        /* 代表爬虫所属房间已经没了 */
        if (!Game.rooms[creep_.memory.belong])
            continue;
        if (!global.CreepNumData[creep_.memory.belong][creep_.memory.role])
            global.CreepNumData[creep_.memory.belong][creep_.memory.role] = 0;
        /* 添加统计数目 */
        if (["carry", "harvest", "out-car", "manage", "initial_speed"].includes(creep_.memory.role)) {
            if (Object.keys(creep_.body).length * 3 >= creep_.ticksToLive)
                continue;
        }
        global.CreepNumData[creep_.memory.belong][creep_.memory.role] += 1;
    }
    /*进行ob数据超时回收*/
    if (!(Game.time % 100)) {
        for (let _ob in Memory.ObserverList) {
            if (Game.time - 5000 > Memory.ObserverList[_ob]) {
                delete Memory.ObserverList[_ob];
            }
        }
        for (let _ob in Memory.Findrouteroom) {
            if (Game.time - 5000 > Memory.Findrouteroom[_ob].t) {
                delete Memory.Findrouteroom[_ob];
            }
        }
        for (let _creeps in Memory.creepscpu) {
            if (!Game.creeps[_creeps])
                delete Memory.creepscpu[_creeps];
        }
    }
}
const creepRecycleAndStatistic = {
    tickStart: CreepNumStatistic
};

function pixel() {
    let buy = Memory.pixelInfo.buy;
    if (buy.num > 0 && Game.time % (2 * buy.unit) === 0) {
        let buyOrder;
        if (!Game.market.getOrderById(buy.order)) {
            for (let i in Game.market.orders) {
                let order = Game.market.getOrderById(i);
                if (order.resourceType === PIXEL && order.type === ORDER_BUY) {
                    buyOrder = order.id;
                    break;
                }
            }
        }
        else
            buyOrder = buy.order;
        let order = Game.market.getOrderById(buyOrder);
        buy.order = buyOrder;
        if (order) {
            if (order.remainingAmount === 0) {
                let extendAmount = Math.min(buy.unit, buy.num);
                if (Game.market.extendOrder(order.id, extendAmount) === OK) {
                    buy.num -= extendAmount;
                }
            }
            //自动调价
            if (Game.time % (11 * buy.unit) === 0) {
                let highest = Math.max(highestPrice(PIXEL, "buy", buy.price) + 0.001, buy.floor);
                if (highest < buy.price || buy.price < buy.floor) {
                    buy.price = highest;
                    Game.market.changeOrderPrice(order.id, buy.price);
                    console.log(`[Pixel] 像素购入价格变更! 新价格: ${buy.price}`);
                }
            }
        }
    }
    let sell = Memory.pixelInfo.sell;
    if (sell.num > 0 && Game.time % (2 * sell.unit) === 0) {
        let sellOrder;
        if (!Game.market.getOrderById(sell.order)) {
            for (let i in Game.market.orders) {
                let order = Game.market.getOrderById(i);
                if (order.resourceType === PIXEL && order.type === ORDER_SELL) {
                    sellOrder = order.id;
                    break;
                }
            }
        }
        else
            sellOrder = sell.order;
        let order = Game.market.getOrderById(sellOrder);
        sell.order = sellOrder;
        if (order) {
            if (order.remainingAmount === 0) {
                let extendAmount = Math.min(sell.unit, sell.num);
                if (Game.market.extendOrder(order.id, extendAmount) === OK) {
                    sell.num -= extendAmount;
                }
            }
            if (Game.time % (13 * sell.unit) === 0) {
                let lowest = Math.min(lowestPrice(PIXEL, "sell", buy.price * 1.05 / 0.95 * 1.10) - 0.001, sell.ceil); //至少10%利润
                if (sell.price < lowest || sell.price > sell.ceil) {
                    sell.price = lowest;
                    Game.market.changeOrderPrice(order.id, sell.price);
                    console.log(`[Pixel] 像素卖出价格变更! 新价格: ${sell.price}`);
                }
            }
        }
    }
    if (!Game.cpu.generatePixel)
        return;
    if (Game.cpu.bucket >= 10000) {
        if (!Memory.StopPixel) {
            Game.cpu.generatePixel();
        }
    }
}
const pixelManager = {
    tickEnd: pixel
};

var dev = {
    "name": "",
    "shard": "shard0",
    "rcl": 8,
    "buildings": {
        "storage": {
            "pos": [
                { "x": 25, "y": 25 }
            ]
        },
        "tower": {
            "pos": [
                { "x": 25, "y": 24 },
                { "x": 24, "y": 25 },
                { "x": 25, "y": 26 },
                { "x": 27, "y": 23 },
                { "x": 23, "y": 23 },
                { "x": 23, "y": 27 }
            ]
        },
        "spawn": {
            "pos": [
                { "x": 25, "y": 23 },
                { "x": 23, "y": 25 },
                { "x": 25, "y": 27 }
            ]
        },
        "link": {
            "pos": [
                { "x": 26, "y": 25 }
            ]
        },
        "terminal": {
            "pos": [
                { "x": 27, "y": 27 }
            ]
        },
        "powerSpawn": {
            "pos": [
                { "x": 27, "y": 25 }
            ]
        },
        "extension": {
            "pos": [
                { "x": 28, "y": 24 },
                { "x": 28, "y": 23 },
                { "x": 28, "y": 22 },
                { "x": 27, "y": 22 },
                { "x": 26, "y": 22 },
                { "x": 27, "y": 21 },
                { "x": 28, "y": 21 },
                { "x": 29, "y": 22 },
                { "x": 29, "y": 23 },
                { "x": 29, "y": 20 },
                { "x": 30, "y": 21 },
                { "x": 25, "y": 21 },
                { "x": 26, "y": 20 },
                { "x": 25, "y": 20 },
                { "x": 24, "y": 20 },
                { "x": 24, "y": 22 },
                { "x": 23, "y": 21 },
                { "x": 22, "y": 21 },
                { "x": 22, "y": 22 },
                { "x": 23, "y": 22 },
                { "x": 22, "y": 23 },
                { "x": 22, "y": 24 },
                { "x": 21, "y": 23 },
                { "x": 21, "y": 22 },
                { "x": 20, "y": 21 },
                { "x": 21, "y": 20 },
                { "x": 22, "y": 19 },
                { "x": 23, "y": 19 },
                { "x": 19, "y": 22 },
                { "x": 19, "y": 23 },
                { "x": 20, "y": 24 },
                { "x": 20, "y": 25 },
                { "x": 20, "y": 26 },
                { "x": 21, "y": 25 },
                { "x": 19, "y": 27 },
                { "x": 19, "y": 28 },
                { "x": 31, "y": 22 },
                { "x": 31, "y": 23 },
                { "x": 30, "y": 24 },
                { "x": 30, "y": 25 },
                { "x": 29, "y": 25 },
                { "x": 21, "y": 27 },
                { "x": 21, "y": 28 },
                { "x": 22, "y": 27 },
                { "x": 22, "y": 26 },
                { "x": 22, "y": 28 },
                { "x": 22, "y": 29 },
                { "x": 23, "y": 29 },
                { "x": 23, "y": 28 },
                { "x": 24, "y": 28 },
                { "x": 20, "y": 29 },
                { "x": 21, "y": 30 },
                { "x": 22, "y": 31 },
                { "x": 23, "y": 31 },
                { "x": 25, "y": 30 },
                { "x": 26, "y": 31 },
                { "x": 24, "y": 30 },
                { "x": 25, "y": 29 },
                { "x": 28, "y": 19 },
                { "x": 27, "y": 19 }
            ]
        },
        "factory": {
            "pos": [
                { "x": 26, "y": 28 }
            ]
        },
        "nuker": {
            "pos": [
                { "x": 28, "y": 26 }
            ]
        },
        "road": {
            "pos": [
                { "x": 24, "y": 27 },
                { "x": 23, "y": 26 },
                { "x": 25, "y": 28 },
                { "x": 26, "y": 27 },
                { "x": 27, "y": 26 },
                { "x": 28, "y": 25 },
                { "x": 27, "y": 24 },
                { "x": 26, "y": 23 },
                { "x": 25, "y": 22 },
                { "x": 24, "y": 23 },
                { "x": 23, "y": 24 },
                { "x": 22, "y": 25 },
                { "x": 24, "y": 26 },
                { "x": 24, "y": 24 },
                { "x": 26, "y": 24 },
                { "x": 26, "y": 26 },
                { "x": 24, "y": 29 },
                { "x": 23, "y": 30 },
                { "x": 22, "y": 30 },
                { "x": 21, "y": 29 },
                { "x": 20, "y": 28 },
                { "x": 20, "y": 27 },
                { "x": 21, "y": 26 },
                { "x": 21, "y": 24 },
                { "x": 20, "y": 23 },
                { "x": 19, "y": 24 },
                { "x": 19, "y": 25 },
                { "x": 19, "y": 26 },
                { "x": 20, "y": 22 },
                { "x": 21, "y": 21 },
                { "x": 22, "y": 20 },
                { "x": 23, "y": 20 },
                { "x": 24, "y": 21 },
                { "x": 26, "y": 21 },
                { "x": 27, "y": 20 },
                { "x": 28, "y": 20 },
                { "x": 29, "y": 21 },
                { "x": 30, "y": 22 },
                { "x": 30, "y": 23 },
                { "x": 29, "y": 24 },
                { "x": 26, "y": 29 },
                { "x": 26, "y": 30 },
                { "x": 27, "y": 28 },
                { "x": 28, "y": 28 },
                { "x": 29, "y": 29 },
                { "x": 30, "y": 30 },
                { "x": 28, "y": 27 },
                { "x": 29, "y": 26 },
                { "x": 30, "y": 26 },
                { "x": 31, "y": 27 },
                { "x": 31, "y": 28 },
                { "x": 31, "y": 29 },
                { "x": 29, "y": 31 },
                { "x": 28, "y": 31 },
                { "x": 27, "y": 31 },
                { "x": 25, "y": 31 },
                { "x": 24, "y": 31 },
                { "x": 24, "y": 19 },
                { "x": 25, "y": 19 },
                { "x": 26, "y": 19 },
                { "x": 31, "y": 24 },
                { "x": 31, "y": 25 }
            ]
        },
        "observer": {
            "pos": [
                { "x": 31, "y": 26 }
            ]
        },
        "lab": {
            "pos": [
                { "x": 29, "y": 27 },
                { "x": 30, "y": 27 },
                { "x": 30, "y": 28 },
                { "x": 29, "y": 28 },
                { "x": 30, "y": 29 },
                { "x": 29, "y": 30 },
                { "x": 28, "y": 29 },
                { "x": 28, "y": 30 },
                { "x": 27, "y": 30 },
                { "x": 27, "y": 29 }
            ]
        }
    }
};

var hoho = {
    "name": "",
    "shard": "shard0",
    "rcl": 8,
    "buildings": {
        "storage": {
            "pos": [
                { "x": 25, "y": 24 }
            ]
        },
        "tower": {
            "pos": [
                { 'x': 23, 'y': 24 },
                { "x": 25, "y": 23 },
                { "x": 27, "y": 24 },
                { "x": 27, "y": 26 },
                { "x": 23, "y": 26 },
                { "x": 25, "y": 27 }
            ]
        },
        "spawn": {
            "pos": [
                { "x": 22, "y": 23 },
                { "x": 23, "y": 22 },
                { "x": 27, "y": 22 }
            ]
        },
        "link": {
            "pos": [
                { "x": 24, "y": 25 }
            ]
        },
        "terminal": {
            "pos": [
                { "x": 26, "y": 25 }
            ]
        },
        "powerSpawn": {
            "pos": [
                { "x": 28, "y": 23 }
            ]
        },
        "extension": {
            "pos": [
                { 'x': 21, 'y': 22 },
                { 'x': 22, 'y': 21 },
                { 'x': 20, 'y': 21 },
                { 'x': 20, 'y': 22 },
                { 'x': 20, 'y': 23 },
                { 'x': 21, 'y': 20 },
                { 'x': 22, 'y': 20 },
                { 'x': 23, 'y': 20 },
                { 'x': 24, 'y': 21 },
                { 'x': 24, 'y': 22 },
                { 'x': 22, 'y': 24 },
                { 'x': 21, 'y': 24 },
                { 'x': 26, 'y': 21 },
                { 'x': 26, 'y': 22 },
                { 'x': 28, 'y': 21 },
                { 'x': 29, 'y': 22 },
                { 'x': 27, 'y': 20 },
                { 'x': 28, 'y': 20 },
                { 'x': 29, 'y': 20 },
                { 'x': 30, 'y': 21 },
                { 'x': 30, 'y': 22 },
                { 'x': 30, 'y': 23 },
                { 'x': 29, 'y': 24 },
                { 'x': 28, 'y': 24 },
                { 'x': 22, 'y': 26 },
                { 'x': 21, 'y': 26 },
                { 'x': 22, 'y': 27 },
                { 'x': 21, 'y': 28 },
                { 'x': 22, 'y': 29 },
                { 'x': 23, 'y': 28 },
                { 'x': 20, 'y': 27 },
                { 'x': 20, 'y': 28 },
                { 'x': 20, 'y': 29 },
                { 'x': 21, 'y': 30 },
                { 'x': 22, 'y': 30 },
                { 'x': 23, 'y': 30 },
                { 'x': 24, 'y': 28 },
                { 'x': 24, 'y': 29 },
                { 'x': 28, 'y': 26 },
                { 'x': 29, 'y': 26 },
                { 'x': 30, 'y': 26 },
                { 'x': 30, 'y': 24 },
                { 'x': 30, 'y': 20 },
                { 'x': 26, 'y': 20 },
                { 'x': 20, 'y': 20 },
                { 'x': 20, 'y': 24 },
                { 'x': 20, 'y': 26 },
                { 'x': 24, 'y': 30 },
                { 'x': 24, 'y': 20 },
                { 'x': 26, 'y': 28 },
                { 'x': 26, 'y': 29 },
                { 'x': 26, 'y': 30 }
            ]
        },
        "factory": {
            "pos": [
                { "x": 25, "y": 26 }
            ]
        },
        "nuker": {
            "pos": [
                { "x": 20, "y": 30 }
            ]
        },
        "road": {
            "pos": [
                { 'x': 24, 'y': 23 },
                { 'x': 24, 'y': 24 },
                { 'x': 23, 'y': 23 },
                { 'x': 22, 'y': 22 },
                { 'x': 23, 'y': 21 },
                { 'x': 21, 'y': 23 },
                { 'x': 21, 'y': 21 },
                { 'x': 25, 'y': 22 },
                { 'x': 26, 'y': 23 },
                { 'x': 27, 'y': 23 },
                { 'x': 28, 'y': 22 },
                { 'x': 27, 'y': 21 },
                { 'x': 29, 'y': 21 },
                { 'x': 29, 'y': 23 },
                { 'x': 23, 'y': 25 },
                { 'x': 24, 'y': 26 },
                { 'x': 24, 'y': 27 },
                { 'x': 23, 'y': 27 },
                { 'x': 22, 'y': 28 },
                { 'x': 21, 'y': 27 },
                { 'x': 25, 'y': 25 },
                { 'x': 26, 'y': 24 },
                { 'x': 27, 'y': 25 },
                { 'x': 26, 'y': 26 },
                { 'x': 26, 'y': 27 },
                { 'x': 25, 'y': 28 },
                { 'x': 28, 'y': 25 },
                { 'x': 27, 'y': 27 },
                { 'x': 28, 'y': 28 },
                { 'x': 29, 'y': 29 },
                { 'x': 21, 'y': 29 },
                { 'x': 23, 'y': 29 },
                { 'x': 29, 'y': 25 },
                { 'x': 22, 'y': 25 },
                { 'x': 21, 'y': 25 },
                { 'x': 29, 'y': 27 },
                { 'x': 25, 'y': 29 },
                { 'x': 25, 'y': 21 }
            ]
        },
        "observer": {
            "pos": [
                { "x": 27, "y": 30 }
            ]
        },
        "lab": {
            "pos": [
                { 'x': 29, 'y': 28 },
                { 'x': 28, 'y': 29 },
                { 'x': 27, 'y': 28 },
                { 'x': 28, 'y': 27 },
                { 'x': 27, 'y': 29 },
                { 'x': 28, 'y': 30 },
                { 'x': 30, 'y': 27 },
                { 'x': 30, 'y': 29 },
                { 'x': 30, 'y': 28 },
                { 'x': 29, 'y': 30 },
            ]
        }
    }
};

var tea = {
    "name": "",
    "shard": "shard0",
    "rcl": 8,
    "buildings": {
        "storage": {
            "pos": [
                { "x": 26, "y": 24 }
            ]
        },
        "tower": {
            "pos": [
                { "x": 22, "y": 27 },
                { "x": 28, "y": 23 },
                { "x": 23, "y": 28 },
                { "x": 27, "y": 22 },
                { "x": 22, "y": 23 },
                { "x": 23, "y": 22 } //lvl 8
            ]
        },
        "spawn": {
            "pos": [
                { "x": 20, "y": 25 },
                { "x": 30, "y": 25 },
                { "x": 25, "y": 30 }
            ]
        },
        "link": {
            "pos": [
                { "x": 24, "y": 26 }
            ]
        },
        "terminal": {
            "pos": [
                { "x": 26, "y": 26 }
            ]
        },
        "powerSpawn": {
            "pos": [
                { "x": 25, "y": 23 }
            ]
        },
        "extension": {
            "pos": [
                { "x": 23, "y": 25 },
                { "x": 22, "y": 26 },
                { "x": 23, "y": 27 },
                { "x": 21, "y": 27 },
                { "x": 21, "y": 28 },
                { "x": 22, "y": 29 },
                { "x": 23, "y": 29 },
                { "x": 22, "y": 28 },
                { "x": 24, "y": 28 },
                { "x": 21, "y": 25 },
                { "x": 22, "y": 24 },
                { "x": 21, "y": 23 },
                { "x": 23, "y": 23 },
                { "x": 21, "y": 22 },
                { "x": 22, "y": 22 },
                { "x": 24, "y": 22 },
                { "x": 22, "y": 21 },
                { "x": 23, "y": 21 },
                { "x": 20, "y": 26 },
                { "x": 20, "y": 24 },
                { "x": 25, "y": 21 },
                { "x": 26, "y": 22 },
                { "x": 28, "y": 22 },
                { "x": 27, "y": 21 },
                { "x": 28, "y": 21 },
                { "x": 29, "y": 22 },
                { "x": 29, "y": 23 },
                { "x": 27, "y": 23 },
                { "x": 28, "y": 24 },
                { "x": 27, "y": 25 },
                { "x": 28, "y": 26 },
                { "x": 26, "y": 28 },
                { "x": 26, "y": 20 },
                { "x": 24, "y": 20 },
                { "x": 23, "y": 19 },
                { "x": 22, "y": 19 },
                { "x": 21, "y": 20 },
                { "x": 20, "y": 21 },
                { "x": 19, "y": 22 },
                { "x": 19, "y": 23 },
                { "x": 27, "y": 19 },
                { "x": 28, "y": 19 },
                { "x": 29, "y": 20 },
                { "x": 30, "y": 21 },
                { "x": 31, "y": 22 },
                { "x": 19, "y": 27 },
                { "x": 19, "y": 28 },
                { "x": 20, "y": 29 },
                { "x": 21, "y": 30 },
                { "x": 22, "y": 31 },
                { "x": 23, "y": 31 },
                { "x": 24, "y": 30 },
                { "x": 25, "y": 29 },
                { "x": 26, "y": 30 },
                { "x": 27, "y": 31 },
                { "x": 31, "y": 23 },
                { "x": 30, "y": 24 },
                { "x": 29, "y": 25 },
                { "x": 30, "y": 26 },
                { "x": 31, "y": 27 } //lvl 8
            ]
        },
        "factory": {
            "pos": [
                { "x": 24, "y": 24 }
            ]
        },
        "nuker": {
            "pos": [
                { "x": 25, "y": 20 }
            ]
        },
        "road": {
            "pos": [
                { "x": 22, "y": 25 },
                { "x": 21, "y": 26 },
                { "x": 20, "y": 27 },
                { "x": 20, "y": 28 },
                { "x": 21, "y": 29 },
                { "x": 22, "y": 30 },
                { "x": 23, "y": 30 },
                { "x": 24, "y": 29 },
                { "x": 25, "y": 28 },
                { "x": 24, "y": 27 },
                { "x": 23, "y": 26 },
                { "x": 21, "y": 24 },
                { "x": 20, "y": 23 },
                { "x": 20, "y": 22 },
                { "x": 21, "y": 21 },
                { "x": 22, "y": 20 },
                { "x": 23, "y": 20 },
                { "x": 24, "y": 21 },
                { "x": 25, "y": 22 },
                { "x": 24, "y": 23 },
                { "x": 23, "y": 24 },
                { "x": 25, "y": 24 },
                { "x": 25, "y": 26 },
                { "x": 24, "y": 25 },
                { "x": 26, "y": 21 },
                { "x": 27, "y": 20 },
                { "x": 28, "y": 20 },
                { "x": 29, "y": 21 },
                { "x": 30, "y": 22 },
                { "x": 30, "y": 23 },
                { "x": 29, "y": 24 },
                { "x": 28, "y": 25 },
                { "x": 27, "y": 24 },
                { "x": 26, "y": 23 },
                { "x": 26, "y": 25 },
                { "x": 27, "y": 26 },
                { "x": 26, "y": 27 },
                { "x": 29, "y": 26 },
                { "x": 30, "y": 27 },
                { "x": 31, "y": 28 },
                { "x": 31, "y": 29 },
                { "x": 27, "y": 27 },
                { "x": 28, "y": 28 },
                { "x": 29, "y": 29 },
                { "x": 30, "y": 30 },
                { "x": 26, "y": 29 },
                { "x": 27, "y": 30 },
                { "x": 28, "y": 31 },
                { "x": 29, "y": 31 } //lvl 6
            ]
        },
        "observer": {
            "pos": [
                { "x": 25, "y": 27 }
            ]
        },
        "lab": {
            "pos": [
                { "x": 27, "y": 28 },
                { "x": 27, "y": 29 },
                { "x": 28, "y": 29 },
                { "x": 28, "y": 27 },
                { "x": 29, "y": 27 },
                { "x": 29, "y": 28 },
                { "x": 28, "y": 30 },
                { "x": 29, "y": 30 },
                { "x": 30, "y": 29 },
                { "x": 30, "y": 28 } //lvl 8
            ]
        }
    }
};

const colors = {
    gray: '#555555',
    light: '#AAAAAA',
    road: '#666',
    energy: '#FFE87B',
    power: '#F53547',
    dark: '#181818',
    outline: '#8FBB93',
    speechText: '#000000',
    speechBackground: '#2ccf3b'
};
const dirs = [
    [],
    [0, -1],
    [1, -1],
    [1, 0],
    [1, 1],
    [0, 1],
    [-1, 1],
    [-1, 0],
    [-1, -1]
];
function relPoly(x, y, poly) {
    return poly.map(p => {
        p[0] += x;
        p[1] += y;
        return p;
    });
}
class RoomVisual$1 extends RoomVisual {
    connRoads(opts = {}) {
        let color = opts.color || colors.road || 'white';
        if (!this.roads)
            return;
        this.roads.forEach(r => {
            for (let i = 1; i <= 4; i++) {
                let d = dirs[i];
                let c = [r[0] + d[0], r[1] + d[1]];
                let rd = _.some(this.roads, r => r[0] == c[0] && r[1] == c[1]);
                if (rd) {
                    this.line(r[0], r[1], c[0], c[1], {
                        color: color,
                        width: 0.35,
                        opacity: opts.opacity || 0.35
                    });
                }
            }
        });
        return this;
    }
    structure(x, y, type, opts) {
        opts = Object.assign({
            opacity: 0.2
        }, opts);
        switch (type) {
            case STRUCTURE_RAMPART:
                this.rect(x - 0.5, y - 0.5, 1, 1, {
                    fill: '#434C43',
                    stroke: '#5D735F',
                    strokeWidth: 0.10,
                    opacity: opts.opacity
                });
                break;
            case STRUCTURE_LINK:
                let outer = [
                    [0.0, -0.5],
                    [0.4, 0.0],
                    [0.0, 0.5],
                    [-0.4, 0.0]
                ];
                let inner = [
                    [0.0, -0.3],
                    [0.25, 0.0],
                    [0.0, 0.3],
                    [-0.25, 0.0]
                ];
                outer = relPoly(x, y, outer);
                inner = relPoly(x, y, inner);
                outer.push(outer[0]);
                inner.push(inner[0]);
                this.poly(outer, {
                    fill: colors.dark,
                    stroke: colors.outline,
                    strokeWidth: 0.05,
                    opacity: opts.opacity
                });
                this.poly(inner, {
                    fill: colors.gray,
                    opacity: opts.opacity
                });
                break;
            case STRUCTURE_EXTENSION:
                this.circle(x, y, {
                    radius: 0.5,
                    fill: colors.dark,
                    stroke: colors.outline,
                    strokeWidth: 0.05,
                    opacity: opts.opacity
                });
                this.circle(x, y, {
                    radius: 0.35,
                    fill: colors.gray,
                    opacity: opts.opacity
                });
                break;
            case STRUCTURE_TOWER:
                this.circle(x, y, {
                    radius: 0.6,
                    fill: colors.dark,
                    stroke: colors.outline,
                    strokeWidth: 0.05,
                    opacity: opts.opacity
                });
                this.rect(x - 0.4, y - 0.3, 0.8, 0.6, {
                    fill: colors.gray,
                    opacity: opts.opacity
                });
                this.rect(x - 0.2, y - 0.9, 0.4, 0.5, {
                    fill: colors.light,
                    stroke: colors.dark,
                    strokeWidth: 0.07,
                    opacity: opts.opacity
                });
                break;
            case STRUCTURE_ROAD:
                this.circle(x, y, {
                    radius: 0.175,
                    fill: colors.road,
                    opacity: opts.opacity
                });
                if (!this.roads)
                    this.roads = [];
                this.roads.push([x, y]);
                break;
            case STRUCTURE_STORAGE:
                let outline1 = relPoly(x, y, [
                    [-0.45, -0.55],
                    [0, -0.65],
                    [0.45, -0.55],
                    [0.55, 0],
                    [0.45, 0.55],
                    [0, 0.65],
                    [-0.45, 0.55],
                    [-0.55, 0],
                    [-0.45, -0.55],
                ]);
                this.poly(outline1, {
                    stroke: colors.outline,
                    strokeWidth: 0.05,
                    fill: colors.dark,
                    opacity: opts.opacity
                });
                this.rect(x - 0.35, y - 0.45, 0.7, 0.9, {
                    fill: colors.energy,
                    opacity: opts.opacity,
                });
                break;
            case STRUCTURE_SPAWN:
                this.circle(x, y, {
                    radius: 0.65,
                    fill: colors.dark,
                    stroke: '#CCCCCC',
                    strokeWidth: 0.10,
                    opacity: opts.opacity
                });
                this.circle(x, y, {
                    radius: 0.40,
                    fill: colors.energy,
                    opacity: opts.opacity
                });
                break;
            case STRUCTURE_TERMINAL:
                {
                    let outer = [
                        [0.0, -0.8],
                        [0.55, -0.55],
                        [0.8, 0.0],
                        [0.55, 0.55],
                        [0.0, 0.8],
                        [-0.55, 0.55],
                        [-0.8, 0.0],
                        [-0.55, -0.55],
                    ];
                    let inner = [
                        [0.0, -0.65],
                        [0.45, -0.45],
                        [0.65, 0.0],
                        [0.45, 0.45],
                        [0.0, 0.65],
                        [-0.45, 0.45],
                        [-0.65, 0.0],
                        [-0.45, -0.45],
                    ];
                    outer = relPoly(x, y, outer);
                    inner = relPoly(x, y, inner);
                    outer.push(outer[0]);
                    inner.push(inner[0]);
                    this.poly(outer, {
                        fill: colors.dark,
                        stroke: colors.outline,
                        strokeWidth: 0.05,
                        opacity: opts.opacity
                    });
                    this.poly(inner, {
                        fill: colors.light,
                        opacity: opts.opacity
                    });
                    this.rect(x - 0.45, y - 0.45, 0.9, 0.9, {
                        fill: colors.gray,
                        stroke: colors.dark,
                        strokeWidth: 0.1,
                        opacity: opts.opacity
                    });
                    break;
                }
            case STRUCTURE_LAB:
                this.circle(x, y - 0.025, {
                    radius: 0.55,
                    fill: colors.dark,
                    stroke: colors.outline,
                    strokeWidth: 0.05,
                    opacity: opts.opacity
                });
                this.circle(x, y - 0.025, {
                    radius: 0.40,
                    fill: colors.gray,
                    opacity: opts.opacity
                });
                this.rect(x - 0.45, y + 0.3, 0.9, 0.25, {
                    fill: colors.dark,
                    opacity: opts.opacity
                });
                {
                    let box = [
                        [-0.45, 0.3],
                        [-0.45, 0.55],
                        [0.45, 0.55],
                        [0.45, 0.3],
                    ];
                    box = relPoly(x, y, box);
                    this.poly(box, {
                        stroke: colors.outline,
                        strokeWidth: 0.05,
                        opacity: opts.opacity
                    });
                }
                break;
            case STRUCTURE_POWER_SPAWN:
                this.circle(x, y, {
                    radius: 0.65,
                    fill: colors.dark,
                    stroke: colors.power,
                    strokeWidth: 0.10,
                    opacity: opts.opacity
                });
                this.circle(x, y, {
                    radius: 0.40,
                    fill: colors.energy,
                    opacity: opts.opacity
                });
                break;
            case STRUCTURE_OBSERVER:
                this.circle(x, y, {
                    fill: colors.dark,
                    radius: 0.45,
                    stroke: colors.outline,
                    strokeWidth: 0.05,
                    opacity: opts.opacity
                });
                this.circle(x + 0.225, y, {
                    fill: colors.outline,
                    radius: 0.20,
                    opacity: opts.opacity
                });
                break;
            case STRUCTURE_NUKER:
                let outline = [
                    [0, -1],
                    [-0.47, 0.2],
                    [-0.5, 0.5],
                    [0.5, 0.5],
                    [0.47, 0.2],
                    [0, -1],
                ];
                outline = relPoly(x, y, outline);
                this.poly(outline, {
                    stroke: colors.outline,
                    strokeWidth: 0.05,
                    fill: colors.dark,
                    opacity: opts.opacity
                });
                let inline = [
                    [0, -.80],
                    [-0.40, 0.2],
                    [0.40, 0.2],
                    [0, -.80],
                ];
                inline = relPoly(x, y, inline);
                this.poly(inline, {
                    stroke: colors.outline,
                    strokeWidth: 0.01,
                    fill: colors.gray,
                    opacity: opts.opacity
                });
                break;
            default:
                this.circle(x, y, {
                    fill: 'red'
                });
                break;
        }
    }
}

const drawByConfig = function (str) {
    let data;
    let xx;
    let yy;
    if (str == 'LayoutVisualDev') {
        xx = -25;
        yy = -25;
        data = dev;
    }
    if (str == 'LayoutVisualHoho') {
        xx = -25;
        yy = -25;
        data = hoho;
    }
    if (str == 'LayoutVisualTea') {
        xx = -25;
        yy = -25;
        data = tea;
    }
    let flag = Game.flags[str];
    if (!flag) {
        return;
    }
    let roomName = flag.pos.roomName;
    let terrian = new Room.Terrain(roomName);
    let rv = new RoomVisual$1(roomName);
    //    let poss = data.buildings['extension']['pos'];
    for (let type in data.buildings) {
        let poss = data.buildings[type]['pos'];
        for (let pos of poss) {
            let x = pos.x + xx + flag.pos.x;
            let y = pos.y + yy + flag.pos.y;
            try {
                if (terrian.get(x, y) != TERRAIN_MASK_WALL)
                    rv.structure(x, y, type);
            }
            catch (e) {
                log('err:' + x + "," + y + ',' + type);
                throw e;
            }
        }
    }
    // 墙
    let pos = flag.pos;
    for (let i = pos.x - 9; i < pos.x + 10; i++)
        for (let j = pos.y - 9; j < pos.y + 10; j++) {
            if (!isInArray([0, 1, 48, 49], i) && !isInArray([0, 1, 48, 49], j) && (Math.abs(i - pos.x) == 9 || Math.abs(j - pos.y) == 9) && terrian.get(i, j) != TERRAIN_MASK_WALL)
                rv.structure(i, j, STRUCTURE_RAMPART);
        }
    rv.connRoads();
};
function log(str, color = 'white') {
    console.log(`<span style="color:${color}">${str}</span>`);
}

// let autoPlannerdu = require('autoPlannerdu');
let autoPlanner63 = require('autoPlanner63');
function layoutVisual() {
    var _a;
    for (let name of ['LayoutVisualDev', 'LayoutVisual63', 'LayoutVisualHoho', 'LayoutVisualTea', 'LayoutVisualdu']) {
        let flag = Game.flags[name];
        if (flag) {
            switch (name) {
                case 'LayoutVisualDev':
                    drawByConfig(flag.name);
                    break;
                case 'LayoutVisualHoho':
                    drawByConfig(flag.name);
                    break;
                case 'LayoutVisualTea':
                    drawByConfig(flag.name);
                    break;
                case 'LayoutVisual63':
                    /* storagePos 可以手动定位中心点 */
                    var p = Game.flags.p;
                    var pa = Game.flags.pa;
                    var pb = Game.flags.pb;
                    var pc = Game.flags.pc;
                    var pm = Game.flags.pm;
                    if (p) {
                        global.roomStructsData = autoPlanner63.ManagerPlanner.computeManor(p.pos.roomName, [pc, pm, pa, pb]);
                        Game.flags.p.remove();
                        global.roomStructsData.structMaplv = []; /*进行数据清空的操作*/
                    }
                    if (global.roomStructsData) {
                        if (Game.flags._dayin) {
                            console.log(JSON.stringify(global.roomStructsData));
                            Game.flags._dayin.remove();
                        }
                        let ret = {
                            structMap: global.roomStructsData.structMap
                        };
                        let _add_lv_state = false;
                        if (global.roomStructsData.structMaplv.length < 1) {
                            _add_lv_state = true;
                        }
                        for (let level = 1; level <= 8; level++) {
                            for (let type in CONTROLLER_STRUCTURES) {
                                let lim = CONTROLLER_STRUCTURES[type];
                                switch (type) {
                                    case 'road':
                                        if (level == 4) {
                                            for (let i = 0; i < ret.structMap[type].length; i++) {
                                                let e = ret.structMap[type][i];
                                                if (_add_lv_state) {
                                                    global.roomStructsData.structMaplv.push(`${e[0]}/${e[1]}/${type}/${level}`);
                                                }
                                                new RoomVisual(flag.pos.roomName).text(level.toString(), e[0] + 0.3, e[1] + 0.5, { font: 0.4, opacity: 0.8 });
                                            }
                                        }
                                        break;
                                    case 'link':
                                        if (level == 5) {
                                            let link_c = ret.structMap[type][ret.structMap[type].length - 1];
                                            if (_add_lv_state) {
                                                global.roomStructsData.structMaplv.push(`${link_c[0]}/${link_c[1]}/${type}/${level}`);
                                            }
                                            new RoomVisual(flag.pos.roomName).text(level.toString(), link_c[0] + 0.3, link_c[1] + 0.5, { font: 0.4, opacity: 0.8 });
                                        }
                                        break;
                                    case 'container':
                                        break;
                                    default:
                                        for (let i = lim[level - 1]; i < Math.min(ret.structMap[type].length, lim[level]); i++) {
                                            let e = ret.structMap[type][i];
                                            if (type != 'rampart') {
                                                if (_add_lv_state) {
                                                    global.roomStructsData.structMaplv.push(`${e[0]}/${e[1]}/${type}/${level}`);
                                                }
                                                // {x: -4, y: -3,structureType:'extension',level:2}
                                                new RoomVisual(flag.pos.roomName).text(level.toString(), e[0] + 0.3, e[1] + 0.5, { font: 0.4, opacity: 0.8 });
                                            }
                                        }
                                        break;
                                }
                            }
                        }
                        if (Game.flags.savestructMap && ((_a = global.roomStructsData) === null || _a === void 0 ? void 0 : _a.structMaplv)) {
                            if (Memory.RoomControlData[flag.pos.roomName]) {
                                Memory.RoomControlData[flag.pos.roomName].structMap = global.roomStructsData.structMaplv;
                                Game.flags.savestructMap.remove();
                                console.log(`[LayoutVisual63] 房间${flag.pos.roomName}63布局已经刷新`);
                            }
                        }
                        //这个有点消耗cpu 不看的时候记得关
                        autoPlanner63.HelperVisual.showRoomStructures(global.roomStructsData.roomName, global.roomStructsData.structMap);
                    }
                    break;
            }
        }
    }
}
const layoutVisualMoudle = {
    tickEnd: layoutVisual
};

/* 常量文件 */
/**
 *
 * 爬虫位置用箭头表示，左上的爬虫：↖, 右上的爬虫：↗, 依此类推...
 *
 */
/* RoomPosition相对位置文字映射 (相对左上角的爬的位置 [x,y]) */
const SquadPos = {
    '↖': [0, 0],
    '↗': [1, 0],
    '↙': [0, 1],
    '↘': [1, 1]
};
/* move常量文字映射 */
const SquadDirection = {
    '↖': 8,
    '↗': 2,
    '↙': 6,
    '↘': 4,
    '↓': 5,
    '↑': 1,
    '←': 7,
    '→': 3
};
/* 房间出口方向文字-常量映射 */
({
    '↑': FIND_EXIT_TOP,
    '↓': FIND_EXIT_BOTTOM,
    '←': FIND_EXIT_LEFT,
    '→': FIND_EXIT_RIGHT
});
/* 爬虫执行战术动作后的记忆更改常量 以cross战术动作举例，原来左上爬虫的记忆为↖，交叉后更改为↘ */
const tactical = {
    cross: { '↖': '↘', '↗': '↙', '↙': '↗', '↘': '↖' },
    right: { '↖': '↗', '↗': '↘', '↘': '↙', '↙': '↖' },
    left: { '↗': '↖', '↘': '↗', '↙': '↘', '↖': '↙' },
};
/* 顺时针旋转(右转)移动常量  爬虫位置：爬虫移动方向 */
const rightConst = {
    '↖': '→',
    '↗': '↓',
    '↙': '↑',
    '↘': '←'
};
/* 逆时针旋转(左转)移动常量 爬虫位置：爬虫移动方向 */
const leftConst = {
    '↖': '↓',
    '↗': '←',
    '↙': '→',
    '↘': '↑'
};
/* 交叉移动常量 爬虫位置：爬虫移动方向 */
const crossConst = {
    '↖': '↘',
    '↗': '↙',
    '↙': '↗',
    '↘': '↖'
};

/* 四人小队状态判断函数 */
/* 小队中寻路的角色是左上角的爬，这个函数用来获取左上角的爬 */
function getStandCreep(Squad) {
    for (var i in Squad) {
        var thisCreep = Game.creeps[i];
        if (!thisCreep)
            continue;
        if (Squad[i].position == '↖')
            return thisCreep;
    }
    return null;
}
/* 获取小队阵型的左上角位置 (在小队成员不完整的情况下，依然能获取坐标) */
function getStandPos(squadData) {
    for (var i in squadData) {
        if (Game.creeps[i]) {
            if (squadData[i].position == '↖') {
                return Game.creeps[i].pos;
            }
        }
    }
    for (var i in squadData) {
        if (Game.creeps[i]) {
            if (squadData[i].position == '↖') {
                return Game.creeps[i].pos;
            }
            else if (squadData[i].position == '↗') {
                let thisPos = Game.creeps[i].pos;
                if (thisPos.x == 0) {
                    continue; // 不由该爬虫获取
                }
                return new RoomPosition(thisPos.x - 1, thisPos.y, thisPos.roomName);
            }
            else if (squadData[i].position == '↘') {
                let thisPos = Game.creeps[i].pos;
                if (thisPos.y == 0 || thisPos.x == 0) {
                    continue; // 不由该爬虫获取
                }
                return new RoomPosition(thisPos.x - 1, thisPos.y - 1, thisPos.roomName);
            }
            else if (squadData[i].position == '↙') {
                let thisPos = Game.creeps[i].pos;
                if (thisPos.y == 0) {
                    continue; // 不由该爬虫获取
                }
                return new RoomPosition(thisPos.x, thisPos.y - 1, thisPos.roomName);
            }
        }
    }
    return null;
}
/* 获取四人小队中指定位置爬的坐标 需要爬在2-48坐标范围内，太靠近边界无法使用 */
function SquadGetRoomPosition(Squad, pos) {
    let standPos = getStandPos(Squad);
    if (!standPos)
        return null;
    if (standPos.x > 48 || standPos.y > 48)
        return null;
    return new RoomPosition(standPos.x + SquadPos[pos][0], standPos.y + SquadPos[pos][1], standPos.roomName);
}
/* 获取小队中指定位置的爬 */
function SquadGetPosCreep(SquadData, pos) {
    for (var i in SquadData) {
        if (!Game.creeps[i])
            continue;
        else {
            if (SquadData[i].position == pos)
                return Game.creeps[i];
        }
    }
    return null;
}
/* 判断小队是否已经集结到位  true 到位 false 未到位 */
function SquadReady(SquadData) {
    var standPos = getStandPos(SquadData);
    if (!standPos)
        return true; // 如果集结爬死了，说明小队不需要再集结了，返回true方便其他爬执行其他事情
    var thisRoom = standPos.roomName;
    for (var cName in SquadData) {
        var disPos = SquadGetRoomPosition(SquadData, SquadData[cName].position);
        if (!Game.creeps[cName])
            continue;
        if ((Game.creeps[cName].room.name == thisRoom && disPos && !Game.creeps[cName].pos.isEqualTo(disPos)))
            return false;
    }
    return true;
}
/* 判断小队所有爬虫是否已经到了目标房间 */
function SquadArrivedRoom(SquadData, disRoom) {
    for (var cName in SquadData) {
        if (!Game.creeps[cName])
            continue;
        if (Game.creeps[cName].room.name != disRoom)
            return false;
    }
    return true;
}
/* 获取小队治疗爬朝向 */
function SquadHealDirection(SquadData) {
    var directionList = [];
    for (var cName in SquadData) {
        if (!Game.creeps[cName])
            return null;
        if (Game.creeps[cName].memory.creepType == 'heal')
            directionList.push(SquadData[cName].position);
    }
    if (isInArray(directionList, '↖') && isInArray(directionList, '↗'))
        return '↑';
    else if (isInArray(directionList, '↘') && isInArray(directionList, '↗'))
        return '→';
    else if (isInArray(directionList, '↘') && isInArray(directionList, '↙'))
        return '↓';
    else if (isInArray(directionList, '↖') && isInArray(directionList, '↙'))
        return '←';
    return null;
}
/* 获取小队攻击爬朝向 */
function SquadAttackDirection(SquadData) {
    var directionList = [];
    for (var cName in SquadData) {
        if (!Game.creeps[cName])
            return null;
        if (Game.creeps[cName].memory.creepType == 'attack')
            directionList.push(SquadData[cName].position);
    }
    if (isInArray(directionList, '↖') && isInArray(directionList, '↗'))
        return '↑';
    else if (isInArray(directionList, '↘') && isInArray(directionList, '↗'))
        return '→';
    else if (isInArray(directionList, '↘') && isInArray(directionList, '↙'))
        return '↓';
    else if (isInArray(directionList, '↖') && isInArray(directionList, '↙'))
        return '←';
    return null;
}
/* 返回目标相对小队的大致方向 */
function SquadPosDirection(SquadData, pos) {
    /* 计算位置和小队的距离 */
    var standPos = getStandPos(SquadData);
    if (!standPos)
        return null;
    var direction_ = null;
    var Xdistance = standPos.x - pos.x; // >0代表目标X方向在小队左边 <=-2代表目标X方向在小队右边  0 -1 代表目标X方向与小队有耦合
    var Ydistance = standPos.y - pos.y; // >0代表目标Y方向在小队上面 <=-2代表目标Y方向在小队下面  0 -1 代表目标Y方向与小队有耦合
    var absXdistance = Math.abs(Xdistance); // X方向距离差的绝对值
    var absYdistance = Math.abs(Ydistance); // Y方向距离差的绝对值
    if (Xdistance > 0) // 目标X方向整体在小队左边
     {
        if (Ydistance > 0) // 目标Y方向整体在小队上面
         {
            if (absXdistance < absYdistance) // 左上偏上
             {
                direction_ = '↑';
            }
            else if (absXdistance == absYdistance) // 正左上 返回null 不必要替换方向
             {
                direction_ = '↖';
            }
            else if (absXdistance > absYdistance) // 左上偏左
             {
                direction_ = '←';
            }
        }
        else if (Ydistance <= 0 && Ydistance > -2) // 目标Y方向整体在小队左边Y方向的耦合区域
         {
            direction_ = '←';
        }
        else if (Ydistance <= -2) // 目标Y方向整体在小队下面
         {
            if (absXdistance < (absYdistance - 1)) // 左下偏下   -1是因为小队是四人小队，我们需要以↙位置的爬为参照
             {
                direction_ = '↓';
            }
            else if (absXdistance == (absYdistance - 1)) // 正左下
             {
                direction_ = '↙';
            }
            else if (absXdistance > (absYdistance - 1)) // 左下偏左
             {
                direction_ = '←';
            }
        }
    }
    else if (Xdistance <= 0 && Xdistance > -2) // 目标与小队处于X方向上的耦合区域
     {
        if (Ydistance > 0) // 目标的Y方向在小队上面
         {
            direction_ = '↑';
        }
        else if (Ydistance <= 0 && Ydistance > -2) // 不会存在的情况，除非目标在小队内
         {
            direction_ = null;
        }
        else if (Ydistance <= -2) // 目标的Y方向在小队下面
         {
            direction_ = '↓';
        }
    }
    else if (Xdistance <= -2) // 目标X方向在小队右边
     {
        if (Ydistance > 0) // 目标Y方向在小队上面
         {
            if (absXdistance - 1 < absYdistance) // 右上偏上
             {
                direction_ = '↑';
            }
            else if (absXdistance - 1 == absYdistance) // 正右上
             {
                direction_ = '↗';
            }
            else if (absXdistance - 1 > absYdistance) // 右上偏下
             {
                direction_ = '→';
            }
        }
        else if (Ydistance <= 0 && Ydistance > -2) // 目标Y方向处于耦合区域
         {
            direction_ = '→';
        }
        else if (Ydistance <= -2) // 目标Y方向处于小队下方
         {
            if (absXdistance < absYdistance) // 右下偏下
             {
                direction_ = '↓';
            }
            else if (absXdistance == absYdistance) // 正右下
             {
                direction_ = '↘';
            }
            else if (absXdistance > absYdistance) // 右下偏右
             {
                direction_ = '→';
            }
        }
    }
    return direction_;
}

/* 四人小队寻路 */
/* squad阵型寻路移动通用函数  为了更好的反应，每一tick的寻路都是实时的，比较消耗cpu (话说都打架了还考虑什么cpu？) */
function squadMove(squadData, disPos, range) {
    let standPos = getStandPos(squadData);
    if (!standPos)
        return;
    const result = PathFinder.search(standPos, { pos: disPos, range: range }, {
        plainCost: 1,
        swampCost: 5,
        maxOps: 4000,
        roomCallback: roomName => {
            // 在绕过房间列表的房间将直接不让走
            if (Memory.bypassRooms && Memory.bypassRooms.includes(roomName))
                return false;
            const room_ = Game.rooms[roomName];
            let costs = new PathFinder.CostMatrix;
            /** 设置地形 */
            const terrian = new Room.Terrain(roomName);
            /* 第一层设置沼泽 */
            for (let x = 0; x < 50; x++)
                for (let y = 0; y < 50; y++) {
                    if (terrian.get(x, y) == TERRAIN_MASK_SWAMP) {
                        costs.set(x, y, 5);
                        if (x > 2) {
                            costs.set(x - 1, y, 5);
                        }
                        if (y > 2) {
                            costs.set(x, y - 1, 5);
                        }
                        if (x > 2 && y > 2) {
                            costs.set(x - 1, y - 1, 5);
                        }
                    }
                }
            /* 第二层设置墙壁 */
            for (let x = 0; x < 50; x++)
                for (let y = 0; y < 50; y++) {
                    if (terrian.get(x, y) == TERRAIN_MASK_WALL) {
                        costs.set(x, y, 0xff);
                        if (x > 2) {
                            costs.set(x - 1, y, 0xff);
                        }
                        if (y > 2) {
                            costs.set(x, y - 1, 0xff);
                        }
                        if (x > 2 && y > 2) {
                            costs.set(x - 1, y - 1, 0xff);
                        }
                    }
                }
            if (!room_) {
                /* 没有视野就不访问其他内容 */
                return;
            }
            // 将其他地图中的道路设置为1，无法行走的建筑设置为255
            room_.find(FIND_STRUCTURES).forEach(struct => {
                if (struct.structureType !== STRUCTURE_CONTAINER && struct.structureType !== STRUCTURE_ROAD &&
                    (struct.structureType !== STRUCTURE_RAMPART || !struct.my)) {
                    costs.set(struct.pos.x, struct.pos.y, 0xff);
                    costs.set(struct.pos.x - 1, struct.pos.y, 0xff);
                    costs.set(struct.pos.x, struct.pos.y - 1, 0xff);
                    costs.set(struct.pos.x - 1, struct.pos.y - 1, 0xff);
                }
            });
            /* 防止撞到其他虫子造成堵虫 */
            room_.find(FIND_CREEPS).forEach(creep => {
                /* 是要不是四人小队的爬都设置成255 */
                if (!isInArray(Object.keys(squadData), creep.name)) {
                    costs.set(creep.pos.x, creep.pos.y, 255);
                    costs.set(creep.pos.x - 1, creep.pos.y, 255);
                    costs.set(creep.pos.x, creep.pos.y - 1, 255);
                    costs.set(creep.pos.x - 1, creep.pos.y - 1, 255);
                }
            });
            return costs;
        }
    });
    /* 获取移动方向 */
    var direction = standPos.getDirectionTo(result.path[0]);
    if (!direction)
        return;
    for (var c in squadData) {
        if (Game.creeps[c]) {
            /* 如果有疲劳单位，就停止 */
            if (Game.creeps[c].fatigue)
                return;
            /* 如果没有腿子,就停止 */
            if (Game.creeps[c].getActiveBodyparts('move') <= 0)
                return;
            if (!SquadReady(squadData))
                return;
            /* 如果检测到要移动的方向是墙壁，就停止 */
            if (result.path[0].x <= 48 && result.path[0].y <= 48) {
                var nextPostion = new RoomPosition(result.path[0].x + SquadPos[squadData[c].position][0], result.path[0].y + SquadPos[squadData[c].position][1], result.path[0].roomName);
                if (nextPostion) {
                    if (nextPostion.lookFor(LOOK_TERRAIN)[0] == 'wall') {
                        Game.creeps[c].say("❗");
                        return;
                    }
                }
            }
        }
    }
    for (var c in squadData) {
        if (Game.creeps[c]) {
            Game.creeps[c].move(direction);
        }
    }
}
/* 判定小队是否已经接近目标了 */
function squadNear(squadData, disPos) {
    for (var i in squadData) {
        if (Game.creeps[i] && Game.creeps[i].pos.isNearTo(disPos)) {
            return true;
        }
    }
    return false;
}

/* 四人小队基本行为 */
/* 小队战术动作 斜插 */
function SquadCross(SquadData) {
    for (var cName in SquadData) {
        if (Game.creeps[cName] && Game.creeps[cName].fatigue)
            return;
    }
    for (var cName in SquadData) {
        if (!Game.creeps[cName])
            continue;
        Game.creeps[cName].move(SquadDirection[crossConst[SquadData[cName].position]]);
        SquadData[cName].position = tactical['cross'][SquadData[cName].position];
    }
}
/* 小队战术动作 右转 */
function SquadRight(SquadData) {
    for (var cName in SquadData) {
        if (Game.creeps[cName] && Game.creeps[cName].fatigue)
            return;
    }
    for (var cName in SquadData) {
        if (!Game.creeps[cName])
            continue;
        Game.creeps[cName].move(SquadDirection[rightConst[SquadData[cName].position]]);
        SquadData[cName].position = tactical['right'][SquadData[cName].position];
    }
}
/* 小队战术动作 左转 */
function SquadLeft(SquadData) {
    for (var cName in SquadData) {
        if (Game.creeps[cName] && Game.creeps[cName].fatigue)
            return;
    }
    for (var cName in SquadData) {
        if (!Game.creeps[cName])
            continue;
        Game.creeps[cName].move(SquadDirection[leftConst[SquadData[cName].position]]);
        SquadData[cName].position = tactical['left'][SquadData[cName].position];
    }
}
/* 进入目标房间前使用  治疗爬方向朝向目标房间的入口 */
function initSquad(thisRoom, disRoom, SquadData) {
    var Healdirection = SquadHealDirection(SquadData);
    if (Healdirection == null) {
        return;
    }
    else if (Healdirection == '←') {
        switch (Game.rooms[thisRoom].findExitTo(disRoom)) {
            case FIND_EXIT_LEFT: {
                break;
            }
            case FIND_EXIT_RIGHT: {
                SquadCross(SquadData);
                break;
            }
            case FIND_EXIT_BOTTOM: {
                SquadLeft(SquadData);
                break;
            }
            case FIND_EXIT_TOP: {
                SquadRight(SquadData);
                break;
            }
        }
    }
    else if (Healdirection == '→') {
        switch (Game.rooms[thisRoom].findExitTo(disRoom)) {
            case FIND_EXIT_LEFT: {
                SquadCross(SquadData);
                break;
            }
            case FIND_EXIT_RIGHT: {
                break;
            }
            case FIND_EXIT_BOTTOM: {
                SquadRight(SquadData);
                break;
            }
            case FIND_EXIT_TOP: {
                SquadLeft(SquadData);
                break;
            }
        }
    }
    else if (Healdirection == '↑') {
        switch (Game.rooms[thisRoom].findExitTo(disRoom)) {
            case FIND_EXIT_LEFT: {
                SquadLeft(SquadData);
                break;
            }
            case FIND_EXIT_RIGHT: {
                SquadRight(SquadData);
                break;
            }
            case FIND_EXIT_BOTTOM: {
                SquadCross(SquadData);
                break;
            }
            case FIND_EXIT_TOP: {
                break;
            }
        }
    }
    else if (Healdirection == '↓') {
        switch (Game.rooms[thisRoom].findExitTo(disRoom)) {
            case FIND_EXIT_LEFT: {
                SquadRight(SquadData);
                break;
            }
            case FIND_EXIT_RIGHT: {
                SquadLeft(SquadData);
                break;
            }
            case FIND_EXIT_BOTTOM: {
                break;
            }
            case FIND_EXIT_TOP: {
                SquadCross(SquadData);
                break;
            }
        }
    }
    return;
}
/* 根据小队攻击爬的方向和目标方向进行战术动作 使得攻击爬方向朝向目标方向 */
function SquadAttackOrient(Attackdirection, direction_, SquadData) {
    /* 根据自己的方向进行旋转 */
    if (Attackdirection == '←') {
        switch (direction_) {
            case '←': {
                break;
            }
            case '→': {
                SquadCross(SquadData);
                break;
            }
            case '↓': {
                SquadLeft(SquadData);
                break;
            }
            case '↑': {
                SquadRight(SquadData);
                break;
            }
        }
    }
    else if (Attackdirection == '→') {
        switch (direction_) {
            case '←': {
                SquadCross(SquadData);
                break;
            }
            case '→': {
                break;
            }
            case '↓': {
                SquadRight(SquadData);
                break;
            }
            case '↑': {
                SquadLeft(SquadData);
                break;
            }
        }
    }
    else if (Attackdirection == '↑') {
        switch (direction_) {
            case '←': {
                SquadLeft(SquadData);
                break;
            }
            case '→': {
                SquadRight(SquadData);
                break;
            }
            case '↓': {
                SquadCross(SquadData);
                break;
            }
        }
    }
    else if (Attackdirection == '↓') {
        switch (direction_) {
            case '←': {
                SquadRight(SquadData);
                break;
            }
            case '→': {
                SquadLeft(SquadData);
                break;
            }
            case '↓': {
                break;
            }
            case '↑': {
                SquadCross(SquadData);
                break;
            }
        }
    }
}
/* 小队所有队员各就各位 */
function SquadSteady(SquadData) {
    for (var i in SquadData) {
        if (!Game.creeps[i])
            continue;
        var disPos = SquadGetRoomPosition(SquadData, SquadData[i].position);
        /* 用不同的移动方式防止各种bug */
        if (Game.time % 3)
            Game.creeps[i].moveTo(disPos);
        else
            Game.creeps[i].goTo(disPos, 0);
    }
}
/* 小队寻找旗帜 */
function SquadColorFlagRange(SquadData, color) {
    /* 先寻找小队左上角的坐标 */
    var standedCreep = SquadGetPosCreep(SquadData, '↖');
    if (!standedCreep)
        return null;
    var disFlag = standedCreep.pos.findClosestByRange(FIND_FLAGS, { filter: (flag) => {
            return flag.color == color;
        } });
    if (disFlag)
        return disFlag;
    return null;
}
/* 小队寻找某类旗帜  （有问题）*/
// export function SquadNameFlagPath(SquadData:Squad,name:string):Flag{
//     let pos_ = getStandPos(SquadData)
//     if (!pos_) return null
//     let disFlag = pos_.findClosestByPath(FIND_FLAGS,{filter:(flag)=>{
//         return flag.name.indexOf(name) == 0
// }})
// if (disFlag) return disFlag
//     return null
// }
/* 整体小队寻找某类旗帜 临时 */
function SquadNameFlagPath(SquadData, name) {
    let pos_ = getStandPos(SquadData);
    if (!pos_)
        return null;
    let flag_ = null;
    let distance_ = null;
    for (let i = pos_.x; i < (pos_.x + 2 < 50 ? pos_.x + 2 : 50); i++)
        LoopB: for (let j = pos_.y; j < (pos_.y + 2 < 50 ? pos_.y + 2 : 50); j++) {
            let thisPos = new RoomPosition(i, j, pos_.roomName);
            let disFlag = thisPos.findClosestByPath(FIND_FLAGS, { filter: (flag) => {
                    return flag.name.indexOf(name) == 0;
                } });
            if (!disFlag)
                continue LoopB;
            if (!flag_) {
                flag_ = disFlag;
                distance_ = Math.max(Math.abs(thisPos.x - disFlag.pos.x), Math.abs(thisPos.y - disFlag.pos.y)); //存储一下距离
            }
            else {
                if (disFlag == flag_)
                    continue LoopB;
                else {
                    // 判定距离
                    let thisDistance = Math.max(Math.abs(thisPos.x - disFlag.pos.x), Math.abs(thisPos.y - disFlag.pos.y));
                    if (thisDistance < distance_) {
                        flag_ = disFlag;
                        distance_ = thisDistance;
                    }
                }
            }
        }
    return flag_;
}
/* 小队行为 */
function Squadaction(SquadData) {
    for (var i in SquadData) {
        var creep = Game.creeps[i];
        if (!creep)
            continue;
        /* 治疗类型爬 */
        if (creep.memory.creepType == 'heal') {
            /* 寻找小队内血量最少的爬 */
            var woundCreep;
            for (var wc in SquadData) {
                if (Game.creeps[wc] && !woundCreep && Game.creeps[wc].hits < Game.creeps[wc].hitsMax)
                    woundCreep = Game.creeps[wc];
                if (Game.creeps[wc] && woundCreep) {
                    if (Game.creeps[wc].hits < woundCreep.hits)
                        woundCreep = Game.creeps[wc];
                }
            }
            if (woundCreep)
                creep.heal(woundCreep);
            else 
            /* 如果奶量都满的,就奶攻击爬 */
            {
                var index = SquadData[i].index;
                var disIndex;
                if (index == 1)
                    disIndex = 0;
                else if (index == 3)
                    disIndex = 2;
                else
                    disIndex = index;
                var disCreep;
                for (var Index in SquadData) {
                    if (SquadData[Index].index == disIndex && Game.creeps[Index])
                        disCreep = Game.creeps[Index];
                }
                if (!disCreep)
                    disCreep = creep;
                creep.heal(disCreep);
            }
            /* 如果有攻击部件，攻击附近血量最少的爬 */
            if (creep.getActiveBodyparts('ranged_attack') > 0) {
                var enemy = creep.pos.findInRange(FIND_HOSTILE_CREEPS, 3, { filter: (creep_) => {
                        return !isInArray(Memory.whitesheet, creep_.owner.username) && !creep_.pos.GetStructure('rampart');
                    } });
                var enemyCreep;
                if (enemy.length == 0) {
                    enemyCreep = enemy[0];
                }
                else if (enemy.length > 1) {
                    for (var ec of enemy) {
                        if (!enemyCreep)
                            enemyCreep = ec;
                        else {
                            if (ec.hits < enemyCreep.hits)
                                enemyCreep = ec;
                        }
                    }
                }
                if (enemyCreep) {
                    creep.rangedAttack(enemyCreep);
                }
                else
                    creep.rangedMassAttack();
                if (creep.memory.role == 'x-aio') ;
            }
        }
        /* 攻击类型的爬也有可能携带heal部件 */
        else if (creep.memory.creepType == 'attack') {
            /* 治疗自己 */
            if (creep.getActiveBodyparts('heal') > 0 && creep.hits < creep.hitsMax)
                creep.heal(creep);
            /* 如果有攻击部件，攻击附近血量最少的爬 */
            if (creep.getActiveBodyparts('ranged_attack') > 0) {
                var enemy = creep.pos.findInRange(FIND_HOSTILE_CREEPS, 3, { filter: (creep_) => {
                        return !isInArray(Memory.whitesheet, creep_.owner.username) && !creep_.pos.GetStructure('rampart');
                    } });
                var enemyCreep = null;
                if (enemy.length == 1) {
                    enemyCreep = enemy[0];
                }
                else if (enemy.length > 1) {
                    for (var ec of enemy) {
                        if (!enemyCreep)
                            enemyCreep = ec;
                        else {
                            if (ec.hits < enemyCreep.hits)
                                enemyCreep = ec;
                        }
                    }
                }
                if (enemyCreep) {
                    creep.rangedAttack(enemyCreep);
                }
                else
                    creep.rangedMassAttack();
            }
            if (creep.getActiveBodyparts('attack') > 0) {
                var enemy = creep.pos.findInRange(FIND_HOSTILE_CREEPS, 1, { filter: (creep_) => {
                        return !isInArray(Memory.whitesheet, creep_.owner.username) && !creep_.pos.GetStructure('rampart');
                    } });
                if (enemy.length > 0) {
                    creep.attack(enemy[0]);
                }
                else {
                    let flag = creep.pos.findInRange(FIND_FLAGS, 1, { filter: (flag) => {
                            return flag.name.indexOf('squad_attack') == 0;
                        } });
                    if (flag.length > 0) {
                        let stru = flag[0].pos.GetStructureList(['rampart', 'extension', 'spawn', 'constructedWall', 'lab', 'nuker', 'powerSpawn', 'factory', 'terminal', 'storage', 'observer', 'extractor', 'tower']);
                        if (stru.length > 0) {
                            creep.attack(stru[0]);
                        }
                        else {
                            flag[0].remove();
                        }
                    }
                }
            }
            if (creep.getActiveBodyparts('work') > 0) {
                let flag = creep.pos.findInRange(FIND_FLAGS, 1, { filter: (flag) => {
                        return flag.name.indexOf('squad_attack') == 0;
                    } });
                if (flag.length > 0) {
                    let stru = flag[0].pos.GetStructureList(['rampart', 'extension', 'spawn', 'constructedWall', 'lab', 'nuker', 'powerSpawn', 'factory', 'terminal', 'storage', 'observer', 'extractor', 'tower']);
                    if (stru.length > 0) {
                        creep.dismantle(stru[0]);
                    }
                    else {
                        flag[0].remove();
                    }
                }
            }
        }
    }
}

/* 四人小队框架控制 */
/**
 * 只是壳子 由于比较懒，无限期延迟开发，不保证没有bug
 */
// 主程序执行
function SquadManager() {
    if (!Memory.squadMemory)
        Memory.squadMemory = {};
    for (var squadID in Memory.squadMemory) {
        /* 先检查该任务的爬是否已经死光，如果死光了就清除数据 */
        let del = true;
        for (var creepName in Memory.squadMemory[squadID].creepData) {
            if (Game.creeps[creepName])
                del = false;
        }
        if (del) {
            delete Memory.squadMemory[squadID];
            continue;
        }
        /* 删除无用数据 */
        if (Game.time % 50 == 0) {
            for (var i in Memory.RoomControlData) {
                if (Game.rooms[i] && Game.rooms[i].controller.level >= 8) {
                    if (Game.rooms[i].MissionNum('Creep', '四人小队') <= 0) {
                        Game.rooms[i].memory.squadData = {};
                    }
                    else {
                        if (Game.rooms[i].memory.squadData[squadID])
                            delete Game.rooms[i].memory.squadData[squadID];
                    }
                }
            }
        }
        /* 运行框架 */
        squadFrameWork(squadID);
    }
}
// 小队通用执行框架
function squadFrameWork(squardID) {
    var Data = Memory.squadMemory[squardID];
    if (!Data)
        return;
    /* 小队Memory中的爬虫数据 */
    var squadData = Data.creepData;
    /* 如果小队没有组队或者脱离组队，要进行的操作 */
    if (!Data.ready) {
        if (!SquadReady(squadData)) {
            SquadSteady(squadData);
        }
        else {
            Data.ready = true;
        }
        return;
    }
    /* 如果小队因为某些原因脱离了组队，需要赶紧组队 */
    if (!SquadReady(squadData)) {
        SquadSteady(squadData);
        Data.ready = false;
        return;
    }
    /* 检测房间内是否有敌对爬 */
    var hasEnemy = false;
    for (const creepName in squadData) {
        var myCreep = Game.creeps[creepName];
        if (!myCreep)
            continue;
        var roomEnemy = myCreep.room.find(FIND_HOSTILE_CREEPS, {
            filter: (creep_) => {
                return !isInArray(Memory.whitesheet, creep_.owner.username) && !creep_.pos.GetStructure('rampart') &&
                    (creep_.getActiveBodyparts(ATTACK) > 0 || creep_.getActiveBodyparts(RANGED_ATTACK) > 0 || creep_.getActiveBodyparts(HEAL) > 0 || creep_.getActiveBodyparts(TOUGH) > 0);
            }
        });
        if (roomEnemy.length > 0) {
            hasEnemy = true;
        }
    }
    /* 如果小队还没有到目标房间 */
    if (!SquadArrivedRoom(squadData, Data.disRoom)) {
        /* 如果有蓝色旗帜，优先去蓝色旗帜那里集结  [临时] */
        var blueFlag = SquadColorFlagRange(squadData, COLOR_BLUE);
        if (!Data.gather && blueFlag) {
            squadMove(squadData, blueFlag.pos, 0);
            if (squadNear(squadData, blueFlag.pos)) {
                Data.gather = true;
            }
            return;
        }
        /* 优先调整坐标 */
        if (!Data.init) {
            Data.init = true;
            initSquad(Data.presentRoom, Data.disRoom, squadData);
            return;
        }
        squadMove(squadData, new RoomPosition(25, 25, Data.disRoom), 10);
        if (hasEnemy) {
            Squadaction(squadData);
        }
        return;
    }
    /* 小队行为 攻击周围的敌人和建筑*/
    Squadaction(squadData);
    /* retreat_xx 是紧急撤退标志 */
    var retreatFlag = SquadNameFlagPath(squadData, 'retreat');
    if (retreatFlag) {
        squadMove(squadData, retreatFlag.pos, 0);
        if (squadNear(squadData, retreatFlag.pos)) {
            retreatFlag.remove();
        }
        return;
    }
    let attack_flag = SquadNameFlagPath(squadData, 'squad_attack');
    if (attack_flag) {
        if ((attack_flag.pos.lookFor(LOOK_STRUCTURES).length <= 0) || attack_flag.pos.findInRange(FIND_HOSTILE_CREEPS, 5).length <= 0)
            attack_flag.remove();
        else {
            var Attackdirection = SquadAttackDirection(Data.creepData);
            if (SquadPosDirection(squadData, attack_flag.pos) != null && Attackdirection != SquadPosDirection(squadData, attack_flag.pos)) {
                if (!isInArray(['↙', '↗', '↘', '↖'], SquadPosDirection(squadData, attack_flag.pos))) {
                    SquadAttackOrient(Attackdirection, SquadPosDirection(squadData, attack_flag.pos), squadData);
                    return;
                }
            }
            if (!squadNear(squadData, attack_flag.pos)) {
                console.log('');
                squadMove(squadData, attack_flag.pos, 1);
            }
        }
    }
    else {
        let standCreep = getStandCreep(squadData);
        if (!standCreep)
            return;
        var clostStructure = standCreep.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES, {
            filter: (struc) => {
                return !isInArray([STRUCTURE_CONTROLLER, STRUCTURE_STORAGE], struc.structureType);
            }
        });
        if (clostStructure) {
            clostStructure.pos.createFlag(`squad_attack_${Math.random().toString(36).substr(3)}`, COLOR_WHITE);
            return;
        }
        var closestCreep = standCreep.pos.findClosestByPath(FIND_HOSTILE_CREEPS, {
            filter: (creep_) => {
                return !isInArray(Memory.whitesheet, creep_.owner.username) && !creep_.pos.GetStructure('rampart') &&
                    (creep_.getActiveBodyparts(ATTACK) > 0 || creep_.getActiveBodyparts(RANGED_ATTACK) > 0 || creep_.getActiveBodyparts(HEAL) > 0 || creep_.getActiveBodyparts(TOUGH) > 0);
            }
        });
        if (closestCreep) {
            closestCreep.pos.createFlag(`squad_attack_${Math.random().toString(36).substr(3)}`, COLOR_WHITE);
            return;
        }
    }
    if (!attack_flag)
        return;
}
const squadWarMoudle = {
    tickEnd: SquadManager
};

function stateScanner() {
    // 每 20 tick 运行一次
    if (Game.time % 20)
        return;
    if (!Memory.stats)
        Memory.stats = {};
    // 统计 GCL / GPL 的升级百分比和等级
    Memory.stats.gclprogress = Game.gcl.progress;
    Memory.stats.gclprogressTotal = Game.gcl.progressTotal;
    Memory.stats.gclLevel = Game.gcl.level;
    Memory.stats.gplprogress = Game.gpl.progress;
    Memory.stats.gplprogressTotal = Game.gpl.progressTotal;
    Memory.stats.gplLevel = Game.gpl.level;
    // CPU 的当前使用量
    Memory.stats.cpu = Game.cpu.getUsed();
    // bucket 当前剩余量
    Memory.stats.bucket = Game.cpu.bucket;
    Memory.stats.cr = Game.market.credits;
    Memory.stats.time = Game.time;
    if (Game.time % 100)
        return;
    // Memory.stats.room = [];
    // for (var room_data in Game.rooms) {
    //     if (!Memory.RoomControlData[room_data]) continue
    // }
}
/* 平均cpu统计相关 */
function statCPU() {
    var mainEndCpu = Game.cpu.getUsed();
    if (!global.CpuData)
        global.CpuData = [];
    global.UsedCpu = mainEndCpu;
    let length_i = 100;
    if (global.CpuData.length >= length_i) {
        global.CpuData = global.CpuData.slice(1);
    }
    global.CpuData.push(global.UsedCpu);
    /* 计算平均cpu */
    var AllCpu = 0;
    for (var cData of global.CpuData) {
        AllCpu += cData;
    }
    global.AveCpu = AllCpu / global.CpuData.length;
}
function stat() {
    statCPU();
    stateScanner();
}
const statMoudle = {
    tickEnd: stat
};

/**
 * 主运行函数
 */
const app = createApp({ roomRunner, creepRunner, powerCreepRunner });
app.on(memoryInit); // 记忆初始化
app.on(createGlobalExtension()); // 原型拓展挂载
app.on(crossShardAppPlugin); // 跨shard相关
app.on(creepRecycleAndStatistic); // 爬虫记忆回收及数目统计
app.on(squadWarMoudle); // 四人小队战斗框架
app.on(ResourceDispatchDelayManager); // 资源调度超时管理器
app.on(pixelManager); // 搓像素
app.on(layoutVisualMoudle); // 房间布局可视化
app.on(towerDataVisual); // 防御塔数据可视化
app.on(statMoudle); //  数据统计模块
const loop = app.run;

exports.loop = loop;
//# sourceMappingURL=main.js.map
